<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>BabylonCandle</title>
        <link>http://blog.ssanj.net</link>
        <description><![CDATA[The blog of Sanjiv Sahayam]]></description>
        <atom:link href="http://blog.ssanj.net/feed.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Tue, 30 Oct 2018 00:00:00 UT</lastBuildDate>
        <item>
    <title>Xiaomi Mi A1 Hotspot Fix on Telstra</title>
    <link>http://blog.ssanj.net/posts/2018-10-30-xiaomi-mi-a1-hotspot-fix.html</link>
    <description><![CDATA[<div class="figure">
<img src="https://i01.appmifile.com/webfile/globalimg/zh/goods/mi_a1/kind-red.jpg" alt="xma" />
<p class="caption">xma</p>
</div>
<p>I’m really enjoying having moved to the <a href="https://www.mi.com/in/mi-a1">Xiaomi Mi A1</a> from my iPhone 6. For $A250 that’s an absolute steal. One issue that has plague this phone is that the hotspot does not work as advertised. This has been an issue until recently when I stumbled across a fix that worked for me:</p>
<ol style="list-style-type: decimal">
<li><p>Got to <em>Settings</em> &gt; <em>Network &amp; Internet</em> &gt; <em>Mobile Network</em> &gt; <em>Advanced</em> &gt; <em>Access Point Names</em> &gt; <em>Telstra Internet</em></p></li>
<li><p>Change <strong>APN</strong> Type from:</p></li>
</ol>
<pre class="terminal scrollx"><code>default, supl</code></pre>
<p>to</p>
<pre class="terminal scrollx"><code>default,supl,dun</code></pre>
<p>And that should be about it. Happy hotspotting! :)</p>]]></description>
    <pubDate>Tue, 30 Oct 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-10-30-xiaomi-mi-a1-hotspot-fix.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Rebasing with Git Pull by Default</title>
    <link>http://blog.ssanj.net/posts/2018-10-30-rebasing-with-git-pull-by-default.html</link>
    <description><![CDATA[<p>Sometimes when pulling changes from a remote repository you are left with a somewhat ugly merge. This leaves you wishing you had rebased instead. Wouldn’t it be nice if you could rebase everytime you <code>git pull</code> automatically? And now you can with another simple configuration option:</p>
<pre class="command scrollx"><code>git config --global --bool pull.rebase true</code></pre>]]></description>
    <pubDate>Tue, 30 Oct 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-10-30-rebasing-with-git-pull-by-default.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>How to Push Git Tags with Commit</title>
    <link>http://blog.ssanj.net/posts/2018-10-30-how-to-push-git-tags-with-commit.html</link>
    <description><![CDATA[<p>When pushing code that has some tags to a remote repository, you need to first push the commits with:</p>
<pre class="command scrollx"><code>git push</code></pre>
<p>and then follow with:</p>
<pre class="command scrollx"><code>git push --tags</code></pre>
<p>Wouldn’t it be nice if you could push the commits and tags in one go? Well now you can by setting one simple config option:</p>
<pre class="command scrollx"><code>git config --global push.followTags true</code></pre>
<p>From the git documentation:</p>
<blockquote>
<p>push.followTags If set to true enable –follow-tags option by default. You may override this configuration at time of push by specifying –no-follow-tags.</p>
</blockquote>
<blockquote>
<p>–follow-tags Push all the refs that would be pushed without this option, and also push annotated tags in refs/tags that are missing from the remote but are pointing at commit-ish that are reachable from the refs being pushed.</p>
</blockquote>
<p>References:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/3745135/push-git-commits-tags-simultaneously">Push git commits &amp; tags simultaneously</a>,</li>
<li><a href="https://git-scm.com/docs/git-config/2.4.1">git-conig</a></li>
</ul>]]></description>
    <pubDate>Tue, 30 Oct 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-10-30-how-to-push-git-tags-with-commit.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>How to Show Git Commit Hash for Tags</title>
    <link>http://blog.ssanj.net/posts/2018-10-17-how-to-show-git-commit-hash-for-tags.html</link>
    <description><![CDATA[<p>To list the commit hash for every tag in a repo use:</p>
<pre class="command scrollx"><code>git show-ref --tags</code></pre>
<p>which yields something like:</p>
<pre class="terminal scrollx"><code>ee02aa7363f9988af700ab136a219c455cab4b5f refs/tags/v.0.4.0
2d5befba5bc80a69c6308d2a5da965488e6bf9d7 refs/tags/v.0.4.1
0099c11405a3ace8ee14b0881f9677bfc1e30f5e refs/tags/v0.4.1</code></pre>
<p>To only list the commit hash for a particular tag use:</p>
<pre class="command scrollx"><code>git show-ref tag_name</code></pre>
<p>for example, to list the commit hash for v0.4.1 use:</p>
<pre class="command scrollx"><code>git show-ref v0.4.1</code></pre>
<p>which gives you a single hash:</p>
<pre class="terminal scrollx"><code>0099c11405a3ace8ee14b0881f9677bfc1e30f5e refs/tags/v0.4.1</code></pre>
<p>To display the contents of a hash use:</p>
<pre class="command scrollx"><code>git show hash</code></pre>]]></description>
    <pubDate>Wed, 17 Oct 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-10-17-how-to-show-git-commit-hash-for-tags.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Defining a multiline function in Haskell using Ghci</title>
    <link>http://blog.ssanj.net/posts/2018-08-09-defining-a-multiline-function-in-haskell-using-ghci.html</link>
    <description><![CDATA[<p>I’ve always found it difficult to remember the exact syntax for setting Ghci into multiline mode and defining a function therein. Below are the steps for easy access.</p>
<p>Start by setting Ghci into multiline mode with:</p>
<pre class="command scrollx"><code>:set +m</code></pre>
<p>You can start a multiline block with <code>:{</code> and end it with <code>:}</code>.</p>
<p>Function definitions must be preceded with <code>let</code>. This has tripped me up many times.</p>
<p>For example, to define a function that pauses for a given delay before printing out “done”:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="fu">:</span>{
  <span class="kw">let</span><span class="ot"> printAfter ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
      printAfter delay <span class="fu">=</span>
        <span class="kw">do</span> putStrLn <span class="fu">$</span> (\d <span class="ot">-&gt;</span> <span class="st">&quot;waiting for &quot;</span> <span class="fu">++</span> d <span class="fu">++</span> <span class="st">&quot; microseconds&quot;</span>) <span class="fu">$</span> show delay
           threadDelay delay
           putStrLn <span class="st">&quot;done&quot;</span>
<span class="fu">:</span>}</code></pre></div>
<p>To unset multiline mode use:</p>
<pre class="command scrollx"><code>:unset +m</code></pre>
<p>References: <a href="https://stackoverflow.com/questions/8443035/multi-line-commands-in-ghci">Multi-line commands in GHCi</a>, <a href="https://stackoverflow.com/questions/2846050/how-to-define-a-function-in-ghci-across-multiple-lines">How to define a function in ghci across multiple lines?</a></p>]]></description>
    <pubDate>Thu, 09 Aug 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-08-09-defining-a-multiline-function-in-haskell-using-ghci.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Loading a Package into GHCi through Stack</title>
    <link>http://blog.ssanj.net/posts/2018-04-10-loading-a-package-into-ghci-through-stack.html</link>
    <description><![CDATA[<p>Ever wanted to play around with a particular set of packages in GHCi but didn’t want to setup a project? You’re in luck. With Stack you can now selectively load named packages and launch directly into GHCi. The incantation you need is:</p>
<pre class="terminal scrollx"><code>stack ghci --package [package-name1] --package [package-name2]</code></pre>
<p>For example to load the transformers package:</p>
<pre class="terminal scrollx"><code>stack ghci --package transformers</code></pre>
<p>And now we have transformers loaded in GHCi:</p>
<pre class="command scrollx"><code>*Main Lib&gt; import Control.Monad.
Control.Monad.Fail                 Control.Monad.Trans.Except
Control.Monad.Fix                  Control.Monad.Trans.Identity
Control.Monad.IO.Class             Control.Monad.Trans.List
Control.Monad.Instances            Control.Monad.Trans.Maybe
Control.Monad.ST                   Control.Monad.Trans.RWS
Control.Monad.ST.Lazy              Control.Monad.Trans.RWS.Lazy
Control.Monad.ST.Lazy.Safe         Control.Monad.Trans.RWS.Strict
Control.Monad.ST.Lazy.Unsafe       Control.Monad.Trans.Reader
Control.Monad.ST.Safe              Control.Monad.Trans.State
Control.Monad.ST.Strict            Control.Monad.Trans.State.Lazy
Control.Monad.ST.Unsafe            Control.Monad.Trans.State.Strict
Control.Monad.Signatures           Control.Monad.Trans.Writer
Control.Monad.Trans.Class          Control.Monad.Trans.Writer.Lazy
Control.Monad.Trans.Cont           Control.Monad.Trans.Writer.Strict
Control.Monad.Trans.Error          Control.Monad.Zip
*Main Lib&gt; import Control.Monad.Trans.Writer.Lazy</code></pre>
<p><a href="https://stackoverflow.com/questions/39848576/load-a-new-package-in-ghci-using-stack#39848577">Reference</a></p>]]></description>
    <pubDate>Tue, 10 Apr 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-04-10-loading-a-package-into-ghci-through-stack.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>How does filterM work in Haskell?</title>
    <link>http://blog.ssanj.net/posts/2018-04-10-how-does-filterm-work-in-haskell.html</link>
    <description><![CDATA[<p><strong>filterM</strong> is an interesting function. In one sense it’s very similar to <strong>filter</strong> which we all know and love. It’s much more powerful though as we shall soon see. Let’s start by having a look at the definition of <strong>filter</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filter<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</code></pre></div>
<p>and then at filterM:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">filterM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</code></pre></div>
<p>A side-by-side comparison:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filter<span class="ot"> ::</span>                   (a <span class="ot">-&gt;</span>   <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span>   [a]
<span class="ot">filterM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</code></pre></div>
<p>By comparing the type signatures of <strong>filter</strong> and <strong>filterM</strong> we can see that <strong>filterM</strong> is just <strong>filter</strong> where the conditional expression yields a <strong>Bool</strong> within a context <strong>m</strong> and where the matching results are aggregated in the <strong>m</strong> context.</p>
<p>The implementation of <strong>filterM</strong> in <a href="https://hackage.haskell.org/package/base-4.11.0.0/docs/src/Control.Monad.html#filterM">GCH base</a> is as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">filterM   ::</span> (<span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]
filterM p <span class="fu">=</span> foldr (\x <span class="ot">-&gt;</span> liftA2 (\flg <span class="ot">-&gt;</span> <span class="kw">if</span> flg <span class="kw">then</span> (x<span class="fu">:</span>) <span class="kw">else</span> id) (p x)) (pure [])</code></pre></div>
<p>From the above definition it looks like whenever the monadic filter function <code>(a -&gt; m Bool)</code> returns a <code>m True</code>, the value in the supplied list is prepended to an accumulator, and if it doesn’t match the existing accumulator is left unchanged.</p>
<p>Although this sound very simple, I found the usage of <strong>filterM</strong> to be somewhat difficult to understand - at least at first. Let’s start investigating its usage by looking at some example instances for <strong>m</strong>.</p>
<h2 id="maybe">Maybe</h2>
<p>Given a list of numbers:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">numbers ::</span> [<span class="dt">Int</span>]
numbers <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</code></pre></div>
<p>and an <strong>isEven</strong> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">isEven ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isEven n <span class="fu">=</span> n <span class="ot">`mod`</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">0</span></code></pre></div>
<p>we can use <strong>filterM</strong> to filter the list of numbers that are even and return the results in a <strong>Maybe</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM (<span class="dt">Just</span> <span class="fu">.</span> isEven) numbers</code></pre></div>
<p>which results in:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">Just</span> [<span class="dv">2</span>,<span class="dv">4</span>]</code></pre></div>
<p>That seems pretty easy. Using <strong>filter</strong> on <strong>numbers</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filter isEven numbers</code></pre></div>
<p>we get:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">[<span class="dv">2</span>,<span class="dv">4</span>]</code></pre></div>
<p>The only difference between the results being that the <strong>filterM</strong> variant has the results in the <strong>Maybe</strong> Monad.</p>
<p>What happens when <strong>filterM</strong> takes a function that can return <strong>Nothing</strong> in some instances?</p>
<p>Given the following function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">isDivisibleByThree ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isDivisibleByThree n <span class="fu">=</span> n <span class="ot">`mod`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span></code></pre></div>
<p>Let’s filter our list of numbers so that they contain even numbers, but if we encounter a number that is divisible by three, we want to bail on the result:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM (\n <span class="ot">-&gt;</span> <span class="kw">if</span> isDivisibleByThree n <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (isEven n)) numbers</code></pre></div>
<p>this results in:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">Nothing</span></code></pre></div>
<p>Now, this might be a little surprising. What happened to all the matches until we encountered a three, such as two? Recall that the <strong>filterM</strong> implementation:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM p <span class="fu">=</span> foldr (\x <span class="ot">-&gt;</span> liftA2 (\flg <span class="ot">-&gt;</span> <span class="kw">if</span> flg <span class="kw">then</span> (x<span class="fu">:</span>) <span class="kw">else</span> id) (p x)) (pure [])</code></pre></div>
<p>uses <strong>liftA2</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">liftA2 ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</code></pre></div>
<p>to run a binary function over the Applicative instances. With two <strong>Maybe</strong> instances, the result is always <strong>Nothing</strong>, if one of them is <strong>Nothing</strong> as you can’t run the function without both inputs:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">liftA2 (<span class="fu">+</span>) (<span class="dt">Just</span> <span class="dv">1</span>) (<span class="dt">Just</span> <span class="dv">2</span>) <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">3</span>
liftA2 (<span class="fu">+</span>) (<span class="dt">Just</span> <span class="dv">1</span>) <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">Nothing</span>
liftA2 (<span class="fu">+</span>) <span class="dt">Nothing</span> (<span class="dt">Just</span> <span class="dv">2</span>)  <span class="fu">=</span> <span class="dt">Nothing</span>
liftA2 (<span class="fu">+</span>) <span class="dt">Nothing</span> <span class="dt">Nothing</span>   <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>What this demonstrates is that if we ever receive a <strong>Nothing</strong> value while using <strong>filterM</strong> all results up until that point are discarded. This highlights one key difference between <strong>filter</strong> and <strong>filterM</strong>; in addition to filtering on the <strong>Bool</strong> result, <strong>filterM</strong> also combines the results using its Applicative properties.</p>
<p>Let’s run the <strong>filterM</strong> code once again, but this time, we’ll leave out any multiples of three:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM (\n <span class="ot">-&gt;</span> <span class="kw">if</span> isDivisibleByThree n <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (isEven n)) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">8</span>]</code></pre></div>
<p>and this time the answer is:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">Just</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">8</span>]</code></pre></div>
<h2 id="io">IO</h2>
<p>Let’s try filtering only even numbers using the <strong>IO</strong> Monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">ioFilterM (pure <span class="fu">.</span> isEven) numbers
<span class="fu">=</span> [<span class="dv">2</span>, <span class="dv">4</span>] <span class="co">-- IO [Int]</span></code></pre></div>
<p>That works as expected. Now let’s introduce a failure in <strong>IO</strong> Monad when a number is divisible by three:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM (\n <span class="ot">-&gt;</span> <span class="kw">if</span> isDivisibleByThree n <span class="kw">then</span> ioError (userError <span class="st">&quot;boom!&quot;</span>) <span class="kw">else</span> pure (isEven n)) numbers
<span class="fu">=</span> <span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> user error (boom<span class="fu">!</span>) <span class="co">-- IO [Int]</span></code></pre></div>
<p>The above discards any results collected once it reaches an <strong>IO</strong> error. This functionality is very similar to how the <strong>Maybe</strong> Monad filtered when it received a <strong>Nothing</strong>. This is quite useful when filtering only valid results and failing on the first failure.</p>
<p>And if we remove any numbers divisible by three:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM (\n <span class="ot">-&gt;</span> <span class="kw">if</span> isDivisibleByThree n <span class="kw">then</span> ioError (userError <span class="st">&quot;boom!&quot;</span>) <span class="kw">else</span> pure (isEven n)) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">8</span>]
<span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">8</span>] <span class="co">-- IO [Int]</span></code></pre></div>
<p>we get back the expected results.</p>
<h2 id="list">List</h2>
<p>With List, things get more interesting. Consider the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM (\n <span class="ot">-&gt;</span> [<span class="dt">True</span>, <span class="dt">False</span>]) numbers</code></pre></div>
<p>What do you reckon the answer would be? Probably not a <a href="https://en.wikipedia.org/wiki/Power_set">powerset</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">2</span>],
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">5</span>],[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]
,[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">2</span>,<span class="dv">4</span>],[<span class="dv">2</span>,<span class="dv">5</span>],[<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">3</span>,<span class="dv">5</span>],[<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">4</span>],
[<span class="dv">5</span>],[]]</code></pre></div>
<p>Remember that <strong>filterM</strong> is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM p <span class="fu">=</span> foldr (\x <span class="ot">-&gt;</span> liftA2 (\flg <span class="ot">-&gt;</span> <span class="kw">if</span> flg <span class="kw">then</span> (x<span class="fu">:</span>) <span class="kw">else</span> id) (p x)) (pure [])</code></pre></div>
<p>How does this work with List? If we use <strong>liftA2</strong> with List:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">liftA2 (<span class="fu">+</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
<span class="fu">=</span> [<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>]</code></pre></div>
<p>we see that we get a <a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a> of values (all combinations). List is a non-deterministic Monad and as such it produces results of every possible combination.</p>
<p>Let’s start by expanding out the point-free implementation of <strong>filterM</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM p <span class="fu">=</span>
  foldr (\x acc <span class="ot">-&gt;</span> liftA2 (\flg1 accx <span class="ot">-&gt;</span> <span class="kw">if</span> flg1 <span class="kw">then</span> (x<span class="fu">:</span>accx) <span class="kw">else</span> accx) (p x) acc) (pure [])</code></pre></div>
<p><strong>accx</strong> is the accumulator value passed to <strong>liftA2</strong>. The values passed will be the Cartesian product of <strong>[True, False]</strong> and the accumulator of list <strong>acc</strong>, which is initially <strong>[[]]</strong>.</p>
<p>There are two main expansions happening in the implementation of <strong>filterM</strong>:</p>
<ol style="list-style-type: decimal">
<li><strong>liftA2</strong> is creating a Cartesian product of the flags <strong>[True, False]</strong> and the accumulator <strong>acc</strong> and combining them with supplied function, which prepends the current value of the list <strong>x</strong> to the accumulator <strong>accx</strong> if the flag is True or returns the existing accumulator <strong>accx</strong> if it is False.</li>
<li>All the combinations returned from <strong>listA2</strong> are then returned into <strong>foldr</strong> as the new value of the accumulator <strong>acc</strong>.</li>
</ol>
<p>Because <strong>filterM</strong> is implemented using <strong>foldr</strong> the accumulated values are used from last to first.</p>
<p>Given the following legend:</p>
<pre class="terminal scrollx"><code>x      -- element in the list
acc    -- value of accumulator
accx   -- value of accumulator at current combination
flg1   -- value of flag at current combination
result -- value of accx after applying flg1
newacc -- value of acc returned to foldr</code></pre>
<p>Let’s start from the end of the list at 5 and follow it up to 1.</p>
<p>For the value of 5:</p>
<pre class="terminal scrollx"><code>x = 5
acc = [[]]
flags = [True, False]
--------------------
accx []
flg1 True
result = 5:[] =&gt; [5]
--------------------
accx []
flg1 False
result =&gt; []
--------------------
newacc = [[5], []]</code></pre>
<p>For the value of 4:</p>
<pre class="terminal scrollx"><code>x = 4
acc = [[5], []]
flags = [True, False]
--------------------
accx [5]
flg1 True
result = 4:[5] =&gt; [4,5]
--------------------
accx []
flg1 True
result = 4:[] =&gt; [4]
--------------------
accx [5]
flg1 False
result =&gt; [5]
--------------------
accx []
flg1 False
result =&gt; []
--------------------
newacc = [[4,5],[4],[5], []]</code></pre>
<p>For the value of 3:</p>
<pre class="terminal scrollx"><code>x = 3
acc = [[4,5],[4],[5], []]
flags = [True, False]
--------------------
accx [4,5]
flg1 True
result = 3:[4,5] =&gt; [3,4,5]
--------------------
accx [4]
flg1 True
result = 3:[4] =&gt; [3,4]
--------------------
accx [5]
flg1 True
result = 3:[5] =&gt; [3,5]
--------------------
accx []
flg1 True
result = 3:[] =&gt; [3]
--------------------
accx [4,5]
flg1 False
result =&gt; [4,5]
--------------------
accx [4]
flg1 False
result =&gt; [4]
--------------------
accx [5]
flg1 False
result =&gt; [5]
--------------------
accx []
flg1 False
result =&gt; []
--------------------
newacc = [[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]</code></pre>
<p>For the value of 2:</p>
<pre class="terminal scrollx"><code>x = 2
acc = [[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]
flags = [True, False]
--------------------
accx [3,4,5]
flg1 True
result = 2:[3,4,5] =&gt; [2,3,4,5]
--------------------
accx [3,4]
flg1 True
result = 2:[3,4] =&gt; [2,3,4]
--------------------
accx [3,5]
flg1 True
result = 2:[3,5] =&gt; [2,3,5]
--------------------
accx [3]
flg1 True
result = 2:[3] =&gt; [2,3]
--------------------
accx [4,5]
flg1 True
result = 2:[4,5] =&gt; [2,4,5]
--------------------
accx [4]
flg1 True
result = 2:[4] =&gt; [2,4]
--------------------
accx [5]
flg1 True
result = 2:[5] =&gt; [2,5]
--------------------
accx []
flg1 True
result = 2:[] =&gt; [2]
--------------------
accx [3,4,5]
flg1 False
result =&gt; [3,4,5]
--------------------
accx [3,4]
flg1 False
result =&gt; [3,4]
--------------------
accx [3,5]
flg1 False
result =&gt; [3,5]
--------------------
accx [3]
flg1 False
result =&gt; [3]
--------------------
accx [4,5]
flg1 False
result =&gt; [4,5]
--------------------
accx [4]
flg1 False
result =&gt; [4]
--------------------
accx [5]
flg1 False
result =&gt; [5]
--------------------
accx []
flg1 False
result =&gt; []
--------------------
newacc = [[2,3,4,5],[2,3,4],[2,3,5],[2,3],[2,4,5],[2,4],[2,5],[2],[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]</code></pre>
<p>For the value of 1:</p>
<pre class="terminal scrollx"><code>x = 1
acc = [[2,3,4,5],[2,3,4],[2,3,5],[2,3],[2,4,5],[2,4],[2,5],[2],[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]
flags = [True, False]
--------------------
accx [2,3,4,5]
flg1 True
result = 1:[2,3,4,5] =&gt; [1,2,3,4,5]
--------------------
accx [2,3,4]
flg1 True
result = 1:[2,3,4] =&gt; [1,2,3,4]
--------------------
accx [2,3,5]
flg1 True
result = 1:[2,3,5] =&gt; [1,2,3,5]
--------------------
accx [2,3]
flg1 True
result = 1:[2,3] =&gt; [1,2,3]
--------------------
accx [2,4,5]
flg1 True
result = 1:[2,4,5] =&gt; [1,2,4,5]
--------------------
accx [2,4]
flg1 True
result = 1:[2,4] =&gt; [1,2,4]
--------------------
accx [2,5]
flg1 True
result = 1:[2,5] =&gt; [1,2,5]
--------------------
accx [2]
flg1 True
result = 1:[2] =&gt; [1,2]
--------------------
accx [3,4,5]
flg1 True
result = 1:[3,4,5] =&gt; [1,3,4,5]
--------------------
accx [3,4]
flg1 True
result = 1:[3,4] =&gt; [1,3,4]
--------------------
accx [3,5]
flg1 True
result = 1:[3,5] =&gt; [1,3,5]
--------------------
accx [3]
flg1 True
result = 1:[3] =&gt; [1,3]
--------------------
accx [4,5]
flg1 True
result = 1:[4,5] =&gt; [1,4,5]
--------------------
accx [4]
flg1 True
result = 1:[4] =&gt; [1,4]
--------------------
accx [5]
flg1 True
result = 1:[5] =&gt; [1,5]
--------------------
accx []
flg1 True
result = 1:[] =&gt; [1]
-------------------- *
accx [2,3,4,5]
flg1 False
result =&gt; [2,3,4,5]
--------------------
accx [2,3,4]
flg1 False
result =&gt; [2,3,4]
--------------------
accx [2,3,5]
flg1 False
result =&gt; [2,3,5]
--------------------
accx [2,3]
flg1 False
result =&gt; [2,3]
--------------------
accx [2,4,5]
flg1 False
result =&gt; [2,4,5]
--------------------
accx [2,4]
flg1 False
result =&gt; [2,4]
--------------------
accx [2,5]
flg1 False
result =&gt; [2,5]
--------------------
accx [2]
flg1 False
result =&gt; [2]
--------------------
accx [3,4,5]
flg1 False
result =&gt; [3,4,5]
--------------------
accx [3,4]
flg1 False
result =&gt; [3,4]
--------------------
accx [3,5]
flg1 False
result =&gt; [3,5]
--------------------
accx [3]
flg1 False
result =&gt; [3]
--------------------
accx [4,5]
flg1 False
result =&gt; [4,5]
--------------------
accx [4]
flg1 False
result =&gt; [4]
--------------------
accx [5]
flg1 False
result =&gt; [5]
--------------------
accx []
flg1 False
result =&gt; []
--------------------

newacc = [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1,3,4,5],[1,3,4],[1,3,5],[1,3],[1,4,5],[1,4],[1,5],[1],[2,3,4,5],[2,3,4],[2,3,5],[2,3],[2,4,5],[2,4],[2,5],[2],[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]</code></pre>
<p>That was a bit harder than necessary!</p>
<h2 id="either">Either</h2>
<p>Using <strong>filterM</strong> with <strong>Either</strong> is pretty much the same as a <strong>Maybe</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">let</span> e1 <span class="fu">=</span> filterM (\x <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="fu">==</span> <span class="dv">11</span> <span class="kw">then</span> <span class="dt">Left</span> <span class="st">&quot;You gave me eleven&quot;</span> <span class="kw">else</span> <span class="dt">Right</span> (isEven x))
<span class="co">-- e1 :: :: Integral a =&gt; [a] -&gt; Either [Char] [a]</span>
e1 [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">10</span>]
<span class="fu">=</span> <span class="dt">Right</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>] <span class="co">-- only even numbers</span>
e1 [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">11</span>]
<span class="fu">=</span> <span class="dt">Left</span> <span class="st">&quot;You gave me eleven&quot;</span> <span class="co">-- drops all results on a Left</span></code></pre></div>
<h2 id="state">State</h2>
<p>Now let’s use a Monad that has two type holes which are both used together. The State Monad allows us to return a value and thread through some state we are interested in at the same time. Let’s use our <strong>isEven</strong> method to filter in all the even inputs and use a list to record all the values inspected along the way:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">let</span> x1 <span class="fu">=</span> filterM (\x <span class="ot">-&gt;</span> state (\s <span class="ot">-&gt;</span> (isEven(x), s <span class="fu">++</span> [x]))) [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">10</span>]
<span class="co">-- x1 :: (Integral a, Monad m) =&gt; StateT [a] m [a]</span>
evalState x1 []          <span class="co">-- get value</span>
<span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>]           <span class="co">-- only even numbers</span>
execState x1 []          <span class="co">-- get state</span>
<span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>] <span class="co">-- the state - all inspected values</span></code></pre></div>
<p>The interesting thing to note is that given <strong>x1</strong>’s type:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">x1 ::</span> (<span class="dt">Integral</span> a, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">StateT</span> [a] m [a]</code></pre></div>
<p>The <strong>m</strong> in <strong>filterM</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">filterM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</code></pre></div>
<p>is:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">StateT</span> [a] m</code></pre></div>
<p>which is why we can return a Bool in the value position and have it filter the inputs for us.</p>
<p>Hopefully that was somewhat easier to understand. You can find alternate explanations to this problem <a href="https://stackoverflow.com/questions/25476248/powerset-function-1-liner#45105085">here</a> and <a href="https://byorgey.wordpress.com/2007/06/26/deducing-code-from-types-filterm">here</a>.</p>]]></description>
    <pubDate>Tue, 10 Apr 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-04-10-how-does-filterm-work-in-haskell.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>The Consolations of Philosophy - Alain de Botton</title>
    <link>http://blog.ssanj.net/posts/2018-03-27-the-consolations-of-philosphy-alain-de-botton.html</link>
    <description><![CDATA[<p>Ideas from the book <a href="https://www.amazon.com/Consolations-Philosophy-Alain-Botton-ebook/dp/B002RI9DM4">The Consolations of Philosophy by Alain de Botton</a>.</p>
<ol style="list-style-type: decimal">
<li>The validity of an idea or action is determined not by whether it is widely believed or widely reviled but by whether it obeys the rules of logic.</li>
<li>A statement is true if it cannot be disproved.</li>
<li>The Socratic Method:
<ol style="list-style-type: decimal">
<li>Locate a statement confidently described as common sense.</li>
<li>Imagine for a moment that, despite the confidence of the person proposing it, the statement is false.</li>
<li>Search for situations or contexts where the statement would not be true.</li>
<li>If an exception is found, the definition must be false or at least imprecise.</li>
<li>The initial statement must be nuanced to take the exception into account.</li>
</ol></li>
<li>It is by finding out what something is not that one comes closest to understanding what it is.</li>
<li>We acquire a misplaced respect for others when we concentrate solely on their conclusions – which is why Socrates urged us to dwell on the logic they used to reach them.</li>
<li>The value of criticism will depend on the thought processes of critics, not on their number or rank.</li>
<li>We are making vases, we should listen to the advice of those who know about turning glaze into Fe3O4 at 800 ° C; when we are making a ship, it is the verdict of those who construct triremes that should worry us.</li>
<li>We should not look to Socrates for advice on escaping a death sentence; we should look to him as an extreme example of how to maintain confidence in an intelligent position which has met with illogical opposition.</li>
<li>Just as medicine confers no benefit if it does not drive away physical illness, so philosophy is useless if it does not drive away the suffering of the mind.</li>
<li>Before you eat or drink anything, consider carefully who you eat or drink with rather than what you eat or drink: for feeding without a friend is the life of a lion or a wolf.</li>
<li>Nothing satisfies the man who is not satisfied with a little.</li>
<li>Could one possess the desired object but not be happy? Could one be happy but not have the desired object?</li>
<li>We aren’t overwhelmed by anger whenever we are denied an object we desire, only when we believe ourselves entitled to obtain it.</li>
<li>No, he who has said ‘a day’ has granted too long a postponement to swift misfortune; an hour, an instant of time, suffices for the overthrow of empires.</li>
<li>We need metaphors to derive a sense of what cannot be seen or touched, or else we will forget.</li>
<li>The wise man can lose nothing. He has everything invested in himself. The wise man is self-sufficient. If he loses a hand through disease or war, or if some accident puts out one or both of his eyes, he will be satisfied with what is left.</li>
<li>To calm us down in noisy streets, we should trust that those making a noise know nothing of us.</li>
<li>Wisdom lies in correctly discerning where we are free to mould reality according to our wishes and where we must accept the unalterable with tranquillity.</li>
<li>We are like dogs who have been tied to an unpredictable cart.</li>
<li>We may be powerless to alter certain events, but we remain free to choose our attitude towards them, and it is in our spontaneous acceptance of necessity that we find our distinctive freedom</li>
<li>That which you cannot reform, it is best to endure.</li>
</ol>
<div>
<div class="quote">
<p>Upon the highest throne in the world, we are seated, still, upon our arses</p>
</div>
<div class="attribution">
Montaigne
</div>
<ol start="22" style="list-style-type: decimal">
<li>Every man may bear the whole form of the human condition, but it seems that no single country can tolerate the complexity of this condition.</li>
<li>Friendship is a minor conspiracy against what other people think of as reasonable.</li>
</ol>
<div>
<div class="quote">
<p>I have seen in my time hundreds of craftsmen and ploughmen wiser and happier than university rectors.</p>
</div>
<div class="attribution">
Montaigne
</div>
</div>
<ol start="24" style="list-style-type: decimal">
<li>What reads easily is rarely so written.</li>
<li>The prudent man strives for freedom from pain, not pleasure.</li>
<li>What if pleasure and displeasure were so tied together that whoever wanted to have as much as possible of one must also have as much as possible of the other?</li>
<li>In the mountains of truth you will never climb in vain: either you will get up higher today or you will exercise your strength so as to be able to get up higher tomorrow.</li>
</ol>
<div>
<div class="quote">
How can anyone become a thinker if he does not spend at least a third of the day without passions, people and books?
</div>
<div class="attribution">
Nietzsche
</div>
</div>
<ol start="28" style="list-style-type: decimal">
<li>Not everything which makes us feel better is good for us. Not everything which hurts may be bad.</li>
</ol>]]></description>
    <pubDate>Tue, 27 Mar 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-03-27-the-consolations-of-philosphy-alain-de-botton.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Functor, Applicative and Monad instances for Reader</title>
    <link>http://blog.ssanj.net/posts/2018-03-05-functor-applicative-and-monad-instances-for-reader.html</link>
    <description><![CDATA[<p>How do you define a Reader (-&gt; r) instance of a <strong>Functor</strong>, <strong>Applicative</strong> or even a <strong>Monad</strong>? A Reader is a function that takes some resource <strong>r</strong> and returns another value. This has been something that has always confused me. After an initial peruse it all makes sense for a while but when next faced with the same problem I can’t remember how these instances are implemented.</p>
<p>I’d like to analyse how the Reader instances are derived for each of <strong>Functor</strong>, <strong>Applicative</strong> and <strong>Monad</strong> and test it against some examples to gain some intuition. Also note that (-&gt; r) and (r -&gt;) can be used interchangeably. Thanks to <a href="https://www.youtube.com/watch?v=qH0EjlM9Cm4">Brian McKenna</a> for that useful titbit.</p>
<h2 id="functor">Functor</h2>
<p>A functor typeclass is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
  fmap,<span class="ot"> (&lt;$&gt;) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p><strong>fmap</strong> or <strong>&lt;$&gt;</strong> basically runs a function (<strong>a -&gt; b</strong>), on a value within some context <strong>f a</strong> and returns the context with the function applied to its value as an <strong>f b</strong>.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(a <span class="ot">-&gt;</span> b)  <span class="co">-- f&#39;, a function that requires an &#39;a&#39; to create a &#39;b&#39;</span>
f a       <span class="co">-- Functor with an &#39;a&#39;</span>
f (f&#39;(a)) <span class="co">-- apply f&#39; to the &#39;a&#39;</span>
f b       <span class="co">-- the final result of a &#39;b&#39;</span></code></pre></div>
<p>Let’s take a look at the <strong>Functor</strong> instance for <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#t:Maybe">Maybe</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  <span class="co">-- fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span>
  fmap f (<span class="dt">Just</span> a) <span class="fu">=</span>  <span class="dt">Just</span> (f a)
  fmap _ <span class="dt">Nothing</span>  <span class="fu">=</span>  <span class="dt">Nothing</span></code></pre></div>
<p>With <strong>Maybe</strong>, the function <strong>f</strong>, is applied to a value within a <strong>Just</strong> or not applied if the value is a <strong>Nothing</strong>.</p>
<p>When we hear that (-&gt; r) is also a Functor it can boggle our minds a little. How do we define an instance for that?</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="ot">-&gt;</span> r) <span class="kw">where</span>
  fmap f <span class="fu">=</span> <span class="co">-- what goes here?</span></code></pre></div>
<p>We need a function that takes some resource <strong>r</strong> and returns some other value. Let’s have a crack at deriving the implementation for Functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (r <span class="ot">-&gt;</span> ) <span class="kw">where</span>
<span class="co">-- fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span>
  fmap fab      f a       <span class="fu">=</span> f b                 <span class="co">-- refer to (a -&gt; b) as fab</span>
  fmap fab      (\r <span class="ot">-&gt;</span> a) <span class="fu">=</span> (\r <span class="ot">-&gt;</span> b)           <span class="co">-- given that the Functor is (r -&gt;), replace &#39;f&#39; with (r -&gt;)</span>
  fmap fab      fra       <span class="fu">=</span> (\r <span class="ot">-&gt;</span> b)           <span class="co">-- refer to (r -&gt; a) as fra so we can use it</span>
  fmap fab      fra       <span class="fu">=</span> (\r <span class="ot">-&gt;</span> <span class="fu">???</span> (fra r)) <span class="co">-- we have an &#39;r&#39; and we have something that needs an &#39;r&#39; and returns an &#39;a&#39;.</span>
  fmap fab      fra       <span class="fu">=</span> (\r <span class="ot">-&gt;</span> fab (fra r)) <span class="co">-- We have an &#39;a&#39; and something that needs an &#39;a&#39; to return a &#39;b&#39;</span>
  fmap fab      fra       <span class="fu">=</span> fab <span class="fu">.</span> fra           <span class="co">-- we can simplify this to composing fab and fra</span></code></pre></div>
<p>We are applying the function <strong>fab</strong> to the result of <strong>fra</strong>. It looks like <strong>fmap</strong> takes two functions are composes them.</p>
<p>Compose (.) is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span>  (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</code></pre></div>
<p>or in our case:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span>  (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> b</code></pre></div>
<p>And we can implement the Functor for (r -&gt;) with compose alone:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (r <span class="ot">-&gt;</span> ) <span class="kw">where</span>
  fmap <span class="fu">=</span> (<span class="fu">.</span>)</code></pre></div>
<p>This gives us the intuition that fmap over functions is just composition.</p>
<p>Let’s use it on an example:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">fmap (<span class="fu">*</span><span class="dv">3</span>) (<span class="fu">+</span><span class="dv">100</span>) <span class="dv">1</span></code></pre></div>
<p>What is the result of the above?</p>
<p>Let’s use function composition to get the answer:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">fmap (<span class="fu">*</span><span class="dv">3</span>) (<span class="fu">+</span><span class="dv">100</span>) <span class="dv">1</span>
<span class="fu">=</span> (\r <span class="ot">-&gt;</span> (r <span class="fu">+</span> <span class="dv">100</span>) <span class="fu">*</span> <span class="dv">3</span>) <span class="co">-- expanding Functor</span>
<span class="fu">=</span> ((<span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span>) <span class="fu">*</span> <span class="dv">3</span>)       <span class="co">-- substituting 1 for &#39;r&#39;</span>
<span class="fu">=</span> <span class="dv">303</span></code></pre></div>
<h2 id="applicative">Applicative</h2>
<p>The Applicative typeclass is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
<span class="ot">  pure  ::</span> a <span class="ot">-&gt;</span> f a
<span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>The <strong>pure</strong> function lifts some value <strong>a</strong> into the <strong>Applicative</strong>, <strong>f</strong>. Also note that <strong>f</strong> is also a <strong>Functor</strong>. The <strong>&lt;$&gt;</strong> function sequences a function from (<strong>a -&gt; b</strong>) within an <strong>Applicative</strong> context, with the value of <strong>a</strong> supplied in another <strong>Applicative</strong> context to produce the result <strong>b</strong> in a third <strong>Applicative</strong> context.</p>
<p>Note the similarities between <strong>&lt;$&gt;</strong> and &lt;*&gt;:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">fmap,<span class="ot"> (&lt;$&gt;) ::</span>   (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="ot">(&lt;*&gt;)       ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>The only difference is that with &lt;*&gt; the function is within a context <strong>f</strong>.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">f (a <span class="ot">-&gt;</span> b)  <span class="co">-- f&#39;, a function within a context &#39;f&#39;, requires an &#39;a&#39; to create a &#39;b&#39;</span>
f a         <span class="co">-- Applicative Functor with an &#39;a&#39;</span>
f (f&#39;(a))   <span class="co">-- apply f&#39; to the &#39;a&#39; within &#39;f&#39;</span>
f b         <span class="co">-- the final result of a &#39;b&#39;</span></code></pre></div>
<p>Let’s take a look at the <strong>Applicative</strong> instance for <strong>Maybe</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span>
<span class="co">-- pure  :: a -&gt; f a</span>
  pure <span class="fu">=</span> <span class="dt">Just</span>
<span class="co">-- (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span>
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Just</span> f) other <span class="fu">=</span> fmap f other
  (<span class="fu">&lt;*&gt;</span>) <span class="dt">Nothing</span>  _     <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>For <strong>Maybe</strong>, <strong>pure</strong> simply creates an instance of <strong>Just</strong> with the supplied value. With &lt;*&gt; the function <strong>f</strong> is within a <strong>Maybe</strong> context. If the context is a <strong>Just</strong>, the function is applied to the other <strong>Maybe</strong> context using <strong>fmap</strong> from the <strong>Functor</strong> typeclass. If the context is a <strong>Nothing</strong>, no function application takes place and a <strong>Nothing</strong> is returned.</p>
<p>How do we define an <strong>Applicative</strong> instance for (r -&gt;) ?</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> (r <span class="ot">-&gt;</span> ) <span class="kw">where</span>
<span class="co">-- pure  :: a -&gt; f a</span>
  pure a <span class="fu">=</span> \r <span class="ot">-&gt;</span> a
<span class="co">-- (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span>
  (<span class="fu">&lt;*&gt;</span>) f g <span class="fu">=</span> \r <span class="ot">-&gt;</span> f r (g r) <span class="co">-- f is (\r -&gt; (a -&gt; b)), g is (\r -&gt; a)</span></code></pre></div>
<p>Apply the input <strong>r</strong> to <strong>g</strong> to return an <strong>a</strong> and also apply <strong>r</strong> to <strong>f</strong>, to return the function from (<strong>a -&gt; b</strong>). Then apply the function (<strong>a -&gt; b</strong>) to <strong>a</strong> to return a <strong>b</strong>.</p>
<p>Let’s use it on an example:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> (<span class="fu">+</span><span class="dv">3</span>) <span class="fu">&lt;*&gt;</span> (<span class="fu">*</span><span class="dv">100</span>) <span class="dv">5</span>
<span class="fu">=</span> (<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> (\r <span class="ot">-&gt;</span> r <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">&lt;*&gt;</span> (\r <span class="ot">-&gt;</span> r <span class="fu">*</span> <span class="dv">100</span>) <span class="dv">5</span> <span class="co">-- expanding Applicative</span>
<span class="fu">=</span> (<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="fu">*</span> <span class="dv">100</span>)                   <span class="co">-- substituting 5 for &#39;r&#39;</span>
<span class="fu">=</span> <span class="dv">8</span> <span class="fu">+</span> <span class="dv">500</span>                                     <span class="co">-- combining with (+)</span>
<span class="fu">=</span> <span class="dv">508</span></code></pre></div>
<p>You may also notice that this gives you the same answer as <strong>liftA2</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">liftA2 ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c
liftA2 (<span class="fu">+</span>) (<span class="fu">+</span><span class="dv">3</span>) (<span class="fu">*</span><span class="dv">100</span>) <span class="dv">5</span>
<span class="fu">=</span> <span class="dv">508</span></code></pre></div>
<p>The intuition here is that, we can supply the input to each <strong>Applicative</strong> context, and then combine them with a function either through <strong>&lt;$&gt;</strong> or <strong>liftA2</strong>.</p>
<p>And here’s one more example which may seem a little hairy:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(\x y z <span class="ot">-&gt;</span> [x,y,z]) <span class="fu">&lt;$&gt;</span> (<span class="fu">+</span><span class="dv">3</span>) <span class="fu">&lt;*&gt;</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">&lt;*&gt;</span> (<span class="fu">/</span><span class="dv">2</span>) <span class="fu">$</span> <span class="dv">5</span>
<span class="fu">=</span> (\x y z <span class="ot">-&gt;</span> [x,y,z]) <span class="fu">&lt;$&gt;</span> (\r <span class="ot">-&gt;</span> r <span class="fu">+</span><span class="dv">3</span>) <span class="fu">&lt;*&gt;</span> (\r <span class="ot">-&gt;</span> <span class="fu">*</span><span class="dv">2</span>) <span class="fu">&lt;*&gt;</span> (\r <span class="ot">-&gt;</span> <span class="fu">/</span><span class="dv">2</span>) <span class="fu">$</span> <span class="dv">5</span> <span class="co">-- expand Applicative</span>
<span class="fu">=</span> (\x y z <span class="ot">-&gt;</span> [x,y,z]) <span class="fu">&lt;$&gt;</span> (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">&lt;*&gt;</span> (<span class="dv">5</span> <span class="fu">*</span> <span class="dv">2</span>) <span class="fu">&lt;*&gt;</span> (<span class="dv">5</span> <span class="fu">/</span> <span class="dv">2</span>)                <span class="co">-- replace &#39;r&#39; with 5</span>
<span class="fu">=</span> (\x y z <span class="ot">-&gt;</span> [x,y,z]) <span class="fu">&lt;$&gt;</span> (<span class="fl">8.0</span>) <span class="fu">&lt;*&gt;</span> (<span class="fl">10.0</span>) <span class="fu">&lt;*&gt;</span> (<span class="fl">2.5</span>)
<span class="fu">=</span> [<span class="fl">8.0</span>, <span class="fl">10.0</span>, <span class="fl">2.5</span>]                                                       <span class="co">-- combine with (\x y z -&gt; [x,y,z])</span></code></pre></div>
<p>The same result can be achieved with <strong>liftA3</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">liftA3 (\x y z <span class="ot">-&gt;</span> [x,y,z]) (<span class="fu">+</span><span class="dv">3</span>) (<span class="fu">*</span><span class="dv">2</span>) (<span class="fu">/</span><span class="dv">2</span>) <span class="fu">$</span> <span class="dv">5</span>
<span class="fu">=</span> [<span class="fl">8.0</span>,<span class="fl">10.0</span>,<span class="fl">2.5</span>]</code></pre></div>
<h2 id="monad">Monad</h2>
<p>The <strong>Monad</strong> typeclass is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">  (&gt;&gt;=)  ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code></pre></div>
<p>The <strong>return</strong> function lifts a value <strong>a</strong> into the <strong>Monad</strong> <strong>m</strong>. Bind or (<strong>&gt;&gt;=</strong>) sequentially composes two actions, passing any value produced by the first as an argument to the second.</p>
<p>Let’s take a look at the <strong>Monad</strong> instance for <strong>Maybe</strong> :</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span>  <span class="dt">Monad</span> <span class="dt">Maybe</span>  <span class="kw">where</span>
<span class="co">-- (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</span>
  (<span class="dt">Just</span> a) <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> k a
  <span class="dt">Nothing</span>  <span class="fu">&gt;&gt;=</span> _  <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>If the first <strong>Maybe</strong> context is a <strong>Just</strong>, then apply the function <strong>k</strong> to produce a new <strong>Maybe</strong> context. If the first <strong>Maybe</strong> context is a <strong>Nothing</strong>, then return <strong>Nothing</strong>.</p>
<p>How do we define an <strong>Monad</strong> instance for (r -&gt;) ?</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span>  <span class="dt">Monad</span> (r <span class="ot">-&gt;</span>)  <span class="kw">where</span>
<span class="co">-- return :: a -&gt; m a</span>
    return <span class="fu">=</span> pure
<span class="co">-- (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</span>
  f <span class="fu">&gt;&gt;=</span> g <span class="fu">=</span> \r <span class="ot">-&gt;</span>  g (f r) r <span class="co">-- f is (\r -&gt; a), g is (\a -&gt; \r -&gt; b)</span></code></pre></div>
<p>The <strong>return</strong> function is derived from <strong>pure</strong>, since all <strong>Monads</strong> are also <strong>Applicatives</strong>. The bind function (<strong>&gt;&gt;=</strong>) first applies the input <strong>r</strong> to <strong>f</strong> to give an <strong>a</strong>. It then applies the <strong>a</strong> to <strong>g</strong> to return a function from (<strong>r -&gt; b</strong>). The input <strong>r</strong> is then applied to this function to return the final <strong>b</strong>.</p>
<p>The intuition here is that we supply the input resource <strong>r</strong> to <strong>f</strong> and use that result as the first input to <strong>g</strong> followed by <strong>r</strong> as the second input.</p>
<p>Let’s use it in an example:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(<span class="fu">+</span><span class="dv">3</span>) <span class="fu">&gt;&gt;=</span> (<span class="fu">*</span>) <span class="fu">$</span> <span class="dv">5</span>
<span class="fu">=</span> (\r <span class="ot">-&gt;</span> r <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> \r <span class="ot">-&gt;</span> a <span class="fu">*</span> r) <span class="dv">5</span> <span class="co">-- expanding the Monad for &#39;r&#39;</span>
<span class="fu">=</span> (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> a <span class="fu">*</span> <span class="dv">5</span>)               <span class="co">-- replace &#39;r&#39; with 5</span>
<span class="fu">=</span> (<span class="dv">8</span>) <span class="fu">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> a <span class="fu">*</span> <span class="dv">5</span>)
<span class="fu">=</span> (<span class="dv">8</span> <span class="fu">*</span> <span class="dv">5</span>)                                 <span class="co">-- replace &#39;a&#39; with 8</span>
<span class="fu">=</span> <span class="dv">40</span></code></pre></div>
<p>or simply:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(<span class="fu">+</span><span class="dv">3</span>) <span class="fu">&gt;&gt;=</span> (<span class="fu">*</span>) <span class="fu">$</span> <span class="dv">5</span>
<span class="fu">=</span> ((<span class="dv">5</span><span class="fu">+</span><span class="dv">3</span>) <span class="fu">*</span> <span class="dv">5</span>)
<span class="fu">=</span> (<span class="dv">8</span> <span class="fu">*</span> <span class="dv">5</span>)
<span class="fu">=</span> <span class="dv">40</span></code></pre></div>
<p>We can also use the do syntax to solve the above:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">let</span> z1 <span class="fu">=</span> <span class="kw">do</span>
           x <span class="ot">&lt;-</span> (<span class="fu">+</span><span class="dv">3</span>)
           (x <span class="fu">*</span>)
z1 <span class="dv">5</span>
<span class="fu">=</span> <span class="dv">40</span></code></pre></div>
<h3 id="join">Join</h3>
<p>The <strong>join</strong> function flattens nested <strong>Monads</strong> and is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">join ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m (m a) <span class="ot">-&gt;</span> m a
join x <span class="fu">=</span> x <span class="fu">&gt;&gt;=</span> id</code></pre></div>
<p>Given the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">join (<span class="fu">+</span>) <span class="dv">10</span></code></pre></div>
<p>armed with the what we know about <strong>Monads</strong>, what is its result?</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">join (<span class="fu">+</span>) <span class="dv">10</span>
<span class="co">-- m (m a) -&gt; m a</span>
<span class="fu">=</span> (\r <span class="ot">-&gt;</span> (\r <span class="ot">-&gt;</span> r <span class="fu">+</span> r)) <span class="dv">10</span> <span class="co">-- expanding the Monad for &#39;r&#39;</span>
<span class="fu">=</span> (<span class="dv">10</span> <span class="fu">+</span> <span class="dv">10</span>)                <span class="co">-- replacing &#39;r&#39; with 10</span>
<span class="fu">=</span> <span class="dv">20</span></code></pre></div>
<p>We can also use the do syntax to solve the above:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">let</span> z2 <span class="fu">=</span> <span class="kw">do</span>
           x <span class="ot">&lt;-</span> (<span class="fu">+</span>)
           x
z2 <span class="dv">10</span>
<span class="fu">=</span> <span class="dv">20</span></code></pre></div>]]></description>
    <pubDate>Mon, 05 Mar 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-03-05-functor-applicative-and-monad-instances-for-reader.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>How to Run Specific Tests through Stack with Tasty in Haskell</title>
    <link>http://blog.ssanj.net/posts/2018-02-01-how-to-run-specific-tests-through-stack-with-tasy-in-haskell.html</link>
    <description><![CDATA[<p>Something I’ve become accustomed to while coding in Scala is being able to run a <a href="https://sanj.ink/posts/2015-08-02-run-a-test-method-of-a-test-class-from-sbt.html">subset of tests</a> through SBT. And while the same functionality is possible through <a href="https://hackage.haskell.org/package/tasty">Tasty</a>, I found it a little difficult to use through Stack.</p>
<p>Now stack allows you to send through parameters to your testing framework with the following options:</p>
<pre class="terminal scrollx"><code>--ta,--test-arguments TEST_ARGS Arguments passed in to the test suite program</code></pre>
<p>So given a full test suite of:</p>
<pre class="terminal scrollx"><code>  RM
    exits from home screen:       OK
    handles invalid query syntax: OK
    handle valid query:           OK
    handle invalid index:         OK
    handle invalid action:        OK
    go home from search:          OK
    quit from search:             OK
    search without results:       OK</code></pre>
<p>Using plain Tasty, you can use the -p argument to run tests that match a pattern:</p>
<pre class="terminal scrollx"><code>-p,--pattern ARG         Select only tests that match pattern</code></pre>
<p>Combining the two options, I can choose to run only the <em>quit from search</em> test with:</p>
<pre class="terminal scrollx"><code>stack test --ta &#39;-p &quot;quit from search&quot;&#39;</code></pre>
<p>which results in running only that specific test:</p>
<pre class="terminal scrollx"><code>  RM
    quit from search: OK

All 1 tests passed (0.00s)</code></pre>
<p>As long as the string you pass to Tasty is specific, you can target tests at different levels (TestGroup, TestCase etc).</p>
<p>For example to only target the <em>CommandParser</em> test group I could use:</p>
<pre class="terminal scrollx"><code>stack test --ta &#39;-p &quot;CommandParser&quot;&#39;</code></pre>
<p>which results in running all the tests with the the <em>CommandParser</em> test group:</p>
<pre class="terminal scrollx"><code>  CommandParser
    matchValue parser should match one of *?^:                  OK
    matchValue parser should not match other chars:             OK
      +++ OK, passed 100 tests.
    matchType parser should match format: &quot;&gt; [*?^]&quot;:            OK
    query parser should parse a valid query with matches:       OK
    query parser should parse a valid query with only commands: OK
    query parser should parse all valid queries:                OK
      +++ OK, passed 100 tests.

All 6 tests passed (0.00s)</code></pre>
<p>And to target a specific test case within a Test Group I could use the</p>
<blockquote>
<p>testGroupName/testName</p>
</blockquote>
<p>format.</p>
<p>For example to run the <em>matchValue parser should not match other chars</em> test within the <em>CommandParser</em> test group, I could use:</p>
<pre class="terminal scrollx"><code>stack test --ta &#39;-p &quot;CommandParser/matchValue parser should not match other chars&quot;&#39;</code></pre>
<p>which results in:</p>
<pre class="terminal scrollx"><code>  CommandParser
    matchValue parser should not match other chars: OK
      +++ OK, passed 100 tests.

All 1 tests passed (0.01s)</code></pre>
<p>While this great, the version of Tasty I’m using (<a href="https://hackage.haskell.org/package/tasty-0.11.0.3">0.11.3</a>) has support for additional patterns:</p>
<blockquote>
<p>An optional prefixed bang ! negates the pattern.</p>
</blockquote>
<blockquote>
<p>If the pattern ends with a slash, it is removed for the purpose of the following description, but it would only find a match with a test group. In other words, foo/ will match a group called foo and any tests underneath it, but will not match a regular test foo.</p>
</blockquote>
<blockquote>
<p>If the pattern does not contain a slash /, the framework checks for a match against any single component of the path. Otherwise, the pattern is treated as a glob, where:</p>
</blockquote>
<blockquote>
<p>The wildcard * matches anything within a single path component (i.e. foo but not foo/bar).</p>
</blockquote>
<blockquote>
<p>Two wildcards ** matches anything (i.e. foo and foo/bar).</p>
</blockquote>
<blockquote>
<p>Anything else matches exactly that text in the path (i.e. foo would only match a component of the test path called foo (or a substring of that form).</p>
</blockquote>
<blockquote>
<p>For example, group/*1 matches group/test1 but not group/subgroup/test1, whereas both examples would be matched by group/**1. A leading slash matches the beginning of the test path; for example, /test* matches test1 but not group/test1.</p>
</blockquote>
<p>Newer versions of Tasty such as <a href="https://hackage.haskell.org/package/tasty-1.0">1.0</a> onward support even more advanced syntax.</p>
<p>Now that’s pretty neat!</p>]]></description>
    <pubDate>Thu, 01 Feb 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-02-01-how-to-run-specific-tests-through-stack-with-tasy-in-haskell.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>

    </channel>
</rss>
