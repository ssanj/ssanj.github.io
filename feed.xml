<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>BabylonCandle</title>
        <link>https://blog.ssanj.net</link>
        <description><![CDATA[The blog of Sanjiv Sahayam]]></description>
        <atom:link href="https://blog.ssanj.net/feed.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 24 Jan 2024 00:00:00 UT</lastBuildDate>
        <item>
    <title>Working With Rust Result</title>
    <link>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result.html</link>
    <description><![CDATA[<p>Trying to learning how to use the Rust <a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result</a> type can be daunting. In this “Working with Rust Result” series of short posts, I hope to make that more approachable. This series is for beginners who are finding it difficult to understand what a <code>Result</code> is and how to use it.</p>
<p>The series is split into fourteen parts as listed below.</p>
<ol type="1">
<li><a href="2024-01-24-working-with-rust-result-part-1.html">What is a Result?</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-2.html">Extracting Values</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-3.html">Extracting Values That Can Panic</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-4.html">Making Things Nicer with Fallbacks</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-5.html">Transforming Values</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-6.html">Combining Results</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-7.html">Chaining with Map</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-8.html">Combining Results the Question Mark Operator</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-9.html">Combining Results Some More</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-10.html">Working with Errors</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-11.html">Conversion to Option</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-12.html">Value Tests</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-13.html">Asides</a></li>
<li><a href="2024-01-24-working-with-rust-result-part-14.html">Summary</a></li>
</ol>
<p>Now I know what you’re thinking:</p>
<blockquote>
<p>Fourteen posts? You’ve got to be kidding me!</p>
</blockquote>
<p>I know it’s a lot of posts. I’ve tried to make each as small as possible with a single focus. I’ve added examples and some diagrams to make it more palatable.</p>
<p>Also don’t feel the need to read the full series at one go. Read as much as you want or choose a topic you want to know more about or are currently struggling with and start there. Be sure to try some of the examples out and experiment with your own changes; That’s the best way to learn.</p>
<p>Jump in at <a href="2024-01-24-working-with-rust-result-part-1.html">What is a Result?</a></p>]]></description>
    <pubDate>Wed, 24 Jan 2024 00:00:00 UT</pubDate>
    <guid>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Working With Rust Result - Combining Results Some More - Part 9</title>
    <link>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-9.html</link>
    <description><![CDATA[<p>There are even more ways to combine <code>Results</code>s!</p>
<h2 id="and">and</h2>
<p><code>and</code> is similar to <code>and_then</code> except a default <code>Result</code> is returned on an <code>Ok</code> instance:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> and<span class="op">&lt;</span>U<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> res<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>U<span class="op">,</span> E<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>U<span class="op">,</span> E<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(_) <span class="op">=&gt;</span> res<span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="cn">Err</span>(e)<span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that the value inside the <code>Ok</code> instance is never used:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cn">Ok</span>(_) <span class="op">=&gt;</span> res<span class="op">,</span></span></code></pre></div>
<p>In summary:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Given a Result&lt;T, E&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Return typr: Result&lt;U, E&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="cn">Ok</span>(_<span class="op">:</span>T)  <span class="op">-&gt;</span> res<span class="op">:</span><span class="dt">Result</span><span class="op">&lt;</span>U<span class="op">,</span> E<span class="op">&gt;</span> <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>U<span class="op">,</span> E<span class="op">&gt;</span>  <span class="co">// `Ok` value type changes from `T` from `U`</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="cn">Err</span>(e<span class="op">:</span>E) <span class="op">-&gt;</span> <span class="cn">Err</span>(e)           <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>U<span class="op">,</span> E<span class="op">&gt;</span>  <span class="co">// Notice that the `Err` value type is fixed at: `E`</span></span></code></pre></div>
<p><img src="/images/2024-01-24-working-with-rust-result/and-2.png" width="600" /></p>
<p>This can be useful when you only want to know if something succeeded or failed instead of needing to work on its value.</p>
<p>Take creating a directory and subsequently creating a file in that directory only if the directory creation succeeded.</p>
<p>We can create a directory with the <code>create_dir</code> function from the <code>std::fs</code> module:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> create_dir<span class="op">&lt;</span>P<span class="op">:</span> <span class="bu">AsRef</span><span class="op">&lt;</span><span class="dt">Path</span><span class="op">&gt;&gt;</span>(path<span class="op">:</span> P) <span class="op">-&gt;</span> <span class="pp">io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span></span></code></pre></div>
<p>Notice how this function returns a <code>Result</code> with a <code>Unit</code> as the success value.</p>
<p>We can create a file with the <code>create</code> function on the <code>std::fs::File</code> struct:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> create<span class="op">&lt;</span>P<span class="op">:</span> <span class="bu">AsRef</span><span class="op">&lt;</span><span class="dt">Path</span><span class="op">&gt;&gt;</span>(path<span class="op">:</span> P) <span class="op">-&gt;</span> <span class="pp">io::</span><span class="dt">Result</span><span class="op">&lt;</span>File<span class="op">&gt;</span></span></code></pre></div>
<p>If we use <code>and_then</code> to complete the example use case:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> create_directory_and_then_file(dir_path<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Path</span><span class="op">,</span> file_name<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="pp">io::</span><span class="dt">Result</span><span class="op">&lt;</span>File<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  create_dir(dir_path)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>and_then(<span class="op">|</span>_<span class="op">|</span> <span class="op">{</span> <span class="co">// We ignore the value from create_dir</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>      <span class="pp">File::</span>create(dir_path<span class="op">.</span>join(file_name))</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>) <span class="co">// Result&lt;File&gt;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We have to ignore the previous success value in <code>and_then</code> (as we can’t do anything useful with <code>Unit</code>). This is a little verbose and we can trim it down with <code>and</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> create_directory_and_file(dir_path<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Path</span><span class="op">,</span> file_name<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="pp">io::</span><span class="dt">Result</span><span class="op">&lt;</span>File<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  create_dir(dir_path)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>and(<span class="pp">File::</span>create(dir_path<span class="op">.</span>join(file_name)))  <span class="co">// Result&lt;File&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="or">or</h2>
<p>If you wanted to try an alternative <code>Result</code> on <code>Err</code> and you didn’t care about the error value, you could use <code>or</code>. <code>or</code> is defined as:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a> <span class="kw">pub</span> <span class="kw">fn</span> or<span class="op">&lt;</span>F<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> res<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> F<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> F<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>     <span class="cn">Ok</span>(v) <span class="op">=&gt;</span> <span class="cn">Ok</span>(v)<span class="op">,</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>     <span class="cn">Err</span>(_) <span class="op">=&gt;</span> res<span class="op">,</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a> <span class="op">}</span></span></code></pre></div>
<p>In the definition above the value <code>res</code> is used only when there is an <code>Err</code> instance. If the <code>Result</code> is an <code>Ok</code> instance, its value
is returned.</p>
<p>In summary:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Given: Result&lt;T, E&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Return type: Result&lt;T, F&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="cn">Err</span>(_<span class="op">:</span>E) <span class="op">-&gt;</span> res<span class="op">:</span><span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> F<span class="op">&gt;</span>  <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> F<span class="op">&gt;</span> <span class="co">// The `Err` value type changes from `E` to `F`</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="cn">Ok</span>(t<span class="op">:</span>T)  <span class="op">-&gt;</span> <span class="cn">Ok</span>(t)             <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> F<span class="op">&gt;</span> <span class="co">// `Ok` value type is fixed: `T`</span></span></code></pre></div>
<p>It’s important to note that <code>res</code> dictates the final <code>Err</code> type returned from <code>or</code> and that the type inside the <code>Ok</code> constructor doesn’t change. We’ll see that come into play in the example below.</p>
<p><img src="/images/2024-01-24-working-with-rust-result/or-2.png" width="600" /></p>
<p>Here’s an example of where we can try one of several parse functions until we find one that succeeds.</p>
<p>Given a common error type <code>MyError</code> and a common success type <code>MyResult</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyError(<span class="dt">String</span>)<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> MyResult <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  N(<span class="dt">u32</span>)<span class="op">,</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  B(<span class="dt">bool</span>)<span class="op">,</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  S(<span class="dt">String</span>)<span class="op">,</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And functions to parse numbers and booleans:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> parse_number(value<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> ParseIntError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">u32</span><span class="pp">::</span>from_str(value)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> parse_bool(value<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> ParseBoolError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span><span class="pp">::</span>from_str(value)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>One thing to note is that both functions return different error types in <code>Err</code>: <code>ParseIntError</code> and <a href="https://doc.rust-lang.org/std/str/struct.ParseBoolError.html">ParseBoolError</a> respectively.</p>
<p>How would we combine these functions into parsing a string slice into a type of <code>MyResult</code>? And we also don’t support converting a string that is all caps into <code>MyResult</code>. That would be an error.</p>
<p><code>Note</code> that we don’t need to align the error types here as mentioned before because the <code>Result</code> passed to <code>or</code> would change the final <code>Err</code> type as required.</p>
<p>Here’s one way we could do it:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> parse_my_result(value<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>MyResult<span class="op">,</span> MyError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  parse_number(value) <span class="co">// Result&lt;u32, ParseIntError&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>map(<span class="op">|</span>n<span class="op">|</span> <span class="pp">MyResult::</span>N(n)) <span class="co">// Result&lt;MyResult, ParseIntError&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>or(</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      parse_bool(value) <span class="co">// Result&lt;u32, ParseBoolError&gt;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(<span class="op">|</span>b<span class="op">|</span> <span class="pp">MyResult::</span>B(b))</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    ) <span class="co">// Result&lt;MyResult, ParseBoolError&gt;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>or(</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> value<span class="op">.</span>to_uppercase() <span class="op">==</span> value <span class="op">{</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>          <span class="co">// We don&#39;t support full caps</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>          <span class="cn">Err</span>(MyError(<span class="pp">format!</span>(<span class="st">&quot;We don&#39;t support screaming case: {}&quot;</span><span class="op">,</span> value))) <span class="co">// Result&lt;MyResult, MyError&gt;</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>       <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(<span class="pp">MyResult::</span>S(value<span class="op">.</span>to_owned())) <span class="co">// Result&lt;MyResult, MyError&gt;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>       <span class="op">}</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    ) <span class="co">// Result&lt;MyResult, MyError&gt;</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We could use it like:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r1<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>MyResult<span class="op">,</span> MyError<span class="op">&gt;</span> <span class="op">=</span> parse_my_result(<span class="st">&quot;123&quot;</span>)<span class="op">;</span> <span class="co">// Ok(N(123))</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r2<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>MyResult<span class="op">,</span> MyError<span class="op">&gt;</span> <span class="op">=</span> parse_my_result(<span class="st">&quot;true&quot;</span>)<span class="op">;</span> <span class="co">// Ok(B(true))</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r3<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>MyResult<span class="op">,</span> MyError<span class="op">&gt;</span> <span class="op">=</span> parse_my_result(<span class="st">&quot;something&quot;</span>)<span class="op">;</span> <span class="co">//Ok(S(&quot;something&quot;))</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r4<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>MyResult<span class="op">,</span> MyError<span class="op">&gt;</span> <span class="op">=</span> parse_my_result(<span class="st">&quot;HELLO&quot;</span>)<span class="op">;</span> <span class="co">//Err(MyError(&quot;We don&#39;t support screaming case: HELLO&quot;))</span></span></code></pre></div>
<p>How the <code>Err</code> type changed between <code>ParseIntError</code>, <code>ParseBoolError</code> to <code>MyError</code> can be a bit harder to see. Here’s a more detailed example of the above:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> parse_my_result_2(value<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>MyResult<span class="op">,</span> MyError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> p1<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>MyResult<span class="op">,</span> ParseIntError<span class="op">&gt;</span> <span class="op">=</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    parse_number(value)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>map(<span class="op">|</span>n<span class="op">|</span> <span class="pp">MyResult::</span>N(n))<span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> p2<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>MyResult<span class="op">,</span> ParseBoolError<span class="op">&gt;</span> <span class="op">=</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    parse_bool(value)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>map(<span class="op">|</span>b<span class="op">|</span> <span class="pp">MyResult::</span>B(b))<span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> p3<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>MyResult<span class="op">,</span> MyError<span class="op">&gt;</span> <span class="op">=</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> value<span class="op">.</span>to_uppercase() <span class="op">==</span> value <span class="op">{</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We don&#39;t support full caps</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(MyError(<span class="pp">format!</span>(<span class="st">&quot;We don&#39;t support screaming case: {}&quot;</span><span class="op">,</span> value)))</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>      <span class="cn">Ok</span>(<span class="pp">MyResult::</span>S(value<span class="op">.</span>to_owned()))</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>     <span class="op">};</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r1<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>MyResult<span class="op">,</span> ParseBoolError<span class="op">&gt;</span> <span class="op">=</span> p1<span class="op">.</span>or(p2)<span class="op">;</span> <span class="co">// p2&#39;s type wins</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r2<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>MyResult<span class="op">,</span> MyError<span class="op">&gt;</span> <span class="op">=</span> r1<span class="op">.</span>or(p3)<span class="op">;</span> <span class="co">// p3&#39;s type wins</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    r2</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The function <code>res</code>, passed to <code>or</code> dictates the final <code>Err</code> type. Also when chaining multiple <code>or</code> calls, the final <code>res</code> block dictates the final <code>Result</code> type. In the case of <code>or</code> chaining, the <code>Ok</code> type is fixed but the <code>Err</code> type can vary!</p>
<h2 id="or_else">or_else</h2>
<p><code>or_else</code> is similar to <code>or</code> with the exception that you get access to the error type <code>E</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> <span class="kw">fn</span> or_else<span class="op">&lt;</span>F<span class="op">,</span> O<span class="op">:</span> <span class="bu">FnOnce</span>(E) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> F<span class="op">&gt;&gt;</span>(<span class="kw">self</span><span class="op">,</span> op<span class="op">:</span> O) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> F<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>      <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>          <span class="cn">Ok</span>(t) <span class="op">=&gt;</span> <span class="cn">Ok</span>(t)<span class="op">,</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>          <span class="cn">Err</span>(e) <span class="op">=&gt;</span> op(e)<span class="op">,</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>The function <code>op</code> takes in the <code>Err</code> type <code>E</code> and returns a <code>Result</code> with the same success type <code>T</code> and a new error type <code>F</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="bu">FnOnce</span>(E) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> F<span class="op">&gt;</span></span></code></pre></div>
<p>In summary:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Given: Result&lt;T, E&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Return type: Result&lt;T, F&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="cn">Err</span>(e<span class="op">:</span>E) <span class="op">-&gt;</span> op(e)  <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> F<span class="op">&gt;</span> <span class="co">// `Err` value type goes from `E` -&gt; `F`</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="cn">Ok</span>(t<span class="op">:</span>T)  <span class="op">-&gt;</span> <span class="cn">Ok</span>(t)  <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> F<span class="op">&gt;</span> <span class="co">// `Ok` value type is fixed: `T`</span></span></code></pre></div>
<p>This can be useful when you need access to the error to make a decision about the result to return or when you need to log the error.</p>
<p>For example, if you want to log the error before returning a fallback:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> parse_number_somehow(value<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> MyError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  parse_number(value)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>or_else(<span class="op">|</span>e<span class="op">|</span> <span class="op">{</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>      <span class="pp">eprintln!</span>(<span class="st">&quot;Could not convert &#39;{}&#39; to a number: {}, defaulting to length&quot;</span><span class="op">,</span> value<span class="op">,</span> e)<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>      parse_by_length(value)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> parse_by_length(value<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> MyError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> length <span class="op">=</span> value<span class="op">.</span>len()<span class="op">;</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> length <span class="op">&lt;=</span> <span class="dt">u32</span><span class="pp">::</span><span class="cn">MAX</span> <span class="kw">as</span> <span class="dt">usize</span> <span class="op">{</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(length <span class="kw">as</span> <span class="dt">u32</span>)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Err</span>(MyError(<span class="st">&quot;Your string is too long for u32&quot;</span><span class="op">.</span>to_owned()))</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>parse_number_somehow(<span class="st">&quot;number&quot;</span>)</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="co">//Could not convert &#39;number&#39; to a number: invalid digit found in string, defaulting to length</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="co">// Ok(6)</span></span></code></pre></div>
<ul>
<li>Continue on to <a href="2024-01-24-working-with-rust-result-part-10.html">Working with Errors</a></li>
<li>Back to <a href="2024-01-24-working-with-rust-result.html">TOC</a></li>
</ul>]]></description>
    <pubDate>Wed, 24 Jan 2024 00:00:00 UT</pubDate>
    <guid>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-9.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Working With Rust Result - Combining Results with the Question Mark Operator - Part 8</title>
    <link>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-8.html</link>
    <description><![CDATA[<p>Lets try to perform a calculation on multiple numbers parsed from strings:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers_1<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> ParseIntError<span class="op">&gt;</span> <span class="op">=</span> add_numbers(<span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="st">&quot;20&quot;</span><span class="op">,</span> <span class="st">&quot;30&quot;</span>)<span class="op">;</span> <span class="co">// Ok(60)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers_2 <span class="op">=</span> add_numbers(<span class="st">&quot;ten&quot;</span><span class="op">,</span> <span class="st">&quot;20&quot;</span><span class="op">,</span> <span class="st">&quot;30&quot;</span>)<span class="op">;</span>    <span class="co">// Err(ParseIntError { kind: InvalidDigit })</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers_3 <span class="op">=</span> add_numbers(<span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="st">&quot;twenty&quot;</span><span class="op">,</span> <span class="st">&quot;30&quot;</span>)<span class="op">;</span> <span class="co">// Err(ParseIntError { kind: InvalidDigit })</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers_4 <span class="op">=</span> add_numbers(<span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="st">&quot;20&quot;</span><span class="op">,</span> <span class="st">&quot;thirty&quot;</span>)<span class="op">;</span> <span class="co">// Err(ParseIntError { kind: InvalidDigit })</span></span></code></pre></div>
<p>Here’s the definition of <code>add_numbers</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> add_numbers(one<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> two<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> three<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> ParseIntError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  parse_number(one) <span class="co">// try and get the first number. Returns Result&lt;u32, ParseIntError&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>and_then(<span class="op">|</span>n1<span class="op">|</span> <span class="op">{</span> <span class="co">// if that succeeds,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>      parse_number(two) <span class="co">// try and get the second number. Returns Result&lt;u32, ParseIntError&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>and_then(<span class="op">|</span>n2<span class="op">|</span> <span class="op">{</span> <span class="co">// if that succeeds</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>          parse_number(three) <span class="co">// try and get the third number. Returns Result&lt;u32, ParseIntError&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>map(<span class="op">|</span>n3<span class="op">|</span> n1 <span class="op">+</span> n2 <span class="op">+</span> n3) <span class="co">// if that succeeds, add up all the previous numbers. Returns Result&lt;u32, ParseIntError&gt;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is similar to how we previously parsed two numbers. This is quickly becoming hard to reason about. Parsing more numbers like this would be almost unmaintainable. Luckily Rust gives us a simpler way to do this.</p>
<h2 id="the-question-mark-operator">The question mark operator</h2>
<p>Rust has the <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator">question mark operator</a> (<code>?</code>) which allows you to simply
return an error or extract a success value. You can think of it as an <code>unwrap</code> on <code>Ok</code> with an immediate return on <code>Err</code>, instead of panic-ing.</p>
<p><img src="/images/2024-01-24-working-with-rust-result/question-mark-operator-3.png" width="600" /></p>
<p>Here’s the definition of <code>and_numbers_2</code> which uses the <code>?</code> operator:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> add_numbers_2(one<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> two<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> three<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> ParseIntError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> n1<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> parse_number(one)<span class="op">?;</span>   <span class="co">// Get the number or return an Err</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> n2<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> parse_number(two)<span class="op">?;</span>   <span class="co">// Get the number or return an Err</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> n3<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> parse_number(three)<span class="op">?;</span> <span class="co">// Get the number or return an Err</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If we got here, all the numbers are valid</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="cn">Ok</span>(n1 <span class="op">+</span> n2 <span class="op">+</span> n3) <span class="co">// Add all the numbers and return an Ok</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It’s important to note that if any of the <code>parse_number</code> function calls return an <code>Err</code>, the <code>add_numbers_2</code> function would return that <code>Err</code> as the final result instead of proceeding to the next line.</p>
<blockquote>
<p>We have to still wrap the final result in an <code>Ok</code> constructor as <code>add_numbers_2</code> returns a <code>Result&lt;u32, ParseIntError&gt;</code>.</p>
</blockquote>
<p>We can see that the <code>add_numbers_2</code> function is easier to reason about than chaining together <code>and_then</code> and <code>map</code> calls as in the <code>add_numbers</code> function. The <code>?</code> operator is supported for <code>Result</code> and <code>Option</code> types at the moment.</p>
<h3 id="keep-aligning-those-error-values">Keep aligning those error values</h3>
<p>Something else to keep in mind is that we still need to align on the <code>Err</code> value as we did when using <code>and_then</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> add_numbers_3(one<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> two<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> three<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> ParseIntError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> n1<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> parse_number(one)<span class="op">?;</span>                                      <span class="co">// Result&lt;u32, ParseIntError&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> n2<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> parse_number(two)<span class="op">.</span>map_err(<span class="op">|</span>e<span class="op">|</span> MyError(e<span class="op">.</span>to_string()))<span class="op">?;</span>  <span class="co">// Result&lt;u32, MyError&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> n3<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> parse_number(three)<span class="op">?;</span>                                    <span class="co">// Result&lt;u32, ParseIntError&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If we got here, all the numbers are valid</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="cn">Ok</span>(n1 <span class="op">+</span> n2 <span class="op">+</span> n3) <span class="co">// Add all the numbers and return an Ok</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The above leads to an error:</p>
<pre class="terminal scrollx"><code>error[E0277]: `?` couldn&#39;t convert the error to `ParseIntError`
   --&gt; src/main.rs:414:74
    |
412 | ...numbers_3(one: &amp;str, two: &amp;str, three: &amp;str) -&gt; Result&lt;u32, ParseIntError&gt; {
    |                                                    -------------------------- expected `ParseIntError` because of this
413 | ...1: u32 = parse_number(one)?; // Get the number or return an Err
414 | ...2: u32 = parse_number(two).map_err(|_| MyError(&quot;Blah&quot;.to_owned()))?; // Get the number...
    |             ----------------- ---------------------------------------^ the trait `From&lt;MyError&gt;` is not implemented for `ParseIntError`, which is required by `Result&lt;u32, ParseIntError&gt;: FromResidual&lt;Result&lt;Infallible, MyError&gt;&gt;`
    |             |                 |
    |             |                 this can&#39;t be annotated with `?` because it has type `Result&lt;_, MyError&gt;`
    |             this has type `Result&lt;_, ParseIntError&gt;`
    |
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the following other types implement trait `FromResidual&lt;R&gt;`:
              &lt;Result&lt;T, F&gt; as FromResidual&lt;Yeet&lt;E&gt;&gt;&gt;
              &lt;Result&lt;T, F&gt; as FromResidual&lt;Result&lt;Infallible, E&gt;&gt;&gt;
    = note: required for `Result&lt;u32, ParseIntError&gt;` to implement `FromResidual&lt;Result&lt;Infallible, MyError&gt;&gt;`</code></pre>
<p>The important bits are:</p>
<blockquote>
<p>error[E0277]: <code>?</code> couldn’t convert the error to <code>ParseIntError</code></p>
</blockquote>
<blockquote>
<p>Result&lt;u32, ParseIntError&gt;
————————– expected <code>ParseIntError</code> because of this</p>
</blockquote>
<blockquote>
<p>the trait <code>From&lt;MyError&gt;</code> is not implemented for <code>ParseIntError</code>, which is required by <code>Result&lt;u32, ParseIntError&gt;: FromResidual&lt;Result&lt;Infallible, MyError&gt;&gt;</code></p>
</blockquote>
<blockquote>
<p>the question mark operation (<code>?</code>) implicitly performs a conversion on the error value using the <code>From</code> trait</p>
</blockquote>
<p>The error states that we need an <code>Err</code> value of type <code>ParseIntError</code> and we have an <code>Err</code> value of type <code>MyError</code>. If we have a <code>From</code> instance to convert from <code>MyError</code> to <code>ParseIntError</code> it would be called and the conversion automatically performed for us.</p>
<p>We can’t directly create a <code>ParseIntError</code> as the constructor is private. We can however create one from parsing a String that doesn’t represent a number. Using that information we can create a terrible <code>From</code> implementation to convert from <code>MyError</code> to <code>ParseIntError</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="bu">From</span><span class="op">&lt;</span>MyError<span class="op">&gt;</span> <span class="cf">for</span> ParseIntError <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> from(source<span class="op">:</span> MyError) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>      parse_number(<span class="op">&amp;</span>source<span class="op">.</span><span class="dv">0</span>)<span class="op">.</span>unwrap_err() <span class="co">// Forcing values again</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>With the above conversion in place <code>add_numbers_3</code> compiles with out any errors, indicating that <code>MyError</code> was implicitly converted to <code>ParseIntError</code> and aligning our <code>Err</code> values almost for “free”. The question mark operator makes working with <code>Result</code> so much easier.</p>
<ul>
<li>Continue on to <a href="2024-01-24-working-with-rust-result-part-9.html">Combining Results Some More</a></li>
<li>Back to <a href="2024-01-24-working-with-rust-result.html">TOC</a></li>
</ul>]]></description>
    <pubDate>Wed, 24 Jan 2024 00:00:00 UT</pubDate>
    <guid>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-8.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Working With Rust Result - Chaining with Map - Part 7</title>
    <link>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-7.html</link>
    <description><![CDATA[<p>What if we only wanted to parse two numbers and add them together and not return any errors? We can already solve this with <code>and_then</code> as before:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>parse_number(<span class="st">&quot;10&quot;</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>and_then(<span class="op">|</span>ten<span class="op">|</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="co">// We have successfully parsed &quot;10&quot; into 10.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      parse_number(<span class="st">&quot;20&quot;</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>and_then(<span class="op">|</span>twenty<span class="op">|</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">// We have successfully parsed &quot;20&quot; into 20.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>(ten <span class="op">+</span> twenty)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>)</span></code></pre></div>
<p><img src="/images/2024-01-24-working-with-rust-result/and-then-chaining.png" width="600" /></p>
<p>We could also just <code>map</code> over the last function that returns a <code>Result</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>parse_number(<span class="st">&quot;10&quot;</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>and_then(<span class="op">|</span>ten<span class="op">|</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="co">// We have successfully parsed &quot;10&quot; into 10.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>      parse_number(<span class="st">&quot;20&quot;</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(<span class="op">|</span>twenty<span class="op">|</span> <span class="op">{</span> <span class="co">// We map here</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">// We have successfully parsed &quot;20&quot; into 20.</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            ten <span class="op">+</span> twenty <span class="co">// We didn&#39;t have to wrap the answer in a Result, because we are &#39;in&#39; a Result</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>)</span></code></pre></div>
<p>Reminder about <code>map</code>s definition:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> map<span class="op">&lt;</span>U<span class="op">,</span> F<span class="op">:</span> <span class="bu">FnOnce</span>(T) <span class="op">-&gt;</span> U<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> op<span class="op">:</span> F) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>U<span class="op">,</span> E<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(t) <span class="op">=&gt;</span> <span class="cn">Ok</span>(op(t))<span class="op">,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="cn">Err</span>(e)<span class="op">,</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p><code>map</code> wraps the result of <code>op</code> in an <code>Ok</code> constructor for us so we don’t have to!</p>
</blockquote>
<p>In summary:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode for map</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Given: Result&lt;T, E&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Return type: Result&lt;U, E&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>op<span class="op">:</span> T <span class="op">-&gt;</span> U <span class="co">// Convert success value to a U</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="cn">Ok</span>(t<span class="op">:</span>T)   <span class="op">-&gt;</span>  op(t) <span class="op">-&gt;</span> U <span class="op">-&gt;</span> <span class="cn">Ok</span>(U)  <span class="co">// Return converted value in Ok, as a Result&lt;U, E&gt;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="cn">Err</span>(e<span class="op">:</span>E)                 <span class="op">-&gt;</span> <span class="cn">Err</span>(e) <span class="co">// Return existing error as Result&lt;U, E&gt;</span></span></code></pre></div>
<p><img src="/images/2024-01-24-working-with-rust-result/and-then-with-map-2.png" width="600" /></p>
<p>How do we decide when to use <code>and_then</code> at the last step of a <code>Result</code> chain or whether to use <code>map</code>?</p>
<blockquote>
<p>If you need to make a decision about whether to fail or not, then use <code>and_then</code> because you
can return an <code>Ok</code> to succeed or an <code>Err</code> to fail. If you simply want to work on the <code>Ok</code> side of a previous <code>Result</code>, then use <code>map</code>.</p>
</blockquote>
<blockquote>
<p>This logic works only at the last step of a <code>Result</code> chain. If you use <code>map</code> where you should have used <code>and_then</code>, you will end up with a nested <code>Result</code> of the sort: <code>Result&lt;Result&lt;T, E&gt;,E&gt;</code> indicating that you should have <code>and_then</code>ed where you had previously <code>map</code>ped.</p>
</blockquote>
<p>So many rules to keep in mind! If only there were an easier way to combine <code>Result</code>s.</p>
<ul>
<li>Continue on to <a href="2024-01-24-working-with-rust-result-part-8.html">Combining Results the Question Mark Operator</a></li>
<li>Back to <a href="2024-01-24-working-with-rust-result.html">TOC</a></li>
</ul>]]></description>
    <pubDate>Wed, 24 Jan 2024 00:00:00 UT</pubDate>
    <guid>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-7.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Working With Rust Result - Combining Results - Part 6</title>
    <link>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-6.html</link>
    <description><![CDATA[<p><code>Result</code> gets interesting when you need to combine multiples to give you one final <code>Result</code>.</p>
<h2 id="and_then">and_then</h2>
<p>Sometimes when you have multiple functions that return <code>Result</code>s, you want to know if all of them succeeded or any of them failed. <code>and_then</code> can help you there. <code>and_then</code> is defined as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> and_then<span class="op">&lt;</span>U<span class="op">,</span> F<span class="op">:</span> <span class="bu">FnOnce</span>(T) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>U<span class="op">,</span> E<span class="op">&gt;&gt;</span>(<span class="kw">self</span><span class="op">,</span> op<span class="op">:</span> F) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>U<span class="op">,</span> E<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(t) <span class="op">=&gt;</span> op(t)<span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="cn">Err</span>(e)<span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>From the above definition, the function <code>op</code> is run on the success value within an <code>Ok</code> instance. This is very similar to <code>map</code>, with the main difference being that the function <code>op</code> returns another <code>Result</code> instead of another type. It’s important to note that since <code>op</code> returns a <code>Result</code> we can choose whether to return an <code>Ok</code> or <code>Err</code> instance at this point. <code>and_then</code> gives us the power to make a decision.</p>
<blockquote>
<p>Unlike <code>map</code> there is no wrapping of the result in an <code>Ok</code> constructor as <code>op</code> already returns a <code>Result</code>.</p>
</blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Given: Result&lt;T, E&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Return type: Result&lt;U, E&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>op<span class="op">:</span> T <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>U<span class="op">,</span> E<span class="op">&gt;</span> <span class="co">// Converts a success value into another Result (Ok or Err)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="cn">Ok</span>(t<span class="op">:</span>T)   <span class="op">-&gt;</span>  op(t)  <span class="op">-&gt;</span> <span class="cn">Ok</span>(U) or <span class="cn">Err</span>(E) <span class="co">// Return converted value in Ok or Err as a Result&lt;U, E&gt;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="cn">Err</span>(e<span class="op">:</span>E)             <span class="op">-&gt;</span> <span class="cn">Err</span>(e)          <span class="co">// Return existing error as Result&lt;U, E&gt;</span></span></code></pre></div>
<p><img src="/images/2024-01-24-working-with-rust-result/and-then.png" width="600" /></p>
<p>Given the following function that parses a string to a <code>u32</code> or returns a <a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html">ParseIntError</a>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::num::</span>ParseIntError<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span><span class="dt">str</span><span class="pp">::</span><span class="bu">FromStr</span><span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> parse_number(value<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> ParseIntError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">u32</span><span class="pp">::</span>from_str(value)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Let’s try and parse a string number with <code>parse_number</code> and multiply its value by 2:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>parse_number(<span class="st">&quot;10&quot;</span>) <span class="co">// Result&lt;u32, ParseIntError&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>and_then(<span class="op">|</span>value<span class="op">|</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We have successfully parsed &quot;10&quot; into 10.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> new_result <span class="op">=</span> ten <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Multiply by 2</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">todo!</span>() <span class="co">// What do we return here?</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span></code></pre></div>
<p>Given that we have to use a function that also returns a <code>Result</code> from <code>and_then</code> we can wrap <code>new_result</code> in the <code>Ok</code> constructor:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>parse_number(<span class="st">&quot;10&quot;</span>) <span class="co">// Result&lt;u32, ParseIntError&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>and_then(<span class="op">|</span>ten<span class="op">|</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We have successfully parsed &quot;10&quot; into 10.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> new_result <span class="op">=</span> ten <span class="op">*</span> <span class="dv">2</span> <span class="co">// Multiply by 2</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(new_result) <span class="co">// Result&lt;u32, ParseIntError&gt;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span></code></pre></div>
<h3 id="aligning-errors-types">Aligning errors types</h3>
<p>If we want to fail our calculation for some reason we can return an <code>Err</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyError(<span class="dt">String</span>)<span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>parse_number(<span class="st">&quot;10&quot;</span>) <span class="co">// Result&lt;u32, ParseIntError&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="op">.</span>and_then(<span class="op">|</span>one<span class="op">|</span> <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We have successfully parsed &quot;10&quot; into 10.</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    parse_number(<span class="st">&quot;20&quot;</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>and_then(<span class="op">|</span>two<span class="op">|</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>          <span class="co">// We have successfully parsed &quot;20&quot; into 20.</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>          <span class="co">// but we don&#39;t like even numbers...</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> two <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>              <span class="cn">Err</span>(MyError(<span class="st">&quot;I don&#39;t add even numbers&quot;</span><span class="op">.</span>to_owned())) <span class="co">// Result&lt;u32, MyError&gt;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>              <span class="cn">Ok</span>(one <span class="op">+</span> two) <span class="co">// Result&lt;u32, ParseIntError&gt;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span>)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)</span></code></pre></div>
<p>But we can an error!:</p>
<pre class="terminal scrollx"><code>error[E0308]: mismatched types
   --&gt; src/main.rs:86:23
    |
86  |                   Err(MyError(&quot;I don&#39;t add even numbers&quot;.to_owned()))
    |                   --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ParseIntError`, found `MyError`
    |                   |
    |                   arguments to this enum variant are incorrect
    |
help: the type constructed contains `MyError` due to the type of the argument passed
   --&gt; src/main.rs:86:19
    |
86  |                   Err(MyError(&quot;I don&#39;t add even numbers&quot;.to_owned()))
    |                   ^^^^----------------------------------------------^
    |                       |
    |                       this argument influences the type of `Err`</code></pre>
<p>Which points to the real cause:</p>
<blockquote>
<p>expected <code>ParseIntError</code>, found <code>MyError</code></p>
</blockquote>
<p>What this means is that when you are chaining <code>Result</code>s through <code>and_then</code> functions, all the <code>Err</code> types need to be the same. We can change the <code>Ok</code> type as
much as we want but we have to <code>align</code> the <code>Err</code> types. This is just something to keep in mind when using <code>Result</code>. If you have functions that return <code>Result</code>s with different
<code>Err</code> types, you can create a common error type and convert each error into that type using something like <code>map_err</code>, which we will cover later.</p>
<p>For completeness, here’s how you align your error types with <code>map_error</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>parse_number(<span class="st">&quot;10&quot;</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>map_err(<span class="op">|</span>e<span class="op">|</span> MyError(e<span class="op">.</span>to_string())) <span class="co">// Result&lt;u32, MyError&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>and_then(<span class="op">|</span>one<span class="op">|</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We have successfully parsed &quot;10&quot; into 10.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    parse_number(<span class="st">&quot;20&quot;</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>map_err(<span class="op">|</span>e<span class="op">|</span> MyError(e<span class="op">.</span>to_string())) <span class="co">// Result&lt;u32, MyError&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>and_then(<span class="op">|</span>two<span class="op">|</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>          <span class="co">// We have successfully parsed &quot;20&quot; into 20.</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>          <span class="co">// but we don&#39;t like even numbers...</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> two <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>              <span class="cn">Err</span>(MyError(<span class="st">&quot;I don&#39;t add even numbers&quot;</span><span class="op">.</span>to_owned())) <span class="co">// Result&lt;u32, MyError&gt;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>              <span class="cn">Ok</span>(one <span class="op">+</span> two)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)</span></code></pre></div>
<p><img src="/images/2024-01-24-working-with-rust-result/aligning-errors.png" width="600" /></p>
<ul>
<li>Continue on to <a href="2024-01-24-working-with-rust-result-part-7.html">Chaining with Map</a></li>
<li>Back to <a href="2024-01-24-working-with-rust-result.html">TOC</a></li>
</ul>]]></description>
    <pubDate>Wed, 24 Jan 2024 00:00:00 UT</pubDate>
    <guid>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-6.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Working With Rust Result - Tranforming Values - Part 5</title>
    <link>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-5.html</link>
    <description><![CDATA[<p>When using functions like <code>map_or_else</code>, we extracted the success and error values out of a <code>Result</code>, thereby losing our <code>Result</code> wrapper. What if you could run a function on the value within a <code>Result</code> and stay within the <code>Result</code> wrappers? Then you wouldn’t have to do all this pesky unwrapping until you needed the value.</p>
<h3 id="map">map</h3>
<p>The <code>map</code> function lets you transform a value within a <code>Result</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> map<span class="op">&lt;</span>U<span class="op">,</span> F<span class="op">:</span> <span class="bu">FnOnce</span>(T) <span class="op">-&gt;</span> U<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> op<span class="op">:</span> F) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>U<span class="op">,</span> E<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(t) <span class="op">=&gt;</span> <span class="cn">Ok</span>(op(t))<span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="cn">Err</span>(e)<span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In the above definition, the supplied function <code>op</code> is only run on the value within the <code>Ok</code> instance and the error value within the <code>Err</code> instance is left untouched.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Given: Result&lt;T, E&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Return type: Result&lt;U, E&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>op<span class="op">:</span> T <span class="op">-&gt;</span> U <span class="co">// Convert success value to a U</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="cn">Ok</span>(t<span class="op">:</span>T)   <span class="op">-&gt;</span>  op(t) <span class="op">-&gt;</span> U <span class="op">-&gt;</span> <span class="cn">Ok</span>(U)  <span class="co">// Return converted value in Ok, as a Result&lt;U, E&gt;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="cn">Err</span>(e<span class="op">:</span>E)                 <span class="op">-&gt;</span> <span class="cn">Err</span>(e) <span class="co">// Return existing error as Result&lt;U, E&gt;</span></span></code></pre></div>
<p><img src="/images/2024-01-24-working-with-rust-result/map.png" width="600" /></p>
<blockquote>
<p>After function <code>op</code> is used, the result is rewrapped in an <code>Ok</code> constructor. In the <code>Err</code> case we also rewrap the error again. This might seem pointless, but this has to be done because the result type is changing from a <code>Result&lt;T, E&gt;</code> to a <code>Result&lt;U, E&gt;</code> and the <code>Err(e)</code> in the pattern match is of type <code>Result&lt;T, E&gt;</code>. By creating a new <code>Err</code> instance we convert the error to type <code>Result&lt;U, E&gt;</code>.</p>
</blockquote>
<p>In either case the <code>Result</code>is converted from a <code>Result&lt;T, E&gt;</code> to a <code>Result&lt;U, E&gt;</code>. It’s important to note that we stay within a <code>Result</code> after running the function <code>op</code>. Here’s a simple example demonstrating this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> result_ok_1<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">=</span> <span class="cn">Ok</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> result_ok_2<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">=</span> result_ok_1<span class="op">.</span>map(<span class="op">|</span>n<span class="op">|</span> n <span class="op">*</span> <span class="dv">2</span>)<span class="op">;</span> <span class="co">// Ok(2), multiplied by 2</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> result_ok_3<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">=</span> result_ok_2<span class="op">.</span>map(<span class="op">|</span>n<span class="op">|</span> <span class="pp">format!</span>(<span class="st">&quot;age: {}&quot;</span><span class="op">,</span> n))<span class="op">;</span> <span class="co">// Ok(&quot;age: 2&quot;), converted to a String</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> result_err_1<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">=</span> <span class="cn">Err</span>(<span class="st">&quot;You have errors&quot;</span><span class="op">.</span>to_owned())<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> result_err_2<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">=</span> result_err_1<span class="op">.</span>map(<span class="op">|</span>n<span class="op">|</span> n <span class="op">*</span> <span class="dv">2</span>)<span class="op">;</span> <span class="co">// Err(&quot;You have errors&quot;), no change</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> result_err_3<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">=</span> result_err_2<span class="op">.</span>map(<span class="op">|</span>n<span class="op">|</span> <span class="pp">format!</span>(<span class="st">&quot;age: {}&quot;</span><span class="op">,</span> n))<span class="op">;</span> <span class="co">// Err(&quot;You have errors&quot;), no change</span></span></code></pre></div>
<p>You can also think of the <code>map</code> function as of type: <code>Result&lt;T -&gt; U, E&gt;</code>; as in it runs a function on the success side of <code>Result</code> leaving the error side untouched.</p>
<ul>
<li>Continue on to <a href="2024-01-24-working-with-rust-result-part-6.html">Combining Results</a></li>
<li>Back to <a href="2024-01-24-working-with-rust-result.html">TOC</a></li>
</ul>]]></description>
    <pubDate>Wed, 24 Jan 2024 00:00:00 UT</pubDate>
    <guid>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-5.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Working With Rust Result - Making Things Nicer with Fallbacks - Part 4</title>
    <link>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-4.html</link>
    <description><![CDATA[<p>We can <code>unwrap</code> a <code>Result</code> in a nicer way, if we provide a default value of type <code>T</code> or call a function that returns a value of type <code>T</code> when given a type <code>E</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Given: Result&lt;T, E&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="cn">Ok</span>(T)  <span class="op">-&gt;</span> T</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="cn">Err</span>(_) <span class="op">-&gt;</span> T <span class="co">// Return value of `T`</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="cn">Err</span>(E) <span class="op">-&gt;</span> T <span class="co">// Use a function of type `E` -&gt; `T`</span></span></code></pre></div>
<h3 id="unwrap_or">unwrap_or</h3>
<p><code>unwrap_or</code> is defined as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> unwrap_or(<span class="kw">self</span><span class="op">,</span> <span class="kw">default</span><span class="op">:</span> T) <span class="op">-&gt;</span> T <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(t) <span class="op">=&gt;</span> t<span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(_) <span class="op">=&gt;</span> <span class="kw">default</span><span class="op">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In summary:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Given: Result&lt;T, E&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Return type: T</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">default</span><span class="op">:</span> <span class="op">-&gt;</span> T</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="cn">Ok</span>(t)   <span class="op">-&gt;</span>  t       <span class="op">-&gt;</span> T <span class="co">// Return value in Ok</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="cn">Err</span>(e)  <span class="op">-&gt;</span>  <span class="kw">default</span> <span class="op">-&gt;</span> T <span class="co">// Return default if in error</span></span></code></pre></div>
<p>In the above definition we supply a <code>default</code> value of type <code>T</code>. This default value will be used when there is an <code>Err</code>, the <code>Ok</code> value will be returned otherwise. This is very similar to <code>map_or</code> but where we don’t run a function on the success value.</p>
<p><img src="/images/2024-01-24-working-with-rust-result/unwrap-or.png" width="600" /></p>
<p>Here’s an example of using <code>unwrap_or</code> to do just that:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> twenty_five_or_ten_1<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> twenty_five(<span class="dv">20</span>)<span class="op">.</span>unwrap_or(<span class="dv">10</span>)<span class="op">;</span> <span class="co">// 10</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> twenty_five_or_ten_2<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> twenty_five(<span class="dv">25</span>)<span class="op">.</span>unwrap_or(<span class="dv">10</span>)<span class="op">;</span> <span class="co">// 25</span></span></code></pre></div>
<h3 id="unwrap_or_else">unwrap_or_else</h3>
<p>There’s a similarly named function called <code>unwrap_or_else</code>. The main difference being that <code>unwrap_or_else</code> takes in a function <code>op</code> that is called when an <code>Err</code> is returned:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> unwrap_or_else<span class="op">&lt;</span>F<span class="op">:</span> <span class="bu">FnOnce</span>(E) <span class="op">-&gt;</span> T<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> op<span class="op">:</span> F) <span class="op">-&gt;</span> T <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(t) <span class="op">=&gt;</span> t<span class="op">,</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(e) <span class="op">=&gt;</span> op(e)<span class="op">,</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In summary:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Given: Result&lt;T, E&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Return type: T</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>op<span class="op">:</span> E <span class="op">-&gt;</span> T</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="cn">Ok</span>(t)   <span class="op">-&gt;</span>  t     <span class="op">-&gt;</span> T <span class="co">// Return value in Ok</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="cn">Err</span>(e)  <span class="op">-&gt;</span>  op(e) <span class="op">-&gt;</span> T <span class="co">// Convert the value in Err to a `T`</span></span></code></pre></div>
<p><img src="/images/2024-01-24-working-with-rust-result/unwrap-or-else-2.png" width="600" /></p>
<p>This is very similar to the <code>map_or_else</code> function but where a function is only applied to the error case and not the success case.</p>
<h3 id="unwrap_or_default">unwrap_or_default</h3>
<p>Another in the same family of functions is <code>unwrap_or_default</code>, which is defined as:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> unwrap_or_default(<span class="kw">self</span>) <span class="op">-&gt;</span> T</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    T<span class="op">:</span> <span class="bu">Default</span><span class="op">,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(x) <span class="op">=&gt;</span> x<span class="op">,</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(_) <span class="op">=&gt;</span> <span class="bu">Default</span><span class="pp">::</span><span class="kw">default</span>()<span class="op">,</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In the above definition, if a <code>Result</code> is an <code>Err</code> then the default instance of type <code>T</code> is used. The type <code>T</code> has a constraint on it that requires that it has an instance of the <a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a> trait: <code>T: Default</code>.</p>
<p>In summary:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Given: Result&lt;T, E&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Return type: T</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>T<span class="op">:</span> <span class="bu">Default</span>     <span class="op">-&gt;</span> T</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="cn">Ok</span>(t)   <span class="op">-&gt;</span>  t  <span class="op">-&gt;</span> T <span class="co">// Return value in Ok</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="cn">Err</span>(_)         <span class="op">-&gt;</span> T <span class="co">// Return Default instance for T</span></span></code></pre></div>
<p>Here’s an example of how to use it:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result_ok<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">=</span> <span class="cn">Ok</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result_err<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">=</span> <span class="cn">Err</span>(<span class="st">&quot;You have errors&quot;</span><span class="op">.</span>to_owned())<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>result_ok<span class="op">.</span>unwrap_or_default()<span class="op">;</span>  <span class="co">// 1</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>result_err<span class="op">.</span>unwrap_or_default()<span class="op">;</span> <span class="co">// 0</span></span></code></pre></div>
<p>This is also very similar to <code>unwrap_or</code> where, we supply a default value for the error case. With <code>unwrap_or_default</code> the default value is derived from the <code>Default</code> instance for type <code>T</code>.</p>
<ul>
<li>Continue on to <a href="2024-01-24-working-with-rust-result-part-5.html">Transforming Values</a></li>
<li>Back to <a href="2024-01-24-working-with-rust-result.html">TOC</a></li>
</ul>]]></description>
    <pubDate>Wed, 24 Jan 2024 00:00:00 UT</pubDate>
    <guid>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-4.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Working With Rust Result - Extracting Values That Can Panic - Part 3</title>
    <link>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-3.html</link>
    <description><![CDATA[<blockquote>
<p>Note: Do not use these functions if you have better/nicer alternatives.</p>
</blockquote>
<h3 id="unwrap">unwrap</h3>
<p>What if we want to fail (panic) our program if the supplied age is not twenty five?</p>
<p>We can work forcibly by using <code>unwrap</code>. <code>unwrap</code> is defined as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> unwrap(<span class="kw">self</span>) <span class="op">-&gt;</span> T</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    E<span class="op">:</span> <span class="pp">fmt::</span><span class="bu">Debug</span><span class="op">,</span></span></code></pre></div>
<p>The above definition returns the success type <code>T</code> under all conditions. But how can it return a success value <code>T</code> if it’s an <code>Err</code> instance with a value of type <code>E</code>?</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Given: Result&lt;T, E&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="cn">Ok</span>(T)  <span class="op">-&gt;</span> T</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="cn">Err</span>(E) <span class="op">-&gt;</span> T <span class="co">// How do we do this?</span></span></code></pre></div>
<p>Unwrap’s implementation demonstrates how this is achieved:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> unwrap(<span class="kw">self</span>) <span class="op">-&gt;</span> T</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    E<span class="op">:</span> <span class="pp">fmt::</span><span class="bu">Debug</span><span class="op">,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(t) <span class="op">=&gt;</span> t<span class="op">,</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(e) <span class="op">=&gt;</span> unwrap_failed(<span class="st">&quot;called `Result::unwrap()` on an `Err` value&quot;</span><span class="op">,</span> <span class="op">&amp;</span>e)<span class="op">,</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> unwrap_failed(msg<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> error<span class="op">:</span> <span class="op">&amp;</span><span class="kw">dyn</span> <span class="pp">fmt::</span><span class="bu">Debug</span>) <span class="op">-&gt;</span> <span class="op">!</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">panic!</span>(<span class="st">&quot;{msg}: {error:?}&quot;</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>On an <code>Err</code>, the <code>unwrap_failed</code> function is called, which <code>panic</code>s. Since <code>panic</code> doesn’t have a type, the <a href="https://doc.rust-lang.org/std/primitive.never.html">never</a> type:<code>!</code>, coerces the result of <code>unwrap_failed</code> to match type <code>T</code>. This explains how we can always return an value of type <code>T</code> even when we don’t have one.</p>
<p><img src="/images/2024-01-24-working-with-rust-result/unwrap.png" width="600" /></p>
<p>Since we don’t have some sort of default value for <code>T</code> supplied, this function <code>panic</code>s when the result is an <code>Err</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> twenty_five_1<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> twenty_five(<span class="dv">25</span>)<span class="op">.</span>unwrap()<span class="op">;</span> <span class="co">// This works because the result is &#39;Ok&#39;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> twenty_five_2<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> twenty_five(<span class="dv">20</span>)<span class="op">.</span>unwrap()<span class="op">;</span> <span class="co">// This goes boom! because the result is &#39;Err&#39;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">//thread &#39;main&#39; panicked at src/main.rs:9:22:</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">//called `Result::unwrap()` on an `Err` value: &quot;20 is not 25!&quot;</span></span></code></pre></div>
<p>Also note that the error type <code>E</code> has to have an instance of the <code>Debug</code> trait. This is so that the error can be written out if the <code>unwrap</code> causes a <code>panic</code>:</p>
<pre class="terminal scrollx"><code>called `Result::unwrap()` on an `Err` value: &quot;20 is not 25!&quot;</code></pre>
<h3 id="expect">expect</h3>
<p>What if we wanted to customize the error message when we failed dramatically throwing a panic?</p>
<p>We can do that by using the <code>expect</code> method. <code>expect</code> is defined as:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> expect(<span class="kw">self</span><span class="op">,</span> msg<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> T</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    E<span class="op">:</span> <span class="pp">fmt::</span><span class="bu">Debug</span><span class="op">,</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(t) <span class="op">=&gt;</span> t<span class="op">,</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(e) <span class="op">=&gt;</span> unwrap_failed(msg<span class="op">,</span> <span class="op">&amp;</span>e)<span class="op">,</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Similar to the definition for <code>unwrap</code>, a success type of <code>T</code> is always returned or the function panics, but this time with a message we supply:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> twenty_five_1<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> twenty_five(<span class="dv">25</span>)<span class="op">.</span>expect(<span class="st">&quot;Ooops! Looks like you&#39;re not twenty five&quot;</span>)<span class="op">;</span> <span class="co">// This works because the result is &#39;Ok&#39;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> twenty_five_2<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> twenty_five(<span class="dv">20</span>)<span class="op">.</span>expect(<span class="st">&quot;Ooops! Looks like you&#39;re not twenty five&quot;</span>)<span class="op">;</span> <span class="co">// This goes boom! because the result is &#39;Err&#39;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">//thread &#39;main&#39; panicked at src/main.rs:9:22:</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">//Ooops! Looks like you&#39;re not twenty five: &quot;20 is not 25!&quot;</span></span></code></pre></div>
<p>It’s important to note that the value in the <code>Err</code>: “20 is not 25!” is still printed but we get to customize the message preceding it:</p>
<pre class="terminal scrollx"><code>Ooops! Looks like you&#39;re not twenty five</code></pre>
<p>Panic-ing your program is probably the last thing you want to do; It’s something you do when you have no other options. As such it’s highly discouraged. We should only panic when we have no other ways of recovering from the error.</p>
<p>But how do you do that? We’ve already seen some ways to do that with pattern matching, <code>map_or_else</code> and <code>map_or</code>. We will look at nicer ways to unwrap a <code>Result</code> next.</p>
<ul>
<li>Continue on to <a href="2024-01-24-working-with-rust-result-part-4.html">Making Things Nicer with Fallbacks</a></li>
<li>Back to <a href="2024-01-24-working-with-rust-result.html">TOC</a></li>
</ul>]]></description>
    <pubDate>Wed, 24 Jan 2024 00:00:00 UT</pubDate>
    <guid>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-3.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Working With Rust Result - Extracting Values - Part 2</title>
    <link>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-2.html</link>
    <description><![CDATA[<h2 id="pattern-matching">Pattern Matching</h2>
<p>Since <code>Rust</code> supports <a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html">pattern matching</a>, a simple way to extract a value from a <code>Result</code> is to pattern match on its constructors:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> print_age(age_result<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">match</span> age_result <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(age)    <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;You are twenty five!&quot;</span>)<span class="op">,</span> <span class="co">// We could also do something with &#39;age&#39; if we wanted to.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Err</span>(error) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Imposter! {}&quot;</span><span class="op">,</span> error)<span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>print_age(twenty_five(<span class="dv">20</span>))<span class="op">;</span> <span class="co">// Imposter! 20 is not 25!</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>print_age(twenty_five(<span class="dv">25</span>))<span class="op">;</span> <span class="co">// You are twenty five!</span></span></code></pre></div>
<h2 id="map_or_else">map_or_else</h2>
<p>Another way to extract the values from a <code>Result</code> is to use the <code>map_or_else</code> function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> map_or_else<span class="op">&lt;</span>U<span class="op">,</span> D<span class="op">:</span> <span class="bu">FnOnce</span>(E) <span class="op">-&gt;</span> U<span class="op">,</span> F<span class="op">:</span> <span class="bu">FnOnce</span>(T) <span class="op">-&gt;</span> U<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> <span class="kw">default</span><span class="op">:</span> D<span class="op">,</span> f<span class="op">:</span> F) <span class="op">-&gt;</span> U <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(t) <span class="op">=&gt;</span> f(t)<span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="kw">default</span>(e)<span class="op">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In the above definition we get two functions: <code>default</code> and <code>f</code>. Both functions convert a value into the same result type <code>U</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>f      <span class="op">:</span> T <span class="op">-&gt;</span> U <span class="co">// Convert success value to a U</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">default</span><span class="op">:</span> E <span class="op">-&gt;</span> U <span class="co">// Convert error value to a U</span></span></code></pre></div>
<p><code>default</code> is used on the error value inside an <code>Err</code> instance and <code>f</code> is used on the success value inside an <code>Ok</code> instance. <code>map_or_else</code> has simply extracted the “wrapped” value in each constructor and run a function on each of those values to produce a result of the same type in all cases: <code>U</code>.</p>
<p><img src="/images/2024-01-24-working-with-rust-result/map-or-else.png" width="600" /></p>
<p>It’s important to note that the return type of this function is: <code>U</code> and not a <code>Result</code>. We have left the confines of our <code>Result</code> wrappers.</p>
<blockquote>
<p>Technically <code>U</code> could represent any type, even a <code>Result</code>, but we’ll ignore that for now.</p>
</blockquote>
<p>For example to get a pass or failing grade:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> pass_or_fail(grade<span class="op">:</span> <span class="dt">u8</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> grade <span class="op">&lt;</span> <span class="dv">50</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Err</span>(<span class="pp">format!</span>(<span class="st">&quot;You have failed miserably with a grade of: {grade}&quot;</span>))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(<span class="pp">format!</span>(<span class="st">&quot;Here&#39;s your certificate, for a magnificent grade of: {grade}&quot;</span>))</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result1 <span class="op">=</span> pass_or_fail(<span class="dv">45</span>)<span class="op">.</span>map_or_else(<span class="op">|</span>e<span class="op">|</span> e<span class="op">.</span>to_string()<span class="op">,</span> <span class="op">|</span>t<span class="op">|</span> t)<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result2 <span class="op">=</span> pass_or_fail(<span class="dv">75</span>)<span class="op">.</span>map_or_else(<span class="op">|</span>e<span class="op">|</span> e<span class="op">.</span>to_string()<span class="op">,</span> <span class="op">|</span>t<span class="op">|</span> t)<span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{result1}&quot;</span>)<span class="op">;</span> <span class="co">// You have failed miserably with a grade of: 45</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{result2}&quot;</span>)<span class="op">;</span> <span class="co">// Here&#39;s your certificate, for a magnificent grade of: 75</span></span></code></pre></div>
<h2 id="map_or">map_or</h2>
<p>Another function in the same family of functions is <code>map_or</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> map_or<span class="op">&lt;</span>U<span class="op">,</span> F<span class="op">:</span> <span class="bu">FnOnce</span>(T) <span class="op">-&gt;</span> U<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> <span class="kw">default</span><span class="op">:</span> U<span class="op">,</span> f<span class="op">:</span> F) <span class="op">-&gt;</span> U <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(t) <span class="op">=&gt;</span> f(t)<span class="op">,</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(_) <span class="op">=&gt;</span> <span class="kw">default</span><span class="op">,</span> <span class="co">// We ignore the value and return a default</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>Note how we ignore the value inside of <code>Err</code> with <code>Err(_)</code>.</p>
</blockquote>
<p>In the above definition, a function <code>f</code> runs on the value inside the <code>Ok</code> instance and a <code>default</code> value is returned if it’s an <code>Err</code> instance:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pseudocode</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>f      <span class="op">:</span> T <span class="op">-&gt;</span> U <span class="co">// Convert success value to a U</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">default</span><span class="op">:</span>   <span class="op">-&gt;</span> U <span class="co">// Return a U if in error</span></span></code></pre></div>
<p>Notice that we completely ignore the value inside of the <code>Err</code> instance.</p>
<p><img src="/images/2024-01-24-working-with-rust-result/map-or.png" width="600" /></p>
<p><code>map_or</code> differs from <code>map_or_else</code>, in that it only takes a single function <code>f</code> and a default value to return in the <code>Err</code> case. This can be useful if you don’t care about what the error case and simple want to return some default value on error.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust scrollx"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result1 <span class="op">=</span> pass_or_fail(<span class="dv">45</span>)<span class="op">.</span>map_or(<span class="st">&quot;You failed :(&quot;</span><span class="op">.</span>to_owned()<span class="op">,</span> <span class="op">|</span>t<span class="op">|</span> t)<span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> result2 <span class="op">=</span> pass_or_fail(<span class="dv">75</span>)<span class="op">.</span>map_or(<span class="st">&quot;You failed :(&quot;</span><span class="op">.</span>to_owned()<span class="op">,</span> <span class="op">|</span>t<span class="op">|</span> t)<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{result1}&quot;</span>)<span class="op">;</span> <span class="co">// You have failed :(</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{result2}&quot;</span>)<span class="op">;</span> <span class="co">// Here&#39;s your certificate, for a magnificent grade of: 75</span></span></code></pre></div>
<ul>
<li>Continue on to <a href="2024-01-24-working-with-rust-result-part-3.html">Extracting Values That Can Panic</a></li>
<li>Back to <a href="2024-01-24-working-with-rust-result.html">TOC</a></li>
</ul>]]></description>
    <pubDate>Wed, 24 Jan 2024 00:00:00 UT</pubDate>
    <guid>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-2.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Working With Rust Result - Summary - Part 14</title>
    <link>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-14.html</link>
    <description><![CDATA[<p>If you’ve made it this far, you’re probably overwhelmed by all the different methods and their uses!
It helps to try and learn to use them one at a time; as and when needed. The following table summarises which method you would use under different circumstances.</p>
<table>
<tbody>
<tr>
<th>
What do you want to do?
</th>
<th align="right">
Method to use
</th>
</tr>
<tr>
<td align="center">
Create a <code>Result</code>
</td>
<td align="left">
<ul>
<li>
Constructor: <code>Ok(value)</code>
</li>
<li>
Constructor: <code>Err(value)</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Get both values out of a <code>Result</code>
</td>
<td align="left">
<ul>
<li>
<code>Patten matching</code>
</li>
<li>
<code>map_or_else</code>
</li>
<li>
<code>map_or</code>
</li>
<li>
<code>unwrap</code> panics
</li>
<li>
<code>unwrap_or</code>
</li>
<li>
<code>unwrap_or_else</code>
</li>
<li>
<code>unwrap_or_default</code>
</li>
<li>
<code>expect</code> panics
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Run a function on the value inside <code>Ok</code>
</td>
<td align="left">
<ul>
<li>
<code>map</code>
</li>
<li>
<code>and_then</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Run a function on the value inside <code>Err</code>
</td>
<td align="left">
<ul>
<li>
<code>or_else</code>
</li>
<li>
<code>map_err</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Get the value inside <code>Ok</code>
</td>
<td align="left">
<ul>
<li>
<code>unwrap</code> panics
</li>
<li>
<code>expect</code> panics
</li>
<li>
<code>? operator</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Get the value inside <code>Ok</code> with fallback
</td>
<td align="left">
<ul>
<li>
<code>Patten matching</code>
</li>
<li>
<code>map_or</code>
</li>
<li>
<code>unwrap_or</code>
</li>
<li>
<code>unwrap_or_else</code>
</li>
<li>
<code>unwrap_or_default</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Get the value inside <code>Err</code>
</td>
<td align="left">
<ul>
<li>
<code>unwrap_err</code> panics
</li>
<li>
<code>expect_err</code> panics
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Get the value inside <code>Err</code> with fallback
</td>
<td align="left">
<ul>
<li>
<code>Patten matching</code>
</li>
<li>
<code>map_or</code>
</li>
<li>
<code>unwrap_or</code>
</li>
<li>
<code>unwrap_or_else</code>
</li>
<li>
<code>unwrap_or_default</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Combine two <code>Result</code>s that are <code>Ok</code>
</td>
<td align="left">
<ul>
<li>
<code>and_then</code>
</li>
<li>
<code>and</code>
</li>
<li>
<code>? operator</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Combine two <code>Result</code>s that are <code>Err</code>
</td>
<td align="left">
<ul>
<li>
<code>or</code>
</li>
<li>
<code>or_else</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Convert <code>Ok</code> to <code>Option</code> as <code>Some</code>
</td>
<td align="left">
<ul>
<li>
<code>ok</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Convert <code>Err</code> to <code>Option</code> as <code>Some</code>
</td>
<td align="left">
<ul>
<li>
<code>err</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Convert <code>Result&lt;Option&gt;</code> to <code>Option&lt;Result&gt;</code>
</td>
<td align="left">
<ul>
<li>
<code>transpose</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Test for <code>Ok</code>
</td>
<td align="left">
<ul>
<li>
<code>is_ok</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Test for <code>Err</code>
</td>
<td align="left">
<ul>
<li>
<code>is_err</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Test for <code>Ok</code> and run a predicate
</td>
<td align="left">
<ul>
<li>
<code>is_ok_and</code>
</li>
</ul>
</td>
</tr>
<tr>
<td align="center">
Test for <code>Err</code> and run a predicate
</td>
<td align="left">
<ul>
<li>
<code>is_err_and</code>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>I hope this somewhat lengthy series helped you learn some more about Rust’s <code>Result</code> type. If you found any errors or omissions or found this useful, please leave a comment.</p>
<h2 id="feedback-from-the-review-lounge">Feedback from the review lounge</h2>
<h3 id="sirkastic23">SirKastic23</h3>
<p>A huge thanks to <code>SirKastic23</code> for giving me some sound feedback on Reddit:</p>
<blockquote class="reddit-embed-bq" data-embed-showtitle="true" data-embed-theme="dark" data-embed-height="386">
<a href="https://www.reddit.com/r/rust/comments/1ckbn6f/comment/l2n8wtf/">Comment</a><br> by<a href="https://www.reddit.com/user/ssanjs/">u/ssanjs</a> from discussion<a href="https://www.reddit.com/r/rust/comments/1ckbn6f/working_with_rust_result/"><no value=""></no></a><br> in<a href="https://www.reddit.com/r/rust/">rust</a>
</blockquote>
<script async="" src="https://embed.reddit.com/widgets.js" charset="UTF-8"></script>
<p>I’ve made the updates to the sections marked “unsafe”. I’ll get to dark mode in the near future.</p>
<ul>
<li>Back to <a href="2024-01-24-working-with-rust-result.html">TOC</a></li>
</ul>]]></description>
    <pubDate>Wed, 24 Jan 2024 00:00:00 UT</pubDate>
    <guid>https://blog.ssanj.net/posts/2024-01-24-working-with-rust-result-part-14.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>

    </channel>
</rss>
