<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>BabylonCandle</title>
        <link>http://blog.ssanj.net</link>
        <description><![CDATA[The blog of Sanjiv Sahayam]]></description>
        <atom:link href="http://blog.ssanj.net/feed.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 17 Oct 2018 00:00:00 UT</lastBuildDate>
        <item>
    <title>How to Show Git Commit Hash for Tags</title>
    <link>http://blog.ssanj.net/posts/2018-10-17-how-to-show-git-commit-hash-for-tags.html</link>
    <description><![CDATA[<p>To list the commit hash for every tag in a repo use:</p>
<pre class="command scrollx"><code>git show-ref --tags</code></pre>
<p>which yields something like:</p>
<pre class="terminal scrollx"><code>ee02aa7363f9988af700ab136a219c455cab4b5f refs/tags/v.0.4.0
2d5befba5bc80a69c6308d2a5da965488e6bf9d7 refs/tags/v.0.4.1
0099c11405a3ace8ee14b0881f9677bfc1e30f5e refs/tags/v0.4.1</code></pre>
<p>To only list the commit hash for a particular tag use:</p>
<pre class="command scrollx"><code>git show-ref tag_name</code></pre>
<p>for example, to list the commit hash for v0.4.1 use:</p>
<pre class="command scrollx"><code>git show-ref v0.4.1</code></pre>
<p>which gives you a single hash:</p>
<pre class="terminal scrollx"><code>0099c11405a3ace8ee14b0881f9677bfc1e30f5e refs/tags/v0.4.1</code></pre>
<p>To display the contents of a hash use:</p>
<pre class="command scrollx"><code>git show hash</code></pre>]]></description>
    <pubDate>Wed, 17 Oct 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-10-17-how-to-show-git-commit-hash-for-tags.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Defining a multiline function in Haskell using Ghci</title>
    <link>http://blog.ssanj.net/posts/2018-08-09-defining-a-multiline-function-in-haskell-using-ghci.html</link>
    <description><![CDATA[<p>I’ve always found it difficult to remember the exact syntax for setting Ghci into multiline mode and defining a function therein. Below are the steps for easy access.</p>
<p>Start by setting Ghci into multiline mode with:</p>
<pre class="command scrollx"><code>:set +m</code></pre>
<p>You can start a multiline block with <code>:{</code> and end it with <code>:}</code>.</p>
<p>Function definitions must be preceded with <code>let</code>. This has tripped me up many times.</p>
<p>For example, to define a function that pauses for a given delay before printing out “done”:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="fu">:</span>{
  <span class="kw">let</span><span class="ot"> printAfter ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
      printAfter delay <span class="fu">=</span>
        <span class="kw">do</span> putStrLn <span class="fu">$</span> (\d <span class="ot">-&gt;</span> <span class="st">&quot;waiting for &quot;</span> <span class="fu">++</span> d <span class="fu">++</span> <span class="st">&quot; microseconds&quot;</span>) <span class="fu">$</span> show delay
           threadDelay delay
           putStrLn <span class="st">&quot;done&quot;</span>
<span class="fu">:</span>}</code></pre></div>
<p>To unset multiline mode use:</p>
<pre class="command scrollx"><code>:unset +m</code></pre>
<p>References: <a href="https://stackoverflow.com/questions/8443035/multi-line-commands-in-ghci">Multi-line commands in GHCi</a>, <a href="https://stackoverflow.com/questions/2846050/how-to-define-a-function-in-ghci-across-multiple-lines">How to define a function in ghci across multiple lines?</a></p>]]></description>
    <pubDate>Thu, 09 Aug 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-08-09-defining-a-multiline-function-in-haskell-using-ghci.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Loading a Package into GHCi through Stack</title>
    <link>http://blog.ssanj.net/posts/2018-04-10-loading-a-package-into-ghci-through-stack.html</link>
    <description><![CDATA[<p>Ever wanted to play around with a particular set of packages in GHCi but didn’t want to setup a project? You’re in luck. With Stack you can now selectively load named packages and launch directly into GHCi. The incantation you need is:</p>
<pre class="terminal scrollx"><code>stack ghci --package [package-name1] --package [package-name2]</code></pre>
<p>For example to load the transformers package:</p>
<pre class="terminal scrollx"><code>stack ghci --package transformers</code></pre>
<p>And now we have transformers loaded in GHCi:</p>
<pre class="command scrollx"><code>*Main Lib&gt; import Control.Monad.
Control.Monad.Fail                 Control.Monad.Trans.Except
Control.Monad.Fix                  Control.Monad.Trans.Identity
Control.Monad.IO.Class             Control.Monad.Trans.List
Control.Monad.Instances            Control.Monad.Trans.Maybe
Control.Monad.ST                   Control.Monad.Trans.RWS
Control.Monad.ST.Lazy              Control.Monad.Trans.RWS.Lazy
Control.Monad.ST.Lazy.Safe         Control.Monad.Trans.RWS.Strict
Control.Monad.ST.Lazy.Unsafe       Control.Monad.Trans.Reader
Control.Monad.ST.Safe              Control.Monad.Trans.State
Control.Monad.ST.Strict            Control.Monad.Trans.State.Lazy
Control.Monad.ST.Unsafe            Control.Monad.Trans.State.Strict
Control.Monad.Signatures           Control.Monad.Trans.Writer
Control.Monad.Trans.Class          Control.Monad.Trans.Writer.Lazy
Control.Monad.Trans.Cont           Control.Monad.Trans.Writer.Strict
Control.Monad.Trans.Error          Control.Monad.Zip
*Main Lib&gt; import Control.Monad.Trans.Writer.Lazy</code></pre>
<p><a href="https://stackoverflow.com/questions/39848576/load-a-new-package-in-ghci-using-stack#39848577">Reference</a></p>]]></description>
    <pubDate>Tue, 10 Apr 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-04-10-loading-a-package-into-ghci-through-stack.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>How does filterM work in Haskell?</title>
    <link>http://blog.ssanj.net/posts/2018-04-10-how-does-filterm-work-in-haskell.html</link>
    <description><![CDATA[<p><strong>filterM</strong> is an interesting function. In one sense it’s very similar to <strong>filter</strong> which we all know and love. It’s much more powerful though as we shall soon see. Let’s start by having a look at the definition of <strong>filter</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filter<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</code></pre></div>
<p>and then at filterM:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">filterM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</code></pre></div>
<p>A side-by-side comparison:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filter<span class="ot"> ::</span>                   (a <span class="ot">-&gt;</span>   <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span>   [a]
<span class="ot">filterM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</code></pre></div>
<p>By comparing the type signatures of <strong>filter</strong> and <strong>filterM</strong> we can see that <strong>filterM</strong> is just <strong>filter</strong> where the conditional expression yields a <strong>Bool</strong> within a context <strong>m</strong> and where the matching results are aggregated in the <strong>m</strong> context.</p>
<p>The implementation of <strong>filterM</strong> in <a href="https://hackage.haskell.org/package/base-4.11.0.0/docs/src/Control.Monad.html#filterM">GCH base</a> is as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">filterM   ::</span> (<span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]
filterM p <span class="fu">=</span> foldr (\x <span class="ot">-&gt;</span> liftA2 (\flg <span class="ot">-&gt;</span> <span class="kw">if</span> flg <span class="kw">then</span> (x<span class="fu">:</span>) <span class="kw">else</span> id) (p x)) (pure [])</code></pre></div>
<p>From the above definition it looks like whenever the monadic filter function <code>(a -&gt; m Bool)</code> returns a <code>m True</code>, the value in the supplied list is prepended to an accumulator, and if it doesn’t match the existing accumulator is left unchanged.</p>
<p>Although this sound very simple, I found the usage of <strong>filterM</strong> to be somewhat difficult to understand - at least at first. Let’s start investigating its usage by looking at some example instances for <strong>m</strong>.</p>
<h2 id="maybe">Maybe</h2>
<p>Given a list of numbers:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">numbers ::</span> [<span class="dt">Int</span>]
numbers <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</code></pre></div>
<p>and an <strong>isEven</strong> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">isEven ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isEven n <span class="fu">=</span> n <span class="ot">`mod`</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">0</span></code></pre></div>
<p>we can use <strong>filterM</strong> to filter the list of numbers that are even and return the results in a <strong>Maybe</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM (<span class="dt">Just</span> <span class="fu">.</span> isEven) numbers</code></pre></div>
<p>which results in:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">Just</span> [<span class="dv">2</span>,<span class="dv">4</span>]</code></pre></div>
<p>That seems pretty easy. Using <strong>filter</strong> on <strong>numbers</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filter isEven numbers</code></pre></div>
<p>we get:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">[<span class="dv">2</span>,<span class="dv">4</span>]</code></pre></div>
<p>The only difference between the results being that the <strong>filterM</strong> variant has the results in the <strong>Maybe</strong> Monad.</p>
<p>What happens when <strong>filterM</strong> takes a function that can return <strong>Nothing</strong> in some instances?</p>
<p>Given the following function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">isDivisibleByThree ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isDivisibleByThree n <span class="fu">=</span> n <span class="ot">`mod`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span></code></pre></div>
<p>Let’s filter our list of numbers so that they contain even numbers, but if we encounter a number that is divisible by three, we want to bail on the result:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM (\n <span class="ot">-&gt;</span> <span class="kw">if</span> isDivisibleByThree n <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (isEven n)) numbers</code></pre></div>
<p>this results in:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">Nothing</span></code></pre></div>
<p>Now, this might be a little surprising. What happened to all the matches until we encountered a three, such as two? Recall that the <strong>filterM</strong> implementation:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM p <span class="fu">=</span> foldr (\x <span class="ot">-&gt;</span> liftA2 (\flg <span class="ot">-&gt;</span> <span class="kw">if</span> flg <span class="kw">then</span> (x<span class="fu">:</span>) <span class="kw">else</span> id) (p x)) (pure [])</code></pre></div>
<p>uses <strong>liftA2</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">liftA2 ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</code></pre></div>
<p>to run a binary function over the Applicative instances. With two <strong>Maybe</strong> instances, the result is always <strong>Nothing</strong>, if one of them is <strong>Nothing</strong> as you can’t run the function without both inputs:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">liftA2 (<span class="fu">+</span>) (<span class="dt">Just</span> <span class="dv">1</span>) (<span class="dt">Just</span> <span class="dv">2</span>) <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">3</span>
liftA2 (<span class="fu">+</span>) (<span class="dt">Just</span> <span class="dv">1</span>) <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">Nothing</span>
liftA2 (<span class="fu">+</span>) <span class="dt">Nothing</span> (<span class="dt">Just</span> <span class="dv">2</span>)  <span class="fu">=</span> <span class="dt">Nothing</span>
liftA2 (<span class="fu">+</span>) <span class="dt">Nothing</span> <span class="dt">Nothing</span>   <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>What this demonstrates is that if we ever receive a <strong>Nothing</strong> value while using <strong>filterM</strong> all results up until that point are discarded. This highlights one key difference between <strong>filter</strong> and <strong>filterM</strong>; in addition to filtering on the <strong>Bool</strong> result, <strong>filterM</strong> also combines the results using its Applicative properties.</p>
<p>Let’s run the <strong>filterM</strong> code once again, but this time, we’ll leave out any multiples of three:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM (\n <span class="ot">-&gt;</span> <span class="kw">if</span> isDivisibleByThree n <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (isEven n)) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">8</span>]</code></pre></div>
<p>and this time the answer is:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">Just</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">8</span>]</code></pre></div>
<h2 id="io">IO</h2>
<p>Let’s try filtering only even numbers using the <strong>IO</strong> Monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">ioFilterM (pure <span class="fu">.</span> isEven) numbers
<span class="fu">=</span> [<span class="dv">2</span>, <span class="dv">4</span>] <span class="co">-- IO [Int]</span></code></pre></div>
<p>That works as expected. Now let’s introduce a failure in <strong>IO</strong> Monad when a number is divisible by three:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM (\n <span class="ot">-&gt;</span> <span class="kw">if</span> isDivisibleByThree n <span class="kw">then</span> ioError (userError <span class="st">&quot;boom!&quot;</span>) <span class="kw">else</span> pure (isEven n)) numbers
<span class="fu">=</span> <span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> user error (boom<span class="fu">!</span>) <span class="co">-- IO [Int]</span></code></pre></div>
<p>The above discards any results collected once it reaches an <strong>IO</strong> error. This functionality is very similar to how the <strong>Maybe</strong> Monad filtered when it received a <strong>Nothing</strong>. This is quite useful when filtering only valid results and failing on the first failure.</p>
<p>And if we remove any numbers divisible by three:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM (\n <span class="ot">-&gt;</span> <span class="kw">if</span> isDivisibleByThree n <span class="kw">then</span> ioError (userError <span class="st">&quot;boom!&quot;</span>) <span class="kw">else</span> pure (isEven n)) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">8</span>]
<span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">8</span>] <span class="co">-- IO [Int]</span></code></pre></div>
<p>we get back the expected results.</p>
<h2 id="list">List</h2>
<p>With List, things get more interesting. Consider the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM (\n <span class="ot">-&gt;</span> [<span class="dt">True</span>, <span class="dt">False</span>]) numbers</code></pre></div>
<p>What do you reckon the answer would be? Probably not a <a href="https://en.wikipedia.org/wiki/Power_set">powerset</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">2</span>],
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">1</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">5</span>],[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]
,[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">2</span>,<span class="dv">4</span>],[<span class="dv">2</span>,<span class="dv">5</span>],[<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">3</span>,<span class="dv">5</span>],[<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">4</span>],
[<span class="dv">5</span>],[]]</code></pre></div>
<p>Remember that <strong>filterM</strong> is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM p <span class="fu">=</span> foldr (\x <span class="ot">-&gt;</span> liftA2 (\flg <span class="ot">-&gt;</span> <span class="kw">if</span> flg <span class="kw">then</span> (x<span class="fu">:</span>) <span class="kw">else</span> id) (p x)) (pure [])</code></pre></div>
<p>How does this work with List? If we use <strong>liftA2</strong> with List:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">liftA2 (<span class="fu">+</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
<span class="fu">=</span> [<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>]</code></pre></div>
<p>we see that we get a <a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a> of values (all combinations). List is a non-deterministic Monad and as such it produces results of every possible combination.</p>
<p>Let’s start by expanding out the point-free implementation of <strong>filterM</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">filterM p <span class="fu">=</span>
  foldr (\x acc <span class="ot">-&gt;</span> liftA2 (\flg1 accx <span class="ot">-&gt;</span> <span class="kw">if</span> flg1 <span class="kw">then</span> (x<span class="fu">:</span>accx) <span class="kw">else</span> accx) (p x) acc) (pure [])</code></pre></div>
<p><strong>accx</strong> is the accumulator value passed to <strong>liftA2</strong>. The values passed will be the Cartesian product of <strong>[True, False]</strong> and the accumulator of list <strong>acc</strong>, which is initially <strong>[[]]</strong>.</p>
<p>There are two main expansions happening in the implementation of <strong>filterM</strong>:</p>
<ol style="list-style-type: decimal">
<li><strong>liftA2</strong> is creating a Cartesian product of the flags <strong>[True, False]</strong> and the accumulator <strong>acc</strong> and combining them with supplied function, which prepends the current value of the list <strong>x</strong> to the accumulator <strong>accx</strong> if the flag is True or returns the existing accumulator <strong>accx</strong> if it is False.</li>
<li>All the combinations returned from <strong>listA2</strong> are then returned into <strong>foldr</strong> as the new value of the accumulator <strong>acc</strong>.</li>
</ol>
<p>Because <strong>filterM</strong> is implemented using <strong>foldr</strong> the accumulated values are used from last to first.</p>
<p>Given the following legend:</p>
<pre class="terminal scrollx"><code>x      -- element in the list
acc    -- value of accumulator
accx   -- value of accumulator at current combination
flg1   -- value of flag at current combination
result -- value of accx after applying flg1
newacc -- value of acc returned to foldr</code></pre>
<p>Let’s start from the end of the list at 5 and follow it up to 1.</p>
<p>For the value of 5:</p>
<pre class="terminal scrollx"><code>x = 5
acc = [[]]
flags = [True, False]
--------------------
accx []
flg1 True
result = 5:[] =&gt; [5]
--------------------
accx []
flg1 False
result =&gt; []
--------------------
newacc = [[5], []]</code></pre>
<p>For the value of 4:</p>
<pre class="terminal scrollx"><code>x = 4
acc = [[5], []]
flags = [True, False]
--------------------
accx [5]
flg1 True
result = 4:[5] =&gt; [4,5]
--------------------
accx []
flg1 True
result = 4:[] =&gt; [4]
--------------------
accx [5]
flg1 False
result =&gt; [5]
--------------------
accx []
flg1 False
result =&gt; []
--------------------
newacc = [[4,5],[4],[5], []]</code></pre>
<p>For the value of 3:</p>
<pre class="terminal scrollx"><code>x = 3
acc = [[4,5],[4],[5], []]
flags = [True, False]
--------------------
accx [4,5]
flg1 True
result = 3:[4,5] =&gt; [3,4,5]
--------------------
accx [4]
flg1 True
result = 3:[4] =&gt; [3,4]
--------------------
accx [5]
flg1 True
result = 3:[5] =&gt; [3,5]
--------------------
accx []
flg1 True
result = 3:[] =&gt; [3]
--------------------
accx [4,5]
flg1 False
result =&gt; [4,5]
--------------------
accx [4]
flg1 False
result =&gt; [4]
--------------------
accx [5]
flg1 False
result =&gt; [5]
--------------------
accx []
flg1 False
result =&gt; []
--------------------
newacc = [[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]</code></pre>
<p>For the value of 2:</p>
<pre class="terminal scrollx"><code>x = 2
acc = [[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]
flags = [True, False]
--------------------
accx [3,4,5]
flg1 True
result = 2:[3,4,5] =&gt; [2,3,4,5]
--------------------
accx [3,4]
flg1 True
result = 2:[3,4] =&gt; [2,3,4]
--------------------
accx [3,5]
flg1 True
result = 2:[3,5] =&gt; [2,3,5]
--------------------
accx [3]
flg1 True
result = 2:[3] =&gt; [2,3]
--------------------
accx [4,5]
flg1 True
result = 2:[4,5] =&gt; [2,4,5]
--------------------
accx [4]
flg1 True
result = 2:[4] =&gt; [2,4]
--------------------
accx [5]
flg1 True
result = 2:[5] =&gt; [2,5]
--------------------
accx []
flg1 True
result = 2:[] =&gt; [2]
--------------------
accx [3,4,5]
flg1 False
result =&gt; [3,4,5]
--------------------
accx [3,4]
flg1 False
result =&gt; [3,4]
--------------------
accx [3,5]
flg1 False
result =&gt; [3,5]
--------------------
accx [3]
flg1 False
result =&gt; [3]
--------------------
accx [4,5]
flg1 False
result =&gt; [4,5]
--------------------
accx [4]
flg1 False
result =&gt; [4]
--------------------
accx [5]
flg1 False
result =&gt; [5]
--------------------
accx []
flg1 False
result =&gt; []
--------------------
newacc = [[2,3,4,5],[2,3,4],[2,3,5],[2,3],[2,4,5],[2,4],[2,5],[2],[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]</code></pre>
<p>For the value of 1:</p>
<pre class="terminal scrollx"><code>x = 1
acc = [[2,3,4,5],[2,3,4],[2,3,5],[2,3],[2,4,5],[2,4],[2,5],[2],[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]
flags = [True, False]
--------------------
accx [2,3,4,5]
flg1 True
result = 1:[2,3,4,5] =&gt; [1,2,3,4,5]
--------------------
accx [2,3,4]
flg1 True
result = 1:[2,3,4] =&gt; [1,2,3,4]
--------------------
accx [2,3,5]
flg1 True
result = 1:[2,3,5] =&gt; [1,2,3,5]
--------------------
accx [2,3]
flg1 True
result = 1:[2,3] =&gt; [1,2,3]
--------------------
accx [2,4,5]
flg1 True
result = 1:[2,4,5] =&gt; [1,2,4,5]
--------------------
accx [2,4]
flg1 True
result = 1:[2,4] =&gt; [1,2,4]
--------------------
accx [2,5]
flg1 True
result = 1:[2,5] =&gt; [1,2,5]
--------------------
accx [2]
flg1 True
result = 1:[2] =&gt; [1,2]
--------------------
accx [3,4,5]
flg1 True
result = 1:[3,4,5] =&gt; [1,3,4,5]
--------------------
accx [3,4]
flg1 True
result = 1:[3,4] =&gt; [1,3,4]
--------------------
accx [3,5]
flg1 True
result = 1:[3,5] =&gt; [1,3,5]
--------------------
accx [3]
flg1 True
result = 1:[3] =&gt; [1,3]
--------------------
accx [4,5]
flg1 True
result = 1:[4,5] =&gt; [1,4,5]
--------------------
accx [4]
flg1 True
result = 1:[4] =&gt; [1,4]
--------------------
accx [5]
flg1 True
result = 1:[5] =&gt; [1,5]
--------------------
accx []
flg1 True
result = 1:[] =&gt; [1]
-------------------- *
accx [2,3,4,5]
flg1 False
result =&gt; [2,3,4,5]
--------------------
accx [2,3,4]
flg1 False
result =&gt; [2,3,4]
--------------------
accx [2,3,5]
flg1 False
result =&gt; [2,3,5]
--------------------
accx [2,3]
flg1 False
result =&gt; [2,3]
--------------------
accx [2,4,5]
flg1 False
result =&gt; [2,4,5]
--------------------
accx [2,4]
flg1 False
result =&gt; [2,4]
--------------------
accx [2,5]
flg1 False
result =&gt; [2,5]
--------------------
accx [2]
flg1 False
result =&gt; [2]
--------------------
accx [3,4,5]
flg1 False
result =&gt; [3,4,5]
--------------------
accx [3,4]
flg1 False
result =&gt; [3,4]
--------------------
accx [3,5]
flg1 False
result =&gt; [3,5]
--------------------
accx [3]
flg1 False
result =&gt; [3]
--------------------
accx [4,5]
flg1 False
result =&gt; [4,5]
--------------------
accx [4]
flg1 False
result =&gt; [4]
--------------------
accx [5]
flg1 False
result =&gt; [5]
--------------------
accx []
flg1 False
result =&gt; []
--------------------

newacc = [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1,3,4,5],[1,3,4],[1,3,5],[1,3],[1,4,5],[1,4],[1,5],[1],[2,3,4,5],[2,3,4],[2,3,5],[2,3],[2,4,5],[2,4],[2,5],[2],[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]</code></pre>
<p>That was a bit harder than necessary!</p>
<h2 id="either">Either</h2>
<p>Using <strong>filterM</strong> with <strong>Either</strong> is pretty much the same as a <strong>Maybe</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">let</span> e1 <span class="fu">=</span> filterM (\x <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="fu">==</span> <span class="dv">11</span> <span class="kw">then</span> <span class="dt">Left</span> <span class="st">&quot;You gave me eleven&quot;</span> <span class="kw">else</span> <span class="dt">Right</span> (isEven x))
<span class="co">-- e1 :: :: Integral a =&gt; [a] -&gt; Either [Char] [a]</span>
e1 [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">10</span>]
<span class="fu">=</span> <span class="dt">Right</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>] <span class="co">-- only even numbers</span>
e1 [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">11</span>]
<span class="fu">=</span> <span class="dt">Left</span> <span class="st">&quot;You gave me eleven&quot;</span> <span class="co">-- drops all results on a Left</span></code></pre></div>
<h2 id="state">State</h2>
<p>Now let’s use a Monad that has two type holes which are both used together. The State Monad allows us to return a value and thread through some state we are interested in at the same time. Let’s use our <strong>isEven</strong> method to filter in all the even inputs and use a list to record all the values inspected along the way:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">let</span> x1 <span class="fu">=</span> filterM (\x <span class="ot">-&gt;</span> state (\s <span class="ot">-&gt;</span> (isEven(x), s <span class="fu">++</span> [x]))) [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">10</span>]
<span class="co">-- x1 :: (Integral a, Monad m) =&gt; StateT [a] m [a]</span>
evalState x1 []          <span class="co">-- get value</span>
<span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>]           <span class="co">-- only even numbers</span>
execState x1 []          <span class="co">-- get state</span>
<span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>] <span class="co">-- the state - all inspected values</span></code></pre></div>
<p>The interesting thing to note is that given <strong>x1</strong>’s type:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">x1 ::</span> (<span class="dt">Integral</span> a, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">StateT</span> [a] m [a]</code></pre></div>
<p>The <strong>m</strong> in <strong>filterM</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">filterM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</code></pre></div>
<p>is:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">StateT</span> [a] m</code></pre></div>
<p>which is why we can return a Bool in the value position and have it filter the inputs for us.</p>
<p>Hopefully that was somewhat easier to understand. You can find alternate explanations to this problem <a href="https://stackoverflow.com/questions/25476248/powerset-function-1-liner#45105085">here</a> and <a href="https://byorgey.wordpress.com/2007/06/26/deducing-code-from-types-filterm">here</a>.</p>]]></description>
    <pubDate>Tue, 10 Apr 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-04-10-how-does-filterm-work-in-haskell.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>The Consolations of Philosophy - Alain de Botton</title>
    <link>http://blog.ssanj.net/posts/2018-03-27-the-consolations-of-philosphy-alain-de-botton.html</link>
    <description><![CDATA[<p>Ideas from the book <a href="https://www.amazon.com/Consolations-Philosophy-Alain-Botton-ebook/dp/B002RI9DM4">The Consolations of Philosophy by Alain de Botton</a>.</p>
<ol style="list-style-type: decimal">
<li>The validity of an idea or action is determined not by whether it is widely believed or widely reviled but by whether it obeys the rules of logic.</li>
<li>A statement is true if it cannot be disproved.</li>
<li>The Socratic Method:
<ol style="list-style-type: decimal">
<li>Locate a statement confidently described as common sense.</li>
<li>Imagine for a moment that, despite the confidence of the person proposing it, the statement is false.</li>
<li>Search for situations or contexts where the statement would not be true.</li>
<li>If an exception is found, the definition must be false or at least imprecise.</li>
<li>The initial statement must be nuanced to take the exception into account.</li>
</ol></li>
<li>It is by finding out what something is not that one comes closest to understanding what it is.</li>
<li>We acquire a misplaced respect for others when we concentrate solely on their conclusions – which is why Socrates urged us to dwell on the logic they used to reach them.</li>
<li>The value of criticism will depend on the thought processes of critics, not on their number or rank.</li>
<li>We are making vases, we should listen to the advice of those who know about turning glaze into Fe3O4 at 800 ° C; when we are making a ship, it is the verdict of those who construct triremes that should worry us.</li>
<li>We should not look to Socrates for advice on escaping a death sentence; we should look to him as an extreme example of how to maintain confidence in an intelligent position which has met with illogical opposition.</li>
<li>Just as medicine confers no benefit if it does not drive away physical illness, so philosophy is useless if it does not drive away the suffering of the mind.</li>
<li>Before you eat or drink anything, consider carefully who you eat or drink with rather than what you eat or drink: for feeding without a friend is the life of a lion or a wolf.</li>
<li>Nothing satisfies the man who is not satisfied with a little.</li>
<li>Could one possess the desired object but not be happy? Could one be happy but not have the desired object?</li>
<li>We aren’t overwhelmed by anger whenever we are denied an object we desire, only when we believe ourselves entitled to obtain it.</li>
<li>No, he who has said ‘a day’ has granted too long a postponement to swift misfortune; an hour, an instant of time, suffices for the overthrow of empires.</li>
<li>We need metaphors to derive a sense of what cannot be seen or touched, or else we will forget.</li>
<li>The wise man can lose nothing. He has everything invested in himself. The wise man is self-sufficient. If he loses a hand through disease or war, or if some accident puts out one or both of his eyes, he will be satisfied with what is left.</li>
<li>To calm us down in noisy streets, we should trust that those making a noise know nothing of us.</li>
<li>Wisdom lies in correctly discerning where we are free to mould reality according to our wishes and where we must accept the unalterable with tranquillity.</li>
<li>We are like dogs who have been tied to an unpredictable cart.</li>
<li>We may be powerless to alter certain events, but we remain free to choose our attitude towards them, and it is in our spontaneous acceptance of necessity that we find our distinctive freedom</li>
<li>That which you cannot reform, it is best to endure.</li>
</ol>
<div>
<div class="quote">
<p>Upon the highest throne in the world, we are seated, still, upon our arses</p>
</div>
<div class="attribution">
Montaigne
</div>
<ol start="22" style="list-style-type: decimal">
<li>Every man may bear the whole form of the human condition, but it seems that no single country can tolerate the complexity of this condition.</li>
<li>Friendship is a minor conspiracy against what other people think of as reasonable.</li>
</ol>
<div>
<div class="quote">
<p>I have seen in my time hundreds of craftsmen and ploughmen wiser and happier than university rectors.</p>
</div>
<div class="attribution">
Montaigne
</div>
</div>
<ol start="24" style="list-style-type: decimal">
<li>What reads easily is rarely so written.</li>
<li>The prudent man strives for freedom from pain, not pleasure.</li>
<li>What if pleasure and displeasure were so tied together that whoever wanted to have as much as possible of one must also have as much as possible of the other?</li>
<li>In the mountains of truth you will never climb in vain: either you will get up higher today or you will exercise your strength so as to be able to get up higher tomorrow.</li>
</ol>
<div>
<div class="quote">
How can anyone become a thinker if he does not spend at least a third of the day without passions, people and books?
</div>
<div class="attribution">
Nietzsche
</div>
</div>
<ol start="28" style="list-style-type: decimal">
<li>Not everything which makes us feel better is good for us. Not everything which hurts may be bad.</li>
</ol>]]></description>
    <pubDate>Tue, 27 Mar 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-03-27-the-consolations-of-philosphy-alain-de-botton.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Functor, Applicative and Monad instances for Reader</title>
    <link>http://blog.ssanj.net/posts/2018-03-05-functor-applicative-and-monad-instances-for-reader.html</link>
    <description><![CDATA[<p>How do you define a Reader (-&gt; r) instance of a <strong>Functor</strong>, <strong>Applicative</strong> or even a <strong>Monad</strong>? A Reader is a function that takes some resource <strong>r</strong> and returns another value. This has been something that has always confused me. After an initial peruse it all makes sense for a while but when next faced with the same problem I can’t remember how these instances are implemented.</p>
<p>I’d like to analyse how the Reader instances are derived for each of <strong>Functor</strong>, <strong>Applicative</strong> and <strong>Monad</strong> and test it against some examples to gain some intuition. Also note that (-&gt; r) and (r -&gt;) can be used interchangeably. Thanks to <a href="https://www.youtube.com/watch?v=qH0EjlM9Cm4">Brian McKenna</a> for that useful titbit.</p>
<h2 id="functor">Functor</h2>
<p>A functor typeclass is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
  fmap,<span class="ot"> (&lt;$&gt;) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p><strong>fmap</strong> or <strong>&lt;$&gt;</strong> basically runs a function (<strong>a -&gt; b</strong>), on a value within some context <strong>f a</strong> and returns the context with the function applied to its value as an <strong>f b</strong>.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(a <span class="ot">-&gt;</span> b)  <span class="co">-- f&#39;, a function that requires an &#39;a&#39; to create a &#39;b&#39;</span>
f a       <span class="co">-- Functor with an &#39;a&#39;</span>
f (f&#39;(a)) <span class="co">-- apply f&#39; to the &#39;a&#39;</span>
f b       <span class="co">-- the final result of a &#39;b&#39;</span></code></pre></div>
<p>Let’s take a look at the <strong>Functor</strong> instance for <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#t:Maybe">Maybe</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  <span class="co">-- fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span>
  fmap f (<span class="dt">Just</span> a) <span class="fu">=</span>  <span class="dt">Just</span> (f a)
  fmap _ <span class="dt">Nothing</span>  <span class="fu">=</span>  <span class="dt">Nothing</span></code></pre></div>
<p>With <strong>Maybe</strong>, the function <strong>f</strong>, is applied to a value within a <strong>Just</strong> or not applied if the value is a <strong>Nothing</strong>.</p>
<p>When we hear that (-&gt; r) is also a Functor it can boggle our minds a little. How do we define an instance for that?</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="ot">-&gt;</span> r) <span class="kw">where</span>
  fmap f <span class="fu">=</span> <span class="co">-- what goes here?</span></code></pre></div>
<p>We need a function that takes some resource <strong>r</strong> and returns some other value. Let’s have a crack at deriving the implementation for Functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (r <span class="ot">-&gt;</span> ) <span class="kw">where</span>
<span class="co">-- fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span>
  fmap fab      f a       <span class="fu">=</span> f b                 <span class="co">-- refer to (a -&gt; b) as fab</span>
  fmap fab      (\r <span class="ot">-&gt;</span> a) <span class="fu">=</span> (\r <span class="ot">-&gt;</span> b)           <span class="co">-- given that the Functor is (r -&gt;), replace &#39;f&#39; with (r -&gt;)</span>
  fmap fab      fra       <span class="fu">=</span> (\r <span class="ot">-&gt;</span> b)           <span class="co">-- refer to (r -&gt; a) as fra so we can use it</span>
  fmap fab      fra       <span class="fu">=</span> (\r <span class="ot">-&gt;</span> <span class="fu">???</span> (fra r)) <span class="co">-- we have an &#39;r&#39; and we have something that needs an &#39;r&#39; and returns an &#39;a&#39;.</span>
  fmap fab      fra       <span class="fu">=</span> (\r <span class="ot">-&gt;</span> fab (fra r)) <span class="co">-- We have an &#39;a&#39; and something that needs an &#39;a&#39; to return a &#39;b&#39;</span>
  fmap fab      fra       <span class="fu">=</span> fab <span class="fu">.</span> fra           <span class="co">-- we can simplify this to composing fab and fra</span></code></pre></div>
<p>We are applying the function <strong>fab</strong> to the result of <strong>fra</strong>. It looks like <strong>fmap</strong> takes two functions are composes them.</p>
<p>Compose (.) is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span>  (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</code></pre></div>
<p>or in our case:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span>  (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> b</code></pre></div>
<p>And we can implement the Functor for (r -&gt;) with compose alone:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (r <span class="ot">-&gt;</span> ) <span class="kw">where</span>
  fmap <span class="fu">=</span> (<span class="fu">.</span>)</code></pre></div>
<p>This gives us the intuition that fmap over functions is just composition.</p>
<p>Let’s use it on an example:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">fmap (<span class="fu">*</span><span class="dv">3</span>) (<span class="fu">+</span><span class="dv">100</span>) <span class="dv">1</span></code></pre></div>
<p>What is the result of the above?</p>
<p>Let’s use function composition to get the answer:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">fmap (<span class="fu">*</span><span class="dv">3</span>) (<span class="fu">+</span><span class="dv">100</span>) <span class="dv">1</span>
<span class="fu">=</span> (\r <span class="ot">-&gt;</span> (r <span class="fu">+</span> <span class="dv">100</span>) <span class="fu">*</span> <span class="dv">3</span>) <span class="co">-- expanding Functor</span>
<span class="fu">=</span> ((<span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span>) <span class="fu">*</span> <span class="dv">3</span>)       <span class="co">-- substituting 1 for &#39;r&#39;</span>
<span class="fu">=</span> <span class="dv">303</span></code></pre></div>
<h2 id="applicative">Applicative</h2>
<p>The Applicative typeclass is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
<span class="ot">  pure  ::</span> a <span class="ot">-&gt;</span> f a
<span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>The <strong>pure</strong> function lifts some value <strong>a</strong> into the <strong>Applicative</strong>, <strong>f</strong>. Also note that <strong>f</strong> is also a <strong>Functor</strong>. The <strong>&lt;$&gt;</strong> function sequences a function from (<strong>a -&gt; b</strong>) within an <strong>Applicative</strong> context, with the value of <strong>a</strong> supplied in another <strong>Applicative</strong> context to produce the result <strong>b</strong> in a third <strong>Applicative</strong> context.</p>
<p>Note the similarities between <strong>&lt;$&gt;</strong> and &lt;*&gt;:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">fmap,<span class="ot"> (&lt;$&gt;) ::</span>   (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="ot">(&lt;*&gt;)       ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>The only difference is that with &lt;*&gt; the function is within a context <strong>f</strong>.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">f (a <span class="ot">-&gt;</span> b)  <span class="co">-- f&#39;, a function within a context &#39;f&#39;, requires an &#39;a&#39; to create a &#39;b&#39;</span>
f a         <span class="co">-- Applicative Functor with an &#39;a&#39;</span>
f (f&#39;(a))   <span class="co">-- apply f&#39; to the &#39;a&#39; within &#39;f&#39;</span>
f b         <span class="co">-- the final result of a &#39;b&#39;</span></code></pre></div>
<p>Let’s take a look at the <strong>Applicative</strong> instance for <strong>Maybe</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span>
<span class="co">-- pure  :: a -&gt; f a</span>
  pure <span class="fu">=</span> <span class="dt">Just</span>
<span class="co">-- (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span>
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Just</span> f) other <span class="fu">=</span> fmap f other
  (<span class="fu">&lt;*&gt;</span>) <span class="dt">Nothing</span>  _     <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>For <strong>Maybe</strong>, <strong>pure</strong> simply creates an instance of <strong>Just</strong> with the supplied value. With &lt;*&gt; the function <strong>f</strong> is within a <strong>Maybe</strong> context. If the context is a <strong>Just</strong>, the function is applied to the other <strong>Maybe</strong> context using <strong>fmap</strong> from the <strong>Functor</strong> typeclass. If the context is a <strong>Nothing</strong>, no function application takes place and a <strong>Nothing</strong> is returned.</p>
<p>How do we define an <strong>Applicative</strong> instance for (r -&gt;) ?</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> (r <span class="ot">-&gt;</span> ) <span class="kw">where</span>
<span class="co">-- pure  :: a -&gt; f a</span>
  pure a <span class="fu">=</span> \r <span class="ot">-&gt;</span> a
<span class="co">-- (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span>
  (<span class="fu">&lt;*&gt;</span>) f g <span class="fu">=</span> \r <span class="ot">-&gt;</span> f r (g r) <span class="co">-- f is (\r -&gt; (a -&gt; b)), g is (\r -&gt; a)</span></code></pre></div>
<p>Apply the input <strong>r</strong> to <strong>g</strong> to return an <strong>a</strong> and also apply <strong>r</strong> to <strong>f</strong>, to return the function from (<strong>a -&gt; b</strong>). Then apply the function (<strong>a -&gt; b</strong>) to <strong>a</strong> to return a <strong>b</strong>.</p>
<p>Let’s use it on an example:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> (<span class="fu">+</span><span class="dv">3</span>) <span class="fu">&lt;*&gt;</span> (<span class="fu">*</span><span class="dv">100</span>) <span class="dv">5</span>
<span class="fu">=</span> (<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> (\r <span class="ot">-&gt;</span> r <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">&lt;*&gt;</span> (\r <span class="ot">-&gt;</span> r <span class="fu">*</span> <span class="dv">100</span>) <span class="dv">5</span> <span class="co">-- expanding Applicative</span>
<span class="fu">=</span> (<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="fu">*</span> <span class="dv">100</span>)                   <span class="co">-- substituting 5 for &#39;r&#39;</span>
<span class="fu">=</span> <span class="dv">8</span> <span class="fu">+</span> <span class="dv">500</span>                                     <span class="co">-- combining with (+)</span>
<span class="fu">=</span> <span class="dv">508</span></code></pre></div>
<p>You may also notice that this gives you the same answer as <strong>liftA2</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">liftA2 ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c
liftA2 (<span class="fu">+</span>) (<span class="fu">+</span><span class="dv">3</span>) (<span class="fu">*</span><span class="dv">100</span>) <span class="dv">5</span>
<span class="fu">=</span> <span class="dv">508</span></code></pre></div>
<p>The intuition here is that, we can supply the input to each <strong>Applicative</strong> context, and then combine them with a function either through <strong>&lt;$&gt;</strong> or <strong>liftA2</strong>.</p>
<p>And here’s one more example which may seem a little hairy:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(\x y z <span class="ot">-&gt;</span> [x,y,z]) <span class="fu">&lt;$&gt;</span> (<span class="fu">+</span><span class="dv">3</span>) <span class="fu">&lt;*&gt;</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">&lt;*&gt;</span> (<span class="fu">/</span><span class="dv">2</span>) <span class="fu">$</span> <span class="dv">5</span>
<span class="fu">=</span> (\x y z <span class="ot">-&gt;</span> [x,y,z]) <span class="fu">&lt;$&gt;</span> (\r <span class="ot">-&gt;</span> r <span class="fu">+</span><span class="dv">3</span>) <span class="fu">&lt;*&gt;</span> (\r <span class="ot">-&gt;</span> <span class="fu">*</span><span class="dv">2</span>) <span class="fu">&lt;*&gt;</span> (\r <span class="ot">-&gt;</span> <span class="fu">/</span><span class="dv">2</span>) <span class="fu">$</span> <span class="dv">5</span> <span class="co">-- expand Applicative</span>
<span class="fu">=</span> (\x y z <span class="ot">-&gt;</span> [x,y,z]) <span class="fu">&lt;$&gt;</span> (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">&lt;*&gt;</span> (<span class="dv">5</span> <span class="fu">*</span> <span class="dv">2</span>) <span class="fu">&lt;*&gt;</span> (<span class="dv">5</span> <span class="fu">/</span> <span class="dv">2</span>)                <span class="co">-- replace &#39;r&#39; with 5</span>
<span class="fu">=</span> (\x y z <span class="ot">-&gt;</span> [x,y,z]) <span class="fu">&lt;$&gt;</span> (<span class="fl">8.0</span>) <span class="fu">&lt;*&gt;</span> (<span class="fl">10.0</span>) <span class="fu">&lt;*&gt;</span> (<span class="fl">2.5</span>)
<span class="fu">=</span> [<span class="fl">8.0</span>, <span class="fl">10.0</span>, <span class="fl">2.5</span>]                                                       <span class="co">-- combine with (\x y z -&gt; [x,y,z])</span></code></pre></div>
<p>The same result can be achieved with <strong>liftA3</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">liftA3 (\x y z <span class="ot">-&gt;</span> [x,y,z]) (<span class="fu">+</span><span class="dv">3</span>) (<span class="fu">*</span><span class="dv">2</span>) (<span class="fu">/</span><span class="dv">2</span>) <span class="fu">$</span> <span class="dv">5</span>
<span class="fu">=</span> [<span class="fl">8.0</span>,<span class="fl">10.0</span>,<span class="fl">2.5</span>]</code></pre></div>
<h2 id="monad">Monad</h2>
<p>The <strong>Monad</strong> typeclass is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">  (&gt;&gt;=)  ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code></pre></div>
<p>The <strong>return</strong> function lifts a value <strong>a</strong> into the <strong>Monad</strong> <strong>m</strong>. Bind or (<strong>&gt;&gt;=</strong>) sequentially composes two actions, passing any value produced by the first as an argument to the second.</p>
<p>Let’s take a look at the <strong>Monad</strong> instance for <strong>Maybe</strong> :</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span>  <span class="dt">Monad</span> <span class="dt">Maybe</span>  <span class="kw">where</span>
<span class="co">-- (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</span>
  (<span class="dt">Just</span> a) <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> k a
  <span class="dt">Nothing</span>  <span class="fu">&gt;&gt;=</span> _  <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>If the first <strong>Maybe</strong> context is a <strong>Just</strong>, then apply the function <strong>k</strong> to produce a new <strong>Maybe</strong> context. If the first <strong>Maybe</strong> context is a <strong>Nothing</strong>, then return <strong>Nothing</strong>.</p>
<p>How do we define an <strong>Monad</strong> instance for (r -&gt;) ?</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span>  <span class="dt">Monad</span> (r <span class="ot">-&gt;</span>)  <span class="kw">where</span>
<span class="co">-- return :: a -&gt; m a</span>
    return <span class="fu">=</span> pure
<span class="co">-- (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</span>
  f <span class="fu">&gt;&gt;=</span> g <span class="fu">=</span> \r <span class="ot">-&gt;</span>  g (f r) r <span class="co">-- f is (\r -&gt; a), g is (\a -&gt; \r -&gt; b)</span></code></pre></div>
<p>The <strong>return</strong> function is derived from <strong>pure</strong>, since all <strong>Monads</strong> are also <strong>Applicatives</strong>. The bind function (<strong>&gt;&gt;=</strong>) first applies the input <strong>r</strong> to <strong>f</strong> to give an <strong>a</strong>. It then applies the <strong>a</strong> to <strong>g</strong> to return a function from (<strong>r -&gt; b</strong>). The input <strong>r</strong> is then applied to this function to return the final <strong>b</strong>.</p>
<p>The intuition here is that we supply the input resource <strong>r</strong> to <strong>f</strong> and use that result as the first input to <strong>g</strong> followed by <strong>r</strong> as the second input.</p>
<p>Let’s use it in an example:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(<span class="fu">+</span><span class="dv">3</span>) <span class="fu">&gt;&gt;=</span> (<span class="fu">*</span>) <span class="fu">$</span> <span class="dv">5</span>
<span class="fu">=</span> (\r <span class="ot">-&gt;</span> r <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> \r <span class="ot">-&gt;</span> a <span class="fu">*</span> r) <span class="dv">5</span> <span class="co">-- expanding the Monad for &#39;r&#39;</span>
<span class="fu">=</span> (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> a <span class="fu">*</span> <span class="dv">5</span>)               <span class="co">-- replace &#39;r&#39; with 5</span>
<span class="fu">=</span> (<span class="dv">8</span>) <span class="fu">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> a <span class="fu">*</span> <span class="dv">5</span>)
<span class="fu">=</span> (<span class="dv">8</span> <span class="fu">*</span> <span class="dv">5</span>)                                 <span class="co">-- replace &#39;a&#39; with 8</span>
<span class="fu">=</span> <span class="dv">40</span></code></pre></div>
<p>or simply:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(<span class="fu">+</span><span class="dv">3</span>) <span class="fu">&gt;&gt;=</span> (<span class="fu">*</span>) <span class="fu">$</span> <span class="dv">5</span>
<span class="fu">=</span> ((<span class="dv">5</span><span class="fu">+</span><span class="dv">3</span>) <span class="fu">*</span> <span class="dv">5</span>)
<span class="fu">=</span> (<span class="dv">8</span> <span class="fu">*</span> <span class="dv">5</span>)
<span class="fu">=</span> <span class="dv">40</span></code></pre></div>
<p>We can also use the do syntax to solve the above:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">let</span> z1 <span class="fu">=</span> <span class="kw">do</span>
           x <span class="ot">&lt;-</span> (<span class="fu">+</span><span class="dv">3</span>)
           (x <span class="fu">*</span>)
z1 <span class="dv">5</span>
<span class="fu">=</span> <span class="dv">40</span></code></pre></div>
<h3 id="join">Join</h3>
<p>The <strong>join</strong> function flattens nested <strong>Monads</strong> and is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">join ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m (m a) <span class="ot">-&gt;</span> m a
join x <span class="fu">=</span> x <span class="fu">&gt;&gt;=</span> id</code></pre></div>
<p>Given the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">join (<span class="fu">+</span>) <span class="dv">10</span></code></pre></div>
<p>armed with the what we know about <strong>Monads</strong>, what is its result?</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">join (<span class="fu">+</span>) <span class="dv">10</span>
<span class="co">-- m (m a) -&gt; m a</span>
<span class="fu">=</span> (\r <span class="ot">-&gt;</span> (\r <span class="ot">-&gt;</span> r <span class="fu">+</span> r)) <span class="dv">10</span> <span class="co">-- expanding the Monad for &#39;r&#39;</span>
<span class="fu">=</span> (<span class="dv">10</span> <span class="fu">+</span> <span class="dv">10</span>)                <span class="co">-- replacing &#39;r&#39; with 10</span>
<span class="fu">=</span> <span class="dv">20</span></code></pre></div>
<p>We can also use the do syntax to solve the above:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">let</span> z2 <span class="fu">=</span> <span class="kw">do</span>
           x <span class="ot">&lt;-</span> (<span class="fu">+</span>)
           x
z2 <span class="dv">10</span>
<span class="fu">=</span> <span class="dv">20</span></code></pre></div>]]></description>
    <pubDate>Mon, 05 Mar 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-03-05-functor-applicative-and-monad-instances-for-reader.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>How to Run Specific Tests through Stack with Tasty in Haskell</title>
    <link>http://blog.ssanj.net/posts/2018-02-01-how-to-run-specific-tests-through-stack-with-tasy-in-haskell.html</link>
    <description><![CDATA[<p>Something I’ve become accustomed to while coding in Scala is being able to run a <a href="https://sanj.ink/posts/2015-08-02-run-a-test-method-of-a-test-class-from-sbt.html">subset of tests</a> through SBT. And while the same functionality is possible through <a href="https://hackage.haskell.org/package/tasty">Tasty</a>, I found it a little difficult to use through Stack.</p>
<p>Now stack allows you to send through parameters to your testing framework with the following options:</p>
<pre class="terminal scrollx"><code>--ta,--test-arguments TEST_ARGS Arguments passed in to the test suite program</code></pre>
<p>So given a full test suite of:</p>
<pre class="terminal scrollx"><code>  RM
    exits from home screen:       OK
    handles invalid query syntax: OK
    handle valid query:           OK
    handle invalid index:         OK
    handle invalid action:        OK
    go home from search:          OK
    quit from search:             OK
    search without results:       OK</code></pre>
<p>Using plain Tasty, you can use the -p argument to run tests that match a pattern:</p>
<pre class="terminal scrollx"><code>-p,--pattern ARG         Select only tests that match pattern</code></pre>
<p>Combining the two options, I can choose to run only the <em>quit from search</em> test with:</p>
<pre class="terminal scrollx"><code>stack test --ta &#39;-p &quot;quit from search&quot;&#39;</code></pre>
<p>which results in running only that specific test:</p>
<pre class="terminal scrollx"><code>  RM
    quit from search: OK

All 1 tests passed (0.00s)</code></pre>
<p>As long as the string you pass to Tasty is specific, you can target tests at different levels (TestGroup, TestCase etc).</p>
<p>For example to only target the <em>CommandParser</em> test group I could use:</p>
<pre class="terminal scrollx"><code>stack test --ta &#39;-p &quot;CommandParser&quot;&#39;</code></pre>
<p>which results in running all the tests with the the <em>CommandParser</em> test group:</p>
<pre class="terminal scrollx"><code>  CommandParser
    matchValue parser should match one of *?^:                  OK
    matchValue parser should not match other chars:             OK
      +++ OK, passed 100 tests.
    matchType parser should match format: &quot;&gt; [*?^]&quot;:            OK
    query parser should parse a valid query with matches:       OK
    query parser should parse a valid query with only commands: OK
    query parser should parse all valid queries:                OK
      +++ OK, passed 100 tests.

All 6 tests passed (0.00s)</code></pre>
<p>And to target a specific test case within a Test Group I could use the</p>
<blockquote>
<p>testGroupName/testName</p>
</blockquote>
<p>format.</p>
<p>For example to run the <em>matchValue parser should not match other chars</em> test within the <em>CommandParser</em> test group, I could use:</p>
<pre class="terminal scrollx"><code>stack test --ta &#39;-p &quot;CommandParser/matchValue parser should not match other chars&quot;&#39;</code></pre>
<p>which results in:</p>
<pre class="terminal scrollx"><code>  CommandParser
    matchValue parser should not match other chars: OK
      +++ OK, passed 100 tests.

All 1 tests passed (0.01s)</code></pre>
<p>While this great, the version of Tasty I’m using (<a href="https://hackage.haskell.org/package/tasty-0.11.0.3">0.11.3</a>) has support for additional patterns:</p>
<blockquote>
<p>An optional prefixed bang ! negates the pattern.</p>
</blockquote>
<blockquote>
<p>If the pattern ends with a slash, it is removed for the purpose of the following description, but it would only find a match with a test group. In other words, foo/ will match a group called foo and any tests underneath it, but will not match a regular test foo.</p>
</blockquote>
<blockquote>
<p>If the pattern does not contain a slash /, the framework checks for a match against any single component of the path. Otherwise, the pattern is treated as a glob, where:</p>
</blockquote>
<blockquote>
<p>The wildcard * matches anything within a single path component (i.e. foo but not foo/bar).</p>
</blockquote>
<blockquote>
<p>Two wildcards ** matches anything (i.e. foo and foo/bar).</p>
</blockquote>
<blockquote>
<p>Anything else matches exactly that text in the path (i.e. foo would only match a component of the test path called foo (or a substring of that form).</p>
</blockquote>
<blockquote>
<p>For example, group/*1 matches group/test1 but not group/subgroup/test1, whereas both examples would be matched by group/**1. A leading slash matches the beginning of the test path; for example, /test* matches test1 but not group/test1.</p>
</blockquote>
<p>Newer versions of Tasty such as <a href="https://hackage.haskell.org/package/tasty-1.0">1.0</a> onward support even more advanced syntax.</p>
<p>Now that’s pretty neat!</p>]]></description>
    <pubDate>Thu, 01 Feb 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-02-01-how-to-run-specific-tests-through-stack-with-tasy-in-haskell.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Stacking the ReaderT WriterT Monad Transformer Stack in Haskell</title>
    <link>http://blog.ssanj.net/posts/2018-01-12-stacking-the-readert-writert-monad-transformer-stack-in-haskell.html</link>
    <description><![CDATA[<p>Stacking Monads can be somewhat confusing to get your head around. While looking around for a decent example, I came across this <a href="https://gist.github.com/Decoherence/39a4c34685d86a334b63">Gist</a> by <a href="https://github.com/Decoherence">Decoherence</a> on how to combine a <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control-Monad-Trans-Reader.html#ReaderT">ReaderT</a> with a <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control-Monad-Trans-Writer-Lazy.html#WriterT">WriterT</a> over some Monad.</p>
<p>I needed to use this stack as I was working with the IO Monad and needed some way to capture the outcomes of a computation (via a Writer) and also needed to supply the initial inputs (via a Reader).</p>
<p>While <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html">Reader</a> and <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html">Writer</a> Monads on their own seem easy to use, it can be somewhat daunting to try and figure out how to combine the transformer variations of these Monads over some other Monad.</p>
<div class="figure">
<img src="https://scalerablog.files.wordpress.com/2015/10/bdu68sacyaafkkr.jpg" alt="Say Monad one more time" />
<p class="caption">Say Monad one more time</p>
</div>
<p>I’m documenting my findings on how to use this stack here for anyone who might be also struggling to figure out how all this stuff hangs together. It is also for my future-self who might need a quick refresher.</p>
<h1 id="reader-and-readert">Reader and ReaderT</h1>
<p>Let’s start by looking at the type signature for the Reader Monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">r <span class="ot">-&gt;</span> a</code></pre></div>
<p>The Reader Monad when given some resource, <strong>r</strong> from the environment will return a result of <strong>a</strong>.</p>
<p>The type variables defined are as follows:</p>
<ul>
<li>r = resource from the environment</li>
<li>a = value returned</li>
</ul>
<p>Next lets have a look at the type signature for a ReaderT Monad Transformer (MT):</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a <span class="fu">=</span> <span class="dt">ReaderT</span> {<span class="ot"> runReaderT ::</span> r <span class="ot">-&gt;</span> m a }</code></pre></div>
<p>This is less clear than the definition of the Reader Monad. As we’ll see below they are essentially very similar.</p>
<p>The type variables defined are as follows:</p>
<ul>
<li>r = resource from the environment</li>
<li>m = the resulting Monad</li>
<li>a = value returned in the Monad</li>
</ul>
<p>The ReaderT MT has one extra type variable <strong>m</strong> which is a Monad. If we examine the ReaderT constructor we can see that it encapsulates a type very similar to that of the Reader Monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">r <span class="ot">-&gt;</span> m a <span class="co">-- ReaderT MT</span>
r <span class="ot">-&gt;</span>   a <span class="co">-- Reader Monad</span></code></pre></div>
<p>The ReaderT MT is simply a Reader Monad whose result is returned within another Monad. More on that later. Hopefully the connection between the Reader Monad and the Reader MT is clearer.</p>
<p>When we see a ReaderT r m a we can mentally substitute it with a function of the type:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">r <span class="ot">-&gt;</span> m a</code></pre></div>
<p>And when we see a function of the type <code>r -&gt; m a</code> we can mentally substitute it with:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">ReaderT</span> r m a</code></pre></div>
<p>Depending on the situation it might be easier to think in one of the above versions of the ReaderT MT.</p>
<p>Given a ReaderT r m a we can unwrap its value via the <em>runReaderT</em> method:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">runReaderT ::</span> <span class="dt">ReaderT</span> r m a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> m a</code></pre></div>
<p>Also given a simple Reader Monad (<code>r -&gt; a</code>) we can lift it into a ReaderT MT with the <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#v:reader"><em>reader</em></a> or the <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#v:asks"><em>asks</em></a> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">reader,<span class="ot">asks ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a</code></pre></div>
<p>Also note that ReaderT r m is a Monad if <strong>m</strong> is a Monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ReaderT</span> r m)</code></pre></div>
<p>This is important to know when using <em>do</em> notation with the ReaderT MT as each bind operation will result in a ReaderT r m and not a ReaderT:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">someFunc ::</span> <span class="dt">ReaderT</span> r m a
someFunc <span class="fu">=</span> <span class="kw">do</span>
    r <span class="ot">&lt;-</span> ask
    return a <span class="co">-- this will be returned into ReaderT r m</span></code></pre></div>
<p>If you need to wrap a value within a ReaderT MT use:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">ReaderT</span> \r <span class="ot">-&gt;</span> <span class="co">-- your value of (m a)</span></code></pre></div>
<p>This might all seem very confusing at the moment. These are different ways of lifting values into the transformer stack at different points. Once you start using the ReaderT MT this will become clearer.</p>
<p>Some other useful functions that work with the ReaderT MT are:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#v:ask"><em>ask</em></a> - to retrieve the supplied resource</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> r m r</code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#v:local"><em>local</em></a> - to map a function on the resource <em>before</em> using it:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">local ::</span> (r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a</code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#v:mapReaderT"><em>mapReaderT</em></a> - to change all components of the ReaderT MT except the input type (the inner Monad and result type):</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">mapReaderT ::</span> (m a <span class="ot">-&gt;</span> n b) <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r n b</code></pre></div>
<h1 id="writer-and-writert">Writer and WriterT</h1>
<p>As we’ve not looked at the definitions of the Writer Monad and the WriterT MT let’s do that now. The Writer Monad is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(a, w)</code></pre></div>
<p>The type variables defined are:</p>
<ul>
<li>a = return value</li>
<li>w = log value (which has to be an <a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html">Monoid</a>)</li>
</ul>
<p>The Writer Monad will return a pair of values; a result <strong>a</strong> along with an accumulated log <strong>w</strong>.</p>
<p>The WriterT MT is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">WriterT</span> w m a <span class="fu">=</span> <span class="dt">WriterT</span> {<span class="ot"> runWriterT ::</span> m (a, w) }</code></pre></div>
<p>where the type variables defined are:</p>
<ul>
<li>a = return value</li>
<li>m = the resulting Monad</li>
<li>w = log value (which has to be an Monoid)</li>
</ul>
<p>Both <strong>a</strong> and <strong>w</strong> are returned as a pair within the Monad <strong>m</strong>.</p>
<p>The WriterT constructor encapsulates:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">m (a, w)</code></pre></div>
<p>It’s basically a Writer Monad within another Monad m:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">  (a, w) <span class="co">-- Writer Monad</span>
m (a, w) <span class="co">-- WriterT MT</span></code></pre></div>
<p>Some other useful functions that work with the WriterT MT are:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html#v:runWriterT"><em>runWriterT</em></a> - to unwrap the value of a WriterT MT and return the result and the log:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">runWriterT ::</span> <span class="dt">WriterT</span> w m a <span class="ot">-&gt;</span> m (a, w)</code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html#v:execWriterT"><em>execWriterT</em></a> - to unwrap the value of a WriterT MT and return only the log:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">execWriterT ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">WriterT</span> w m a <span class="ot">-&gt;</span> m w</code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html#v:tell"><em>tell</em></a> - to write a log entry into the WriterT MT:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">tell ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> w <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m ()</code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html#v:listen"><em>listen</em></a> - to change the result to include the log:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">listen ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">WriterT</span> w m a <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m (a, w)</code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html#v:pass"><em>pass</em></a> - to run a function on the log to update it:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">pass ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">WriterT</span> w m (a, w <span class="ot">-&gt;</span> w) <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m a</code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Lazy.html#v:mapWriter"><em>mapWriterT</em></a> - to change all components of the WriterT MT (the inner Monad, result and log type):</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">mapWriterT ::</span> (m (a, w) <span class="ot">-&gt;</span> n (b, w’)) <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m a <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w’ n b</code></pre></div>
<h1 id="monadtrans">MonadTrans</h1>
<p>Let’s also have a look at the <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> typeclass. It defines one function called <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html#v:lift"><em>lift</em></a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">lift ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</code></pre></div>
<p>that lifts a Monad into a MT. We can use this function to insert a Monad into a given transformer stack.</p>
<h1 id="a-readert-writert-example">A ReaderT WriterT example</h1>
<p>Phew! We’ve just had a whirlwind tour of some typeclasses and related functions. Now let’s have a look at an example of using a ReaderT/WriterT transformer stack.</p>
<p>Say we had some configuration about an external service, like its <em>host</em> and <em>port</em>. We might use a Reader Monad to supply that configuration to the program.</p>
<p>Let’s start by defining a type alias to a Map of String keys and values:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Map.Lazy</span> <span class="kw">as</span> <span class="dt">M</span>

<span class="kw">type</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">String</span> <span class="dt">String</span></code></pre></div>
<p>Let’s also define a <em>serverConfig</em> function to return our populated configuration from a list of key-value pairs:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">serverConfig ::</span> <span class="dt">Config</span>
serverConfig <span class="fu">=</span> M.fromList [(<span class="st">&quot;host&quot;</span>, <span class="st">&quot;localhost&quot;</span>), (<span class="st">&quot;port&quot;</span>, <span class="st">&quot;7654&quot;</span>)]</code></pre></div>
<p>Let’s definite a function to read the host:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">getHost ::</span> <span class="dt">Reader</span> <span class="dt">Config</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)</code></pre></div>
<p>Given a <em>Config</em> this function will return the host name in a <em>Just</em> if present, or a <em>Nothing</em> if not.</p>
<p>It would could be implemented as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">getHost ::</span> <span class="dt">Reader</span> <span class="dt">Config</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)
getHost <span class="fu">=</span> <span class="kw">do</span>
  config <span class="ot">&lt;-</span> ask
  return (Map.lookup <span class="st">&quot;host&quot;</span> config)</code></pre></div>
<p>First, the <em>getHost</em> function requests the Config instance from the environment using the <em>ask</em> function. It then looks up the “host” key from that config. Finally it lifts the Maybe value returned from the <a href="http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Lazy.html#v:lookup"><em>lookup</em></a> function into the Reader Monad using the <em>return</em> function.</p>
<p>Let’s define a function to read the port:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">getPort ::</span> <span class="dt">Reader</span> <span class="dt">Config</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</code></pre></div>
<p>It would could be implemented as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">getPort ::</span> <span class="dt">Reader</span> <span class="dt">Config</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)
getPort <span class="fu">=</span> <span class="kw">do</span>
  config <span class="ot">&lt;-</span> ask
  return (Map.lookup <span class="st">&quot;port&quot;</span> config <span class="fu">&gt;&gt;=</span> readMaybe)</code></pre></div>
<p>This function is similar to <em>getHost</em> with the additional bind (&gt;&gt;=) operation to join together the value read from <em>lookup</em> with <a href="https://hackage.haskell.org/package/base-4.8.1.0/docs/Text-Read.html#v:readMaybe"><em>readMaybe</em></a>. readMaybe tries to parse a String into a value of type Int in this case. If it successfully parses the value it returns a (<em>Just Int</em>) or if it fails it returns a <em>Nothing</em>. readMaybe is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">readMaybe ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</code></pre></div>
<p>Also notice that we used a Reader Monad as opposed to a ReaderT MT to read both the host and port. Since the Reader Monad and the ReaderT MT are very similar we can easily convert between them. Why didn’t we use a ReaderT MT directly to read the configuration? We could have, but the ReaderT MT requires an inner Monad m:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">ReaderT</span> r m a</code></pre></div>
<p>and we haven’t decided on what <strong>m</strong> is at the moment. I’ll demonstrate how we could have directly used a ReaderT MT to implement <em>getHost</em> and <em>getPort</em> <a href="https://sanj.ink/posts/2018-01-12-stacking-the-readert-writert-monad-transformer-stack-in-haskell.html#using-readert-instead-of-reader">later</a> on.</p>
<p>Now that we’ve written functions to read the host and port, lets go ahead and use those values in a ReaderT MT along with a WriterT MT to log out the values we received from the configuration:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">getConfig ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()</code></pre></div>
<p>Given a Config type as an input, the result returned will be in a WriterT MT with a log type of String with an inner Monad of IO and a value of unit () returned within IO. That sounds more complicated than it really is.</p>
<p>It’s implemented as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">getConfig ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()
getConfig <span class="fu">=</span> <span class="kw">do</span>
  hostM <span class="ot">&lt;-</span> fromReader getHost
  portM <span class="ot">&lt;-</span> fromReader getPort
  <span class="kw">let</span> host <span class="fu">=</span> maybe <span class="st">&quot;-&quot;</span> id hostM
      port <span class="fu">=</span> maybe <span class="st">&quot;-&quot;</span> show portM
  _ <span class="ot">&lt;-</span> log <span class="st">&quot;\nConfig&quot;</span>
  _ <span class="ot">&lt;-</span> log <span class="st">&quot;\n======&quot;</span>
  _ <span class="ot">&lt;-</span> log (printf <span class="st">&quot;\nhost: %s&quot;</span> host)
  _ <span class="ot">&lt;-</span> log (printf <span class="st">&quot;\nport: %s&quot;</span> port)
  return ()</code></pre></div>
<p>Let’s delve into the implementation of <em>getConfig</em>. The first two lines read the host and port into Maybe values from the configuration:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">  hostM <span class="ot">&lt;-</span> fromReader getHost
  portM <span class="ot">&lt;-</span> fromReader getPort</code></pre></div>
<p>The next two lines covert the Maybe values for host and port into their String equivalents:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">  <span class="kw">let</span> host <span class="fu">=</span> maybe <span class="st">&quot;-&quot;</span> id hostM
      port <span class="fu">=</span> maybe <span class="st">&quot;-&quot;</span> show portM</code></pre></div>
<p>The next four lines write String values to the log in order:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">  _ <span class="ot">&lt;-</span> log <span class="st">&quot;\nConfig&quot;</span>
  _ <span class="ot">&lt;-</span> log <span class="st">&quot;\n======&quot;</span>
  _ <span class="ot">&lt;-</span> log (printf <span class="st">&quot;\nhost: %s&quot;</span> host)
  _ <span class="ot">&lt;-</span> log (printf <span class="st">&quot;\nport: %s&quot;</span> port)</code></pre></div>
<p>and the final line returns a Unit result into the ReaderT r m Monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">return ()</code></pre></div>
<p>which in this case is the ReaderT (WriterT String IO) Monad.</p>
<p>Let’s look at the type definition of the <em>fromReader</em> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">fromReader ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a</code></pre></div>
<p><em>fromReader</em> converts a Reader Monad to a ReaderT MT. It is implemented as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">fromReader ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a
fromReader <span class="fu">=</span> reader <span class="fu">.</span> runReader</code></pre></div>
<p>The <em>runReader</em> function is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">runReader ::</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a</code></pre></div>
<p>and unwraps the Reader Monad to a function (<code>r -&gt; a</code>). The <em>reader</em> function (as defined previously) lifts a function from (<code>r -&gt; a</code>) into the ReaderT MT. This seems like unnecessary work and ideally there should be an in-built function that does this for us.</p>
<p>Next let’s have a look at the <em>log</em> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">log<span class="ot"> ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadTrans</span> t, <span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> w <span class="ot">-&gt;</span> t (<span class="dt">WriterT</span> w m) ()
log <span class="fu">=</span> lift <span class="fu">.</span> tell</code></pre></div>
<p>From the type definition of <em>tell</em>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">tell ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> w <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m ()</code></pre></div>
<p>we can see that we almost get the result we want:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">w <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m ()</code></pre></div>
<p>We just need to lift the WriterT w m Monad into a Monad Transformer <strong>t</strong> and we can do that with the <em>lift</em> defined previously:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">lift ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</code></pre></div>
<p>which gives us:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">w <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m () <span class="co">-- tell</span>

m a <span class="ot">-&gt;</span> t m a <span class="co">-- lift</span>
<span class="co">-- replacing m with (WriterT w m)</span>
(<span class="dt">WriterT</span> w m) a <span class="ot">-&gt;</span> t (<span class="dt">WriterT</span> w m) a
<span class="co">-- replacing a with ()</span>
(<span class="dt">WriterT</span> w m) () <span class="ot">-&gt;</span> t (<span class="dt">WriterT</span> w m) ()

<span class="co">-- combining lift . tell</span>
w <span class="ot">-&gt;</span> t (<span class="dt">WriterT</span> w m) ()</code></pre></div>
<p>We can see that we are lifing some log <strong>w</strong> into a transformer stack <strong>t</strong> through the WriterT w m Monad.</p>
<p>We’ve come a long way and we’ve got everything setup as needed. The only thing left to do is run the transformer stack and reap our rewards. We can do that with the <em>readWriteConfig</em> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">readWriteConfig ::</span> <span class="dt">IO</span> ()
readWriteConfig <span class="fu">=</span> execWriterT (runReaderT getConfig serverConfig) <span class="fu">&gt;&gt;=</span> putStrLn</code></pre></div>
<p>When running the stack, it is run from outside-in. So given a <em>ReaderT (WriterT String m) a</em>, we:</p>
<ol style="list-style-type: decimal">
<li>Run the ReaderT MT:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">r <span class="ot">-&gt;</span> m a</code></pre></div>
<p>with runReaderT. This returns the result <strong>a</strong> in the inner Monad <strong>m</strong> which is a WriterT String m. Substituting the IO Monad for <strong>m</strong> and Unit for <strong>a</strong> returns a WriterT String IO (). We don’t care about the result of <strong>a</strong> - only the log.</p>
<ol start="2" style="list-style-type: decimal">
<li>Run the WriterT MT:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">m (a, w)</code></pre></div>
<p>with execWriterT. This returns the log <strong>w</strong> in the inner Monad <strong>m</strong> which is an <strong>m w</strong>. Substituting the IO Monad for <strong>m</strong> and String for <strong>w</strong>, returns an IO String.</p>
<ol start="3" style="list-style-type: decimal">
<li>Binding through from IO String to <em>putStrLn</em> gives us an IO (). The final output of running the above is:</li>
</ol>
<pre class="terminal scrollx"><code>Config
======
host: localhost
port: 7654</code></pre>
<h2 id="using-readert-instead-of-reader">Using ReaderT instead of Reader</h2>
<p>I previously mentioned that we could have written the <em>getHost</em> and <em>getPort</em> functions with a ReaderT MT instead of a Reader Monad. Here’s how we’d do that:</p>
<p><em>getHost2</em></p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">getHost2 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> m (<span class="dt">Maybe</span> <span class="dt">String</span>)
getHost2 <span class="fu">=</span> <span class="co">-- same as getHost</span></code></pre></div>
<p>Notice that the only difference between <em>getHost</em> and <em>getHost2</em> is the addition of a new type variable <em>m</em> which is a Monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">getHost  ::</span>            <span class="dt">Reader</span>  <span class="dt">Config</span>   (<span class="dt">Maybe</span> <span class="dt">String</span>) <span class="co">-- Reader Monad</span>
<span class="ot">getHost2 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> m (<span class="dt">Maybe</span> <span class="dt">String</span>) <span class="co">-- ReaderT MT</span></code></pre></div>
<p>And since we are working with Monads in both cases, the implementation code remains unchanged! So just by changing the type definition of the <em>getConfig</em> method we can go from a Reader Monad to a ReaderT MT!</p>
<p><em>getPort2</em></p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">getPort2 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> m (<span class="dt">Maybe</span> <span class="dt">Int</span>)
getPort2 <span class="fu">=</span> <span class="co">-- same as getPort</span></code></pre></div>
<p><em>getConfig2</em></p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">getConfig2 ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()
getConfig2 <span class="fu">=</span> <span class="kw">do</span>
  hostM <span class="ot">&lt;-</span> getHost2 <span class="co">-- no need to call fromReader</span>
  portM <span class="ot">&lt;-</span> getPort2 <span class="co">-- no need to call fromReader</span>
  <span class="fu">...</span> <span class="co">-- same as getConfig</span></code></pre></div>
<p>We can see that this solution is a lot easier with less work to do. We just needed to add a Monad type constraint to the <em>getHost2</em> and <em>getPort2</em> functions. We also have no need for the <em>fromReader</em> function which is a bonus! We can also call the <em>readWriteConfig</em> function with <em>getConfig2</em> instead of <em>getConfig</em> and it all works:</p>
<p><em>readWriteConfig2</em></p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">readWriteConfig2 ::</span> <span class="dt">IO</span> ()
readWriteConfig2 <span class="fu">=</span> execWriterT (runReaderT getConfig2 serverConfig) <span class="fu">&gt;&gt;=</span> putStrLn</code></pre></div>
<p>The complete Solution</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Config</span> (readWriteConfig) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Text.Printf</span> (printf)
<span class="kw">import </span><span class="dt">Control.Monad.IO.Class</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Class</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Reader</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Writer.Lazy</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map.Lazy</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.List</span> (intercalate)
<span class="kw">import </span><span class="dt">Data.Functor.Identity</span> (<span class="dt">Identity</span>, runIdentity)
<span class="kw">import </span><span class="dt">Text.Read</span> (readMaybe)
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (log)

<span class="kw">type</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">String</span>

<span class="ot">serverConfig ::</span> <span class="dt">Config</span>
serverConfig <span class="fu">=</span> Map.fromList [(<span class="st">&quot;host&quot;</span>, <span class="st">&quot;localhost&quot;</span>), (<span class="st">&quot;port&quot;</span>, <span class="st">&quot;7654&quot;</span>)]

<span class="co">-- variation with Reader</span>

<span class="ot">getHost ::</span> <span class="dt">Reader</span> <span class="dt">Config</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)
getHost <span class="fu">=</span> <span class="kw">do</span>
  config <span class="ot">&lt;-</span> ask
  return (Map.lookup <span class="st">&quot;host&quot;</span> config)

<span class="ot">getPort ::</span> <span class="dt">Reader</span> <span class="dt">Config</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)
getPort <span class="fu">=</span> <span class="kw">do</span>
  config <span class="ot">&lt;-</span> ask
  return (Map.lookup <span class="st">&quot;port&quot;</span> config <span class="fu">&gt;&gt;=</span> readMaybe)

<span class="ot">fromReader ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a
fromReader <span class="fu">=</span> reader <span class="fu">.</span> runReader

log<span class="ot"> ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadTrans</span> t, <span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> w <span class="ot">-&gt;</span> t (<span class="dt">WriterT</span> w m) ()
log <span class="fu">=</span> lift <span class="fu">.</span> tell

<span class="ot">getConfig ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()
getConfig <span class="fu">=</span> <span class="kw">do</span>
  hostM <span class="ot">&lt;-</span> fromReader getHost
  portM <span class="ot">&lt;-</span> fromReader getPort
  <span class="kw">let</span> host <span class="fu">=</span> maybe <span class="st">&quot;-&quot;</span> id hostM
      port <span class="fu">=</span> maybe <span class="st">&quot;-&quot;</span> show portM
  _ <span class="ot">&lt;-</span> log <span class="st">&quot;\nConfig&quot;</span>
  _ <span class="ot">&lt;-</span> log <span class="st">&quot;\n======&quot;</span>
  _ <span class="ot">&lt;-</span> log (printf <span class="st">&quot;\nhost: %s&quot;</span> host)
  _ <span class="ot">&lt;-</span> log (printf <span class="st">&quot;\nport: %s&quot;</span> port)
  return ()

<span class="ot">readWriteConfig ::</span> <span class="dt">IO</span> ()
readWriteConfig <span class="fu">=</span> execWriterT (runReaderT getConfig serverConfig) <span class="fu">&gt;&gt;=</span> putStrLn

<span class="co">-- variation with ReaderT</span>

<span class="ot">getHost2 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> m (<span class="dt">Maybe</span> <span class="dt">String</span>)
getHost2 <span class="fu">=</span> <span class="kw">do</span>
  config <span class="ot">&lt;-</span> ask
  return (Map.lookup <span class="st">&quot;host&quot;</span> config)

<span class="ot">getPort2 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> m (<span class="dt">Maybe</span> <span class="dt">Int</span>)
getPort2 <span class="fu">=</span> <span class="kw">do</span>
  config <span class="ot">&lt;-</span> ask
  return (Map.lookup <span class="st">&quot;port&quot;</span> config <span class="fu">&gt;&gt;=</span> readMaybe)

<span class="ot">getConfig2 ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()
getConfig2 <span class="fu">=</span> <span class="kw">do</span>
  hostM <span class="ot">&lt;-</span> getHost2
  portM <span class="ot">&lt;-</span> getPort2
  <span class="kw">let</span> host <span class="fu">=</span> maybe <span class="st">&quot;-&quot;</span> id hostM
      port <span class="fu">=</span> maybe <span class="st">&quot;-&quot;</span> show portM
  _ <span class="ot">&lt;-</span> log <span class="st">&quot;\nConfig&quot;</span>
  _ <span class="ot">&lt;-</span> log <span class="st">&quot;\n======&quot;</span>
  _ <span class="ot">&lt;-</span> log (printf <span class="st">&quot;\nhost: %s&quot;</span> host)
  _ <span class="ot">&lt;-</span> log (printf <span class="st">&quot;\nport: %s&quot;</span> port)
  return ()

<span class="ot">readWriteConfig2 ::</span> <span class="dt">IO</span> ()
readWriteConfig2 <span class="fu">=</span> execWriterT (runReaderT getConfig2 serverConfig) <span class="fu">&gt;&gt;=</span> putStrLn</code></pre></div>
<h1 id="a-tale-of-at-least-two-monads">A Tale of At Least Two Monads</h1>
<p>A Monad is based on a type constructor:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)</code></pre></div>
<p>which has one type hole; it creates a type when given a type. A simple example is the Maybe Monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">Maybe</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre></div>
<p>While we can create a Monad instance for the Maybe type constructor, a specific Maybe instance like Maybe String can’t have one because it has no type holes:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"> <span class="dt">Maybe</span><span class="ot">         ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
(<span class="dt">Maybe</span> <span class="dt">String</span>)<span class="ot"> ::</span>      <span class="fu">*</span> <span class="co">-- no type hole</span></code></pre></div>
<p>Each Monad Transformer is composed of at least two Monads. If we take ReaderT MT as an example, we have its definition as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">ReaderT</span> r m a</code></pre></div>
<p>where ReaderT r m is a Monad and <strong>m</strong> is also a Monad. If you stack Monads, in the <strong>m</strong> type variable as with a WriterT for example:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">ReaderT</span> r (<span class="dt">WriterT</span> w m) a</code></pre></div>
<p>then ReaderT r (WriterT w m) is a Monad, WriterT w m is a Monad and <strong>m</strong> is a Monad. Talk about Monad overload!</p>
<div class="figure">
<img src="/images/readertwritert/mind-blown.gif" alt="Mind Blown" />
<p class="caption">Mind Blown</p>
</div>
<h1 id="decoherences-example">Decoherence’s Example</h1>
<p>What we’ve learned so far will help us understand the example from Decoherence I mentioned at the start of this post.</p>
<p>We start off by defining a data type for a Person:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> {<span class="ot"> name ::</span> <span class="dt">String</span> } <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>We then create a few specific Person instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">alex ::</span> <span class="dt">Person</span>
alex <span class="fu">=</span> <span class="dt">Person</span> <span class="st">&quot;Alex Fontaine&quot;</span>

<span class="ot">philip ::</span> <span class="dt">Person</span>
philip <span class="fu">=</span> <span class="dt">Person</span> <span class="st">&quot;Philip Carpenter&quot;</span>

<span class="ot">kim ::</span> <span class="dt">Person</span>
kim <span class="fu">=</span> <span class="dt">Person</span> <span class="st">&quot;Kim Lynch&quot;</span></code></pre></div>
<p>followed by a <em>peopleDb</em> function that returns a list of Person instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">peopleDb ::</span> [<span class="dt">Person</span>]
peopleDb <span class="fu">=</span> [alex, philip, kim]</code></pre></div>
<p>We then define a <em>process</em> function as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">process ::</span> <span class="dt">ReaderT</span> <span class="dt">Person</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()</code></pre></div>
<p>and a <em>process’</em> function as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">process&#39; ::</span> <span class="dt">ReaderT</span> <span class="dt">Person</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) <span class="dt">String</span></code></pre></div>
<p>The main difference between the above functions is that one returns a Unit return type and the other returns a String, respectively. Given that the ReaderT MT stack is almost the same as that in the previous example, it should be fairly easy to implement the above functions.</p>
<p>The <em>process</em> function is implemented as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">process ::</span> <span class="dt">ReaderT</span> <span class="dt">Person</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()
process <span class="fu">=</span> <span class="kw">do</span>
  _ <span class="ot">&lt;-</span> log <span class="fu">$</span> <span class="st">&quot;Looking up Person. &quot;</span>
  <span class="dt">Person</span> p <span class="ot">&lt;-</span> ask
  _ <span class="ot">&lt;-</span> log <span class="fu">$</span> printf <span class="st">&quot;Found person: %s. &quot;</span> p
  (liftIO <span class="fu">.</span> putStrLn) p</code></pre></div>
<p>We’ve not seen the <a href="https://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-IO-Class.html#v:liftIO"><em>liftIO</em></a> function before. It’s defined in the <a href="https://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-IO-Class.html">MonadIO</a> typeclass as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">liftIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>which just lifts a value from the IO Monad into another Monad. In the above example, <em>liftIO</em> will lift a Unit value from the IO Monad (<code>putStrLn p</code>), into the ReaderT Person (WriterT String IO) Monad.</p>
<p>The <em>process’</em> function is implemented as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">process&#39; ::</span> <span class="dt">ReaderT</span> <span class="dt">Person</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) <span class="dt">String</span>
process&#39; <span class="fu">=</span> <span class="kw">do</span>
  _ <span class="ot">&lt;-</span> log <span class="st">&quot;Looking up Person... &quot;</span>
  <span class="dt">Person</span> p <span class="ot">&lt;-</span> ask
  _ <span class="ot">&lt;-</span> log <span class="fu">$</span> printf <span class="st">&quot;Found person: %s. &quot;</span> p
  return p</code></pre></div>
<p>Let’s define a function to run the transformer stack:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">readWritePeople ::</span> <span class="dt">IO</span> ()
readWritePeople <span class="fu">=</span> <span class="kw">do</span></code></pre></div>
<p>Let’s start by running the <em>process</em> function with a Person instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">  result1 <span class="ot">&lt;-</span> runWriterT (runReaderT process alex) <span class="co">-- :: ((), String)</span>
  _ <span class="ot">&lt;-</span> (putStrLn <span class="fu">.</span> snd) result1</code></pre></div>
<p>Next let’s Run the <em>process’</em> function with a Person instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">  result2 <span class="ot">&lt;-</span> runWriterT (runReaderT process&#39; alex) <span class="co">-- :: (String, String)</span>
  _ <span class="ot">&lt;-</span> (putStrLn <span class="fu">.</span> fst) result2
  _ <span class="ot">&lt;-</span> (putStrLn <span class="fu">.</span> snd) result2</code></pre></div>
<h2 id="traversable">Traversable</h2>
<p>Before we look at the next invocation let’s look at the definition of the <a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:mapM"><em>mapM</em></a> function. The <em>mapM</em> function maps each element of a structure to a monadic action, evaluates these actions from left to right, and collects the results.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">mapM<span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</code></pre></div>
<p><em>t</em> is the <a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html">Traversable</a> typeclass which has a <a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#t:Functor">Functor</a> and <a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Foldable.html">Foldable</a> constraint:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> t, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> <span class="dt">Traversable</span> t <span class="kw">where</span></code></pre></div>
<p>There is also a similarly named <a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:mapM_">mapM_</a> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">mapM_<span class="ot"> ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>which just differs from <em>mapM</em> in its result:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">mapM<span class="ot">  ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)
mapM_<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m () <span class="co">-- only performs a side effect</span></code></pre></div>
<p>which it discards (returns Unit). This is useful when you don’t care about the return value and just want to perform some side effect.</p>
<p>Some other interesting functions on the Traversable typeclass are:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:traverse">traverse</a> - has the same definition as <em>mapM</em> where the container is an Applicative instead of a Monad:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">traverse ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)
mapM<span class="ot">     ::</span> <span class="dt">Monad</span>       m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:sequencea">sequenceA</a> - Evaluate each action in the structure from left to right, and and collect the results.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">sequenceA ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> t (f a) <span class="ot">-&gt;</span> f (t a)</code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:sequence">sequence</a> - Evaluate each monadic action in the structure from left to right, and collect the results.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">sequence<span class="ot">   ::</span> <span class="dt">Monad</span> m      <span class="ot">=&gt;</span> t (m a) <span class="ot">-&gt;</span> m (t a)</code></pre></div>
<p><em>sequence</em> and <em>sequenceA</em> are also Monadic and Applicative variants of each other:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">sequenceA  ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> t (f a) <span class="ot">-&gt;</span> f (t a)
sequence<span class="ot">   ::</span> <span class="dt">Monad</span> m       <span class="ot">=&gt;</span> t (m a) <span class="ot">-&gt;</span> m (t a)</code></pre></div>
<p>There are also <code>sequence_</code> and <code>sequenceA_</code> variants that discard the results of the action.</p>
<h2 id="running-readert-mt-with-multiple-inputs">Running ReaderT MT with Multiple Inputs</h2>
<p>Let’s use <em>mapM</em> to run our ReaderT stack with multiple input values:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">  result3 <span class="ot">&lt;-</span> runWriterT (mapM (runReaderT process&#39;) peopleDb) <span class="co">-- :: ([String], String)</span>

  <span class="kw">let</span> people <span class="fu">=</span> fst result3
      log    <span class="fu">=</span> snd result3

  _ <span class="ot">&lt;-</span> putStrLn <span class="st">&quot;\n\nReaderT values:\n&quot;</span>
  _ <span class="ot">&lt;-</span> mapM_ putStrLn people
  _ <span class="ot">&lt;-</span> putStrLn <span class="st">&quot;\nWriterT log:\n&quot;</span></code></pre></div>
<p>The <em>mapM</em> function is run as follows:</p>
<ol style="list-style-type: decimal">
<li>Each <em>runReaderT process’</em> is supplied a Person from the <em>peopleDb</em> function, which then returns a WriterT String IO String.</li>
<li>These results are then collected as a WriterT String IO [String].</li>
</ol>
<p>Here’s how we derive the result by replacing each type parameter with the actual types:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">mapM<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)
<span class="co">-- replacing a with Person:</span>
mapM    (<span class="dt">Person</span> <span class="ot">-&gt;</span> m b) t <span class="dt">Person</span>  <span class="ot">-&gt;</span> m (t b)
<span class="co">-- replacing t with []:</span>
mapM    (<span class="dt">Person</span> <span class="ot">-&gt;</span> m b) [<span class="dt">Person</span>]  <span class="ot">-&gt;</span> m [b]
<span class="co">-- replacing m (the Monad) with WriterT String IO</span>
(<span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> [<span class="dt">Person</span>] <span class="ot">-&gt;</span> <span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span> [b]
<span class="co">-- replacing b with String</span>
(<span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> [<span class="dt">Person</span>] <span class="ot">-&gt;</span> <span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span> [<span class="dt">String</span>]
<span class="co">-- which returns the this result:</span>
<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span> [<span class="dt">String</span>]</code></pre></div>
<p>The final output is:</p>
<pre class="terminal scrollx"><code>Alex Fontaine
Looking up Person. Found person: Alex Fontaine.
Alex Fontaine
Looking up Person... Found person: Alex Fontaine.


ReaderT values:

Alex Fontaine
Philip Carpenter
Kim Lynch

WriterT log:

Looking up Person... Found person: Alex Fontaine. Looking up Person... Found person: Philip Carpenter. Looking up Person... Found person: Kim Lynch.</code></pre>
<p>I hope this walk-through has made using Monad Transformers a little more approachable.</p>
<p>The code for these examples can be found <a href="https://github.com/ssanj/readert-writert">Github</a>.</p>
<p><strong>References</strong></p>
<ol style="list-style-type: decimal">
<li><a href="https://stackoverflow.com/questions/43840588/use-readert-maybe-or-maybet-reader#43840589">use-readert-maybe-or-maybet-reader</a></li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Monad_transformers">Monad_transformers</a></li>
<li><a href="https://stackoverflow.com/questions/11684321/how-to-play-with-control-monad-writer-in-haskell">how-to-play-with-control-monad-writer-in-haskell</a></li>
</ol>]]></description>
    <pubDate>Fri, 12 Jan 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-01-12-stacking-the-readert-writert-monad-transformer-stack-in-haskell.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>The Last Ten Months at a Startup</title>
    <link>http://blog.ssanj.net/posts/2018-01-06-the-last-ten-months-at-a-startup.html</link>
    <description><![CDATA[<p><em>I wrote this article back in 2015 when working for a Startup. I never ended up publishing it though. I thought I’d share my journey here for anyone that maybe experiencing the same highs and lows. Also reading through this made me realise that I did end up making a good decision even though it seemed foolhardy at the time. Everything worked out for the best. As always follow your intuition. Don’t be afraid to reject what you don’t want. Unfortunately I’ve restarted drinking coffee once moving to Melbourne</em>.</p>
<p>I have been on a roller coaster of many highs and lows. To quote Dickens:</p>
<blockquote>
<p>It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness</p>
</blockquote>
<p>Tomorrow is my last day of work at my current workplace. I don’t know what I’m going to do next, but I know it’s going to be something different. When someone asked me recently what I was going to do after I leave, I said “I was free falling”. That’s what it feels like not to have any immediate plans for your next paying gig.</p>
<p>My resignation had come as a bit of a shock. I didn’t have another job to go to, but I was still quitting. I had been restless for the last three months. It was starting to affect my life outside work. I was exhausted on the weekends. I couldn’t stop talking about how crap work was. I was sick a lot. Stressed. It was time to go. I had looked around for another job but had not found one yet.</p>
<p>Since resigning I feel so much better. I feel happy. Optimistic about the future. Life is good! :)</p>
<p>I know I made the right decision. As I said to my manager when I resigned:</p>
<blockquote>
<p>Once you get rid of what you don’t want, you make space for what you do want.</p>
</blockquote>
<p>He looked at me like I was crazy.</p>
<p>There were certainly many memorable moments. Here are some of them.</p>
<h2 id="working-with-friends">Working with friends</h2>
<p>I got this job by an off-hand comment from my friend <a href="https://twitter.com/andrewfnewman">Andrew</a>. I saw him on a crowded train wearing a t-shirt with a lambda symbol. This made perfect sense since Andrew and I are part of the <a href="http://www.meetup.com/Brisbane-Functional-Programming-Group">functional programming scene in Brisbane</a>. Since he was squashed between commuters and the door and I was a few seats down, I sent him a text that read “nice shirt!”. He noticed the text after he got out of the train but replied saying that there was a position going at his work and that I should apply.</p>
<p>A few weeks later I had the job. We spent three months working and bantering together. Unfortunately Andrew was sick of working there. He had been mistreated and lied to. And later after he left, he was unfairly blamed for everything that was wrong with our systems. In reality he had done the impossible and saved the company from the brink of disaster. Strangely no one seemed to care.</p>
<p>At the end of three months, just as I was coming out of my probation, he went to work at another company that appreciated his talents. It was sad to see him go but I was happy I got a chance to work with him.</p>
<p>Six months in, when we were on a hiring spree, my friend <a href="https://twitter.com/edwardsmatt">Matt</a> came on board. I had worked with him many jobs ago and he had always struck me as someone who I would love to work with again. It’s been great working with him for the last four months and I’m going to miss our daily banter and learning sessions and having someone like-minded to work with.</p>
<h2 id="the-chair-revolution">The chair revolution</h2>
<p>When I first started work, the chairs we had to sit on were appalling. Rumour had it that they were second-hand chairs that our CTO had acquired twenty years ago. They had been sent straight from his garage to our office. The chairs were in bad shape. I remember a couple of chairs falling apart and the CTO asking for volunteers to make a Frankenchair by combining the two broken chairs.</p>
<p>I had made several complaints about these chairs and they mostly fell on deaf ears, until we IPOed. Once we had more money the clamouring for chairs didn’t seem so nonsensical. My friend <a href="https://twitter.com/iamryandrake">Ryan</a> and I were championing this cause. Together with another work colleague Dave, we went to a furniture shop to choose three chairs to “trial”. We had been asked to trial three chairs before the company committed to buying more.</p>
<p>We cabbed it across town and spent a good half-an-hour trying different chairs until we decided on two models. We got an invoice sent to our manager and got back to the office very pleased with ourselves.</p>
<p>Nothing happened for a week. I then injured my back sitting on my crappy chair and refused to come back to work until we had proper chairs. Et voilà! The chairs we had ordered finally arrived on my return. Now we only had three good chairs, the ones Ryan, Dave and myself had chosen. Everyone else in the company was sitting on dilapidated chairs.</p>
<p>Ryan and myself had to campaign for another two weeks, constantly reminding my manager, gathering chair preferences of each employee by insisting that they try one of the two models we had chosen. We finally submitted the order for the new chairs. Accounting didn’t pay the invoice for another week. But in the end, I am happy to say that everyone in the company now has a decent chair to sit on. New recruits automatically get ordered a new chair. A nice small win.</p>
<h2 id="recruiting">Recruiting</h2>
<p>At one point around the three month mark of my tenure, it seemed like someone was resigning every week. We also had a big workload to get through and we were trying to hire Scala developers in a market that had mostly never heard of Scala. Recruiters kept sending us ideal candidates that couldn’t make it through the first ten minutes of an interview. I carried out the interviews with my colleague Dave and we had come up with a simple problem involving <a href="http://www.scala-lang.org/api/2.11.7/index.html#scala.Option">Option</a>, which we got candidates to complete on the whiteboard.</p>
<p>If we were not in the office (because all the meeting rooms were taken) we’d take the candidates to a coffee shop, buy them a coffee and then get them to discuss the problem on a sheet of paper.</p>
<p>One thing to note is that we always helped the candidates out if they hit a snag or got nervous and forgot everything that they knew. We also made it a point to explain the solution we were looking for if the candidates failed to reach something reasonable. We gave them pointers, book recommendations, offered pros and cons of their solutions. We spent a long time, usually an hour even with candidates that were not acing it.</p>
<p>If a candidate had failed to come up with a solution, we asked them to study up and learn the how to solve the problem and come back in a few weeks - if they were very keen to work on functional programming. The first four chapters of <a href="http://www.amazon.com/Functional-Programming-Scala-Paul-Chiusano/dp/1617290653">Functional Programming in Scala</a> book was our recommended reading.</p>
<p>People learn all the time. Just because you don’t know something today, doesn’t mean you won’t know it tomorrow or next week. I wish more workplaces realised that.</p>
<p>I joked with Dave that we were teaching functional programming through the interviews one candidate at a time. :)</p>
<h2 id="conferences">Conferences</h2>
<p>I make it a point to go to at least two conferences a year. The <a href="http://www.lambdajam.com">YOW! Lambda Jam</a> is one of them and I have been attending since its inception. Naturally I asked to attend and was going to purchase the tickets myself as I always do. I entered into “negotiations” with the company about maybe getting a couple of days off to go for the conference. There seemed to quite a lot of resistance at first, but I went ahead and purchased my tickets and also took annual leave for the two days I needed. If the company was not going to give me the days off I would just use my leave. Not ideal and not very supportive.</p>
<p>In the meantime I convinced a couple of senior developers to come to a YOW! Night - a presentation leading up to the conference. This finally piqued the interest of these developers and they were on board for going to the Lambda Jam - if the company sponsored them and gave them the days off.</p>
<p>I mentioned to my manager that we should send another couple of senior developers to the conference. The senior developers made their case to management as well. I’m not sure why this was such a hard sell. Surely you want your staff skilled up right? Anyway after what seemed like a miracle, the company sponsored three tickets and gave us all leave to go for the conference. The conference was amazing and really opened up the minds of the other developers on the team to the power of functional programming. The weeks following the conference were filled with discussions about Category Theory and various patterns we had heard of at the conference. It transformed the team and made using functional programming to solve problems a viable option.</p>
<h2 id="scala-lalalala">Scala-lalalala</h2>
<p>This was my first professional Scala gig. I had done Scala in my own time, after work and on the weekends, for the last four years. I had written applications which I use everyday. But this was my first Scala “job”.</p>
<p>I loved writing Scala full time.</p>
<p>To really get up to speed on any language you need to use it a lot; for many different things. It was also good to mentor other developers on how to use Scala for functional programming. It has definitely solidified my understanding of many concepts.</p>
<p>I will definitely be looking for another Scala job in the future.</p>
<h2 id="cadence">Cadence</h2>
<p>There was a lot of chaos going on daily. Fixes were being rushed into production without any tests. They then broke production. Then another fix was rushed into production to fix the fix. Sometimes that broke too. Every decision was based on how many minutes or hours something was going to take. There was no time to plan any changes or to pay back technical debt.</p>
<p>Dave and I came up with a weekly sprint that had a couple of definite days for releasing to production. On other days we had time to design solutions, make improvements to our code, deployments and pay back technical debt. We had sprint opens where we planned what we were going to do for the next release. We batched the highest priority fixes and features into each release. After a release we had a retrospective where we tried to learn from our past mistakes. This is a typical Agile workflow.</p>
<p>This cadence of constantly delivering quality software lasted for about a good two months. Once the system we were working on was deemed “stable”, we were not allowed to improve it in any way.</p>
<p>We were then thrown onto more prototypical pursuits which mean the death of the cadence we had so carefully nurtured and bankruptcy through technical debt.</p>
<h2 id="free-lunch">Free lunch</h2>
<p>The company has a “free lunch on Mondays” policy where the company would buy all employees lunch. The main drawback was that you had to eat it in the office and generally hurry back to your work as soon as you finished. I generally avoided Monday lunches and chose instead to get outside and take a break. This meant I had to buy or bring in my own food on Monday which I had no problems with.</p>
<p>Then our CTO made an announcement that the maximum budget for any person’s lunch was $10. This was bit miserly and the company was not saving that much money with this cutback as opposed to the thousands we were wasting elsewhere. As expected after a while more people started avoiding the free lunch. After what almost seemed like a revolt from the staff, the $10 cap seems to have been lifted. Time will tell.</p>
<h2 id="working-from-home">Working from home</h2>
<p>The company seemed to have a work from home policy - for some people. Some developers worked four days a week. Others seemed to work six or seven. It all depended on what was negotiated with the CTO. Strangely if you had something being delivered, or had some errands to run, then you could “legitimately” work from home. If you just wanted to work from home, you couldn’t. You needed a reason - even a bogus one.</p>
<p>My friend Ryan and I were trying very hard to change this and discussed this with management ad nauseum. We spoke to Human Resources about it. We even spoke to the CEO when he was down visiting from the US. After a long hard battle, it looks like my co-workers will enjoy working from home one day a week. Even once working from home had been “approved”, it was always a “it’s happening next week” kind of thing. So it has yet to happen but I am hopeful that it will at some point. Unfortunately since tomorrow is my last day, like Moses I will not enter the promised land.</p>
<p>What was so frustrating was that we were working with cutting edge technology and rushing things into production all the time. Process changes on the other hand were draconian. If we needed a simple process change, it took more than six months, Human Resource approval and major arm-twisting of the CTO.</p>
<h2 id="crutches">Crutches</h2>
<p>At the very start of my tenure I was a coffee nut and joined the resident coffee gang in their two-to-three visits to the coffee shop per day. Over time I came to settle in on what is arguably the best coffee shop in Brisbane: <a href="https://www.facebook.com/coffeeanthology">Coffee Anthology</a>. Most people at work were really into their coffee. The caffeine was the ideal accompaniment to the daily stress wheel. We loved coffee so much that we had arranged to have a “coffee class” with Adam, the owner of Anthology. <a href="http://sanj.ink/posts/2015-07-25-coffee-class.html">The class was excellent</a>. As fate would have it, I read some articles about the harmful effects of caffeine shortly after and stopped drinking coffee altogether.</p>
<p>Tea became my new beverage of choice, and I brewed my own Oolong and Jasmine tea leaves and stopped visiting coffee shops altogether. Boiling the kettle, infusing the tea and then slowly savouring it became the antidote to the daily stress wheel.</p>
<h2 id="trying-to-make-a-difference">Trying to make a difference</h2>
<p>I’ve had many a chat with Ryan at various coffee shops and over many lunches. We spurred each other on to find and read books and articles about the best workplaces in the world and better ways of working, learning and thinking. We also encouraged each other to <a href="http://blog.ryandrake.com">blog</a> about our thoughts. We tried very hard to makes some positive changes in our current workplace. We won some and but I fear we lost more. But at least we tried.</p>
<h2 id="the-team">The team</h2>
<p>The team I worked with are awesome. They are a really great bunch of people who I would love to work with again some day in the future under better conditions. It’s a shame they are not given the support they deserve to do the great things they are so easily capable of. I’m going to miss working with them.</p>
<h2 id="the-future">The future</h2>
<p>It’s been ten months, but it feels like a mini-lifetime.</p>
<p>I’m looking forward to spending more time at home with my family. Working on <a href="https://github.com/ssanj">my own projects</a> is something else I want to do. Maybe some chillaxing and musing thrown in there for good measure.</p>
<p>I have chosen something different for myself. I have done the unthinkable and left a job without having another job in the wings. I have space to think and make some good decisions. I sense something wonderful is just on the horizon.</p>]]></description>
    <pubDate>Sat, 06 Jan 2018 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2018-01-06-the-last-ten-months-at-a-startup.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Continuous Compilation and Testing through Stack and Haskell</title>
    <link>http://blog.ssanj.net/posts/2017-11-30-continuous-compilation-and-testing-through-stack-and-haskell.html</link>
    <description><![CDATA[<p>One of the features I missed when coming from a Scala/<a href="https://www.scala-sbt.org">SBT</a> toolset to a <a href="https://docs.haskellstack.org">Stack</a>/Haskell toolset was the continuous running of tasks in SBT, through the <strong>~</strong> operator. For example to continuously compile production sources we could use:</p>
<pre class="command scrollx"><code>~compile</code></pre>
<p>from within SBT.</p>
<p>For a while there I was stumped about how to do the same for Stack. That was until I stumbled across it in the documentation under <a href="https://docs.haskellstack.org/en/stable/GUIDE/#the-build-synonyms">Build Synonyms</a>:</p>
<pre class="command scrollx"><code>stack build --pedantic --haddock --test --exec &quot;echo Yay, it succeeded&quot; --file-watch</code></pre>
<p>The flag of interest is <strong>–file–watch</strong>. Now I can continuously watch for file changes against library or test sources and run commands accordingly:</p>
<pre class="command scrollx"><code>stack build --file-watch</code></pre>
<p>or</p>
<pre class="command scrollx"><code>stack test --file-watch</code></pre>
<p>respectively.</p>]]></description>
    <pubDate>Thu, 30 Nov 2017 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2017-11-30-continuous-compilation-and-testing-through-stack-and-haskell.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>

    </channel>
</rss>
