<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>BabylonCandle</title>
        <link>http://blog.ssanj.net</link>
        <description><![CDATA[The blog of Sanjiv Sahayam]]></description>
        <atom:link href="http://blog.ssanj.net/feed.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 20 May 2020 00:00:00 UT</lastBuildDate>
        <item>
    <title>Loading your Stack Project into GHCi</title>
    <link>http://blog.ssanj.net/posts/2020-05-20-loading-a-test-package-into-ghci-through-stack.html</link>
    <description><![CDATA[<p>Sometimes it’s quite useful to play around with functions and data types in your Stack project from within the GHCi. You can do this by simply running:</p>
<pre class="terminal scrollx"><code>stack ghci</code></pre>
<p>from the root of your Stack project.</p>
<p>This however does not include any test sources or dependencies you may have. To include those as well run:</p>
<pre class="terminal scrollx"><code>stack ghci --test --no-load</code></pre>]]></description>
    <pubDate>Wed, 20 May 2020 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2020-05-20-loading-a-test-package-into-ghci-through-stack.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>An even Easier Way to Define a Multiline Function in Haskell using GHCi</title>
    <link>http://blog.ssanj.net/posts/2020-05-20-an-even-easier-way-to-define-a-multiline-function-in-haskell-using-ghci.html</link>
    <description><![CDATA[<p>I previously blogged about <a href="https://sanj.ink/posts/2018-08-09-defining-a-multiline-function-in-haskell-using-ghci.html">Defining a multiline function in Haskell using Ghci</a>. The solution was somewhat cumbersome and while hunting around for other options, <a href="https://stackoverflow.com/questions/45362445/defining-function-signature-in-ghci">I came across what I consider to be the simplest way to write a multiline function in GHCi</a>.</p>
<p>From within GHCi, enclose your function between <code>:{</code> and <code>:}</code> strings.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="fu">:</span>{
<span class="ot">  printAfter ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
  printAfter delay <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="fu">$</span> (\d <span class="ot">-&gt;</span> <span class="st">&quot;waiting for &quot;</span> <span class="fu">++</span> d <span class="fu">++</span> <span class="st">&quot; microseconds&quot;</span>) <span class="fu">$</span> show delay
    Control.Concurrent.threadDelay delay
    putStrLn <span class="st">&quot;done&quot;</span>
<span class="fu">:</span>}</code></pre></div>
<p>If you can’t be bothered to add the opening and closing braces or you don’t need nice formatting, you can smash the whole function on one line by replacing every newline with a <code>;</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">printAfter ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (); printAfter delay <span class="fu">=</span> <span class="kw">do</span>; putStrLn <span class="fu">$</span> (\d <span class="ot">-&gt;</span> <span class="st">&quot;waiting for &quot;</span> <span class="fu">++</span> d <span class="fu">++</span> <span class="st">&quot; microseconds&quot;</span>) <span class="fu">$</span> show delay; Control.Concurrent.threadDelay delay;putStrLn <span class="st">&quot;done&quot;</span></code></pre></div>
<p>And that’s it!</p>]]></description>
    <pubDate>Wed, 20 May 2020 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2020-05-20-an-even-easier-way-to-define-a-multiline-function-in-haskell-using-ghci.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Following a Paginated API with Haskell and UnfoldrM</title>
    <link>http://blog.ssanj.net/posts/2020-01-07-following-a-paginated-api-with-haskell-and-unfoldrm.html</link>
    <description><![CDATA[<p>I’ve been using the <a href="https://developer.twitter.com/en.html">Twitter API</a> for <a href="https://github.com/ssanj/milo">Milo</a> - a little command line application that limits my interaction with Twitter, to a select few specific accounts and searches. As with most APIs that have a large number of results, the Twitter API is paginated and you need to keep supplying it with some manner of cursor when going from one page of results to the next.</p>
<p>For the purposes of Milo, I wanted to access the latest direct messages for my user. Unfortunately the call to get your direct messages may return multiple pages of “empty” results and a cursor to the next page of results. I wanted to navigate these empty results and grab the first page with any results that were not empty - essentially just the latest direct message(s).</p>
<p>An example of an empty result:</p>
<div class="sourceCode"><pre class="sourceCode json scrollx"><code class="sourceCode json"><span class="fu">{</span>
  <span class="dt">&quot;next_cursor&quot;</span><span class="fu">:</span> <span class="st">&quot;some_hash&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;events&quot;</span><span class="fu">:</span> <span class="ot">[]</span>
<span class="fu">}</span></code></pre></div>
<p>An example of a non-empty result:</p>
<div class="sourceCode"><pre class="sourceCode json scrollx"><code class="sourceCode json"><span class="fu">{</span>
  <span class="dt">&quot;next_cursor&quot;</span><span class="fu">:</span> <span class="st">&quot;some_hash&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;events&quot;</span><span class="fu">:</span> <span class="ot">[</span>
    <span class="fu">{</span> <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;110&quot;</span><span class="fu">,</span> <span class="dt">&quot;created_timestamp&quot;</span><span class="fu">:</span> <span class="st">&quot;5300&quot;</span><span class="fu">,</span> <span class="er">...</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="fu">{</span> <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;109&quot;</span><span class="fu">,</span> <span class="dt">&quot;created_timestamp&quot;</span><span class="fu">:</span> <span class="st">&quot;5200&quot;</span><span class="fu">,</span> <span class="er">...</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="fu">{</span> <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;108&quot;</span><span class="fu">,</span> <span class="dt">&quot;created_timestamp&quot;</span><span class="fu">:</span> <span class="st">&quot;5200&quot;</span><span class="fu">,</span> <span class="er">...</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="fu">{</span> <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;107&quot;</span><span class="fu">,</span> <span class="dt">&quot;created_timestamp&quot;</span><span class="fu">:</span> <span class="st">&quot;5200&quot;</span><span class="fu">,</span> <span class="er">...</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="fu">{</span> <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;106&quot;</span><span class="fu">,</span> <span class="dt">&quot;created_timestamp&quot;</span><span class="fu">:</span> <span class="st">&quot;5100&quot;</span><span class="fu">,</span> <span class="er">...</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="fu">{</span> <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;105&quot;</span><span class="fu">,</span> <span class="dt">&quot;created_timestamp&quot;</span><span class="fu">:</span> <span class="st">&quot;5100&quot;</span><span class="fu">,</span> <span class="er">...</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="er">...</span>
  <span class="ot">]</span>
<span class="fu">}</span></code></pre></div>
<p>As we can see, the resulting Json payload has both the result (contents of the <code>events</code> field) and the cursor (<code>next_cursor</code>).</p>
<p><em>Please note that I use <a href="https://www.stackage.org/lts-14.20/package/aeson-1.4.6.0">Aeson</a> to convert the Json payload into the <code>DirectMessages</code> data type used in the example, but I have omitted the bindings for clarity. The full Milo source can be found on Github.</em></p>
<p>I initially came up with this solution:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="co">-- Wrapper around the hash return by the Twitter API</span>
<span class="kw">newtype</span> <span class="dt">Cursor</span> <span class="fu">=</span> <span class="dt">Cursor</span> {<span class="ot"> unCursor ::</span> <span class="dt">T.Text</span> } <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- Data type to hold the list of direct messages and the cursor (if any)</span>
<span class="co">-- Each DirectMessage maps to a single element in the `events` array</span>
<span class="kw">data</span> <span class="dt">DirectMessages</span> <span class="fu">=</span> <span class="dt">DirectMessages</span> {<span class="ot"> messages ::</span> [<span class="dt">DirectMessage</span>],<span class="ot"> cursorPosition ::</span> <span class="dt">Maybe</span> <span class="dt">T.Text</span> } <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- Function that returns the direct messages or an error</span>
<span class="ot">getDirectMessages ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DirectMessages</span>)
getDirectMessages <span class="fu">=</span> getMoreDirectMessages <span class="dt">Nothing</span>

<span class="co">-- Function that loops through the result pages using a cursor</span>
<span class="ot">getMoreDirectMessages ::</span> <span class="dt">Maybe</span> <span class="dt">Cursor</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DirectMessages</span>)
getMoreDirectMessages nextCursor <span class="fu">=</span> <span class="kw">do</span>
  dmsE <span class="ot">&lt;-</span> callTwitterApi nextCursor
  <span class="kw">case</span> dmsE <span class="kw">of</span>
    <span class="dt">Right</span> dms<span class="fu">@</span>(<span class="dt">DirectMessages</span> messageList (<span class="dt">Just</span> nextCursor&#39;)) <span class="ot">-&gt;</span> 
      <span class="kw">if</span> (null messageList) <span class="kw">then</span> <span class="co">-- if the messages are empty try to get more</span>
        <span class="kw">do</span>
          (fmap (combineDms dms)) <span class="fu">&lt;$&gt;</span> (getMoreDirectMessages (<span class="dt">Just</span> <span class="fu">.</span> <span class="dt">Cursor</span> <span class="fu">$</span> nextCursor&#39;))
      <span class="kw">else</span> pure <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> dms

    <span class="dt">Right</span> dms<span class="fu">@</span>(<span class="dt">DirectMessages</span> _ <span class="dt">Nothing</span>) <span class="ot">-&gt;</span> pure (<span class="dt">Right</span> dms) <span class="co">-- No more cursors so just stop</span>
    <span class="dt">Left</span> dmError <span class="ot">-&gt;</span> pure <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">$</span> dmError


<span class="co">-- Function that collates direct messages</span>
<span class="ot">combineDms ::</span> <span class="dt">DirectMessages</span> <span class="ot">-&gt;</span> <span class="dt">DirectMessages</span> <span class="ot">-&gt;</span> <span class="dt">DirectMessages</span>

<span class="co">-- Function that calls the Twitter API with the cursor (if any)</span>
<span class="ot">callTwitterApi ::</span> <span class="dt">Maybe</span> <span class="dt">Cursor</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DirectMessages</span>)</code></pre></div>
<p>Now while this works it has a few problems:</p>
<ol style="list-style-type: decimal">
<li>It does not look very reusable, which it should be because pagination is a common problem</li>
<li>There are dangling error cases where we just lift the error into some outer context</li>
</ol>
<p>At this point I recalled seeing a function called <code>unfold</code> somewhere that produced values until some exit condition was reached. I decided to track it down. I found <a href="http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#g:9">unfoldr</a> which sort of fitted what I needed.</p>
<h2 id="unfoldr">unfoldr</h2>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldr ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (b, a)) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b]</code></pre></div>
<p>From the docs:</p>
<blockquote>
<p>The unfoldr function is a `dual’ to foldr: while foldr reduces a list to a summary value, unfoldr builds a list from a seed value. The function takes the element and returns Nothing if it is done producing the list or returns Just (b,a), in which case, b is a prepended to the list and a is used as the next element in a recursive call.</p>
</blockquote>
<p>This sounded promising. I needed to keep “producing” direct message results and stop as soon as I got some results that were not empty. Unfortunately I needed to work within an effect (<code>IO</code>) which this function did not support.</p>
<p>In any event let’s try and understand how this function works. This is the implementation of the the <code>unfoldr</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldr      ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (b, a)) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b]
unfoldr f a  <span class="fu">=</span>
  <span class="kw">case</span> f a <span class="kw">of</span>
   <span class="dt">Just</span> (b,new_a) <span class="ot">-&gt;</span> b <span class="fu">:</span> unfoldr f new_a
   <span class="dt">Nothing</span>        <span class="ot">-&gt;</span> []</code></pre></div>
<p>Given some generator function <code>f</code> that takes a value of type <code>a</code>, call <code>f</code> with <code>a</code> which returns a <code>Maybe</code> with a pair of values consisting of a result <code>b</code> and the next value of <code>a</code> to feed into the same function. The <code>Maybe</code> is either a <code>Just</code> value with a new result <code>b</code> and the next value of <code>a</code>: <code>new_a</code>. In this case the result <code>b</code> is prepended to a list of results which will be generated by recursively calling the <code>unfoldr</code> function with <code>f</code> and <code>new_a</code>. In the <code>Nothing</code> case return an empty List.</p>
<p>Here’s a simple example that produces numbers from 1 to 10 and then stops:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span> (unfoldr)

unfoldr (\a <span class="ot">-&gt;</span> <span class="kw">if</span> a <span class="fu">&lt;</span> <span class="dv">11</span> <span class="kw">then</span> <span class="dt">Just</span> (a, a <span class="fu">+</span> <span class="dv">1</span>) <span class="kw">else</span> <span class="dt">Nothing</span>) <span class="dv">1</span>
<span class="fu">&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</code></pre></div>
<p>Pretty neat but not what I exactly needed.</p>
<p>After some more digging around I stumbled across a library called <a href="http://hackage.haskell.org/package/monad-loops">monad-loops</a> which had what I was after.</p>
<h2 id="unfoldrm">unfoldrM</h2>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldrM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> (b, a))) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m [b]</code></pre></div>
<p>We can see from its function definition that it’s exactly the same as <code>unfoldr</code> except the intermediate and final results are within some <code>Monad m</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldrM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> (b, a))) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m [b]
<span class="ot">unfoldr  ::</span>            (a <span class="ot">-&gt;</span>    <span class="dt">Maybe</span> (b, a))  <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span>   [b]</code></pre></div>
<p>This is the implementation of the <code>unfoldrM</code> function (which is an alias to <code>unfoldrM'</code>):</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldrM&#39; ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadPlus</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> (b,a))) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m (f b)
unfoldrM&#39; f <span class="fu">=</span> go
    <span class="kw">where</span> go a <span class="fu">=</span> <span class="kw">do</span>
            x <span class="ot">&lt;-</span> f a
            <span class="kw">case</span> x <span class="kw">of</span>
                <span class="dt">Nothing</span>         <span class="ot">-&gt;</span> return mzero
                <span class="dt">Just</span> (b, new_a)    <span class="ot">-&gt;</span> <span class="kw">do</span>
                        rest <span class="ot">&lt;-</span> go new_a
                        return (return b <span class="ot">`mplus`</span> rest)</code></pre></div>
<p>The implementation is very similar to <code>unfoldr</code> with differences due to the selected effect type <code>m</code> and result type <code>f</code>.</p>
<p>Given some generator function <code>f</code> that takes a value of type <code>a</code>, it calls <code>f</code> with <code>a</code> within a <code>do</code> block. It returns a <code>Maybe</code> with a pair of values; the result <code>b</code> and the next value of type <code>a</code>: <code>new_a</code>, within a context <code>m</code>. It extracts and pattern matches on the contextual result. If it’s a <code>Nothing</code> it returns the default value for the <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:MonadPlus">MonadPlus</a> type <code>f</code> (<code>mzero</code>). If the result is a <code>Just</code>, it creates a nested <code>do</code> block and recurses with the <code>new_a</code> value to extract the final result <code>rest</code>. It then combines the <code>rest</code> with the previous result <code>b</code> according to the <code>mplus</code> implementation for the <code>MonadPlus</code> type <code>f</code> and returns the results in the context <code>m</code>. <code>unfoldrM</code> is a specialized version of <code>unfoldrM'</code> where <code>f</code> is a <code>[]</code>.</p>
<h2 id="the-solution">The solution</h2>
<p>Now while this seemed to be what I needed it took a little while for me to understand how to use it in my use case. One thing that stumped me was why the initial value <code>a</code> was not a <code>Maybe</code>. Surely the first time I called the Twitter API, I would not have a cursor, so how could I represent it as an <code>a</code>? Even if I did make <code>a</code> a <code>Maybe a</code>, how would I distinguish between the initial call where I had no cursor and the final call where I would also have no cursor?!</p>
<p>My friend <a href="http://twitter.com/ajfitzpatrick">Adam</a> stated the obvious so I could understand it:</p>
<blockquote>
<p>Maybe does not satisfy your requirements because you need more than two states</p>
</blockquote>
<p>Oh dear! Was I supposed to create some ADT with three states? I thought this was supposed to be some plug-and-play solution and it was turning out not to be.</p>
<p>I started off by creating the ADT for the states:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- | An ADT to capture the three states of a cursor:</span>
<span class="kw">data</span> <span class="dt">CursorState</span> a 
    <span class="fu">=</span> <span class="dt">NewCursor</span>           <span class="co">-- NewCursor - Initial cursor state</span>
    <span class="fu">|</span> <span class="dt">GoCursor</span> (<span class="dt">Cursor</span> a) <span class="co">-- GoCursor - A state of having a cursor, typically used for iteration</span>
    <span class="fu">|</span> <span class="dt">StopCursor</span>          <span class="co">-- StopCursor - The final cursor state</span></code></pre></div>
<p>Now if I plug in my types into the <code>unfoldrM</code> function I get the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">unfoldrM (a <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> (b, a))) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m [b]
<span class="co">-- &#39;a&#39; is CursorState c</span>
<span class="co">-- &#39;c&#39; is the type of cursor data</span>
<span class="ot">unfoldrM ::</span> (<span class="dt">CursorState</span> c <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c))) <span class="ot">-&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span> m [b]
<span class="co">-- &#39;m&#39; is IO</span>
<span class="ot">unfoldrM ::</span> (<span class="dt">CursorState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c ))) <span class="ot">-&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> [b]
<span class="co">-- &#39;b&#39; is DirectMessages</span>
<span class="ot">unfoldrM ::</span> (<span class="dt">CursorState</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> (<span class="dt">DirectMessages</span>, <span class="dt">CursorState</span> c))) <span class="ot">-&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">DirectMessages</span>]</code></pre></div>
<p>Now this seems to make sense.</p>
<p>Given that I already had a function of type:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">callTwitterApi ::</span> <span class="dt">Maybe</span> <span class="dt">Cursor</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DirectMessages</span>)</code></pre></div>
<p>How could I convert it to work with the above function definition?</p>
<p>I could define a function <code>unfoldWith</code> as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldWith ::</span> forall m b c<span class="fu">.</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span>  m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c))
unfoldWith <span class="dt">NewCursor</span> <span class="fu">=</span> undefined
unfoldWith (<span class="dt">GoCursor</span> (<span class="dt">Cursor</span> nextCursor)) <span class="fu">=</span> undefined
unfoldWith <span class="dt">StopCursor</span> <span class="fu">=</span> undefined</code></pre></div>
<p>The simplest one to define is the <code>StopCursor</code> variant:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldWith ::</span> forall m b c<span class="fu">.</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span>  m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c))
unfoldWith <span class="dt">NewCursor</span> <span class="fu">=</span> undefined
unfoldWith (<span class="dt">GoCursor</span> (<span class="dt">Cursor</span> nextCursor)) <span class="fu">=</span> undefined
unfoldWith <span class="dt">StopCursor</span> <span class="fu">=</span> pure <span class="dt">Nothing</span></code></pre></div>
<p>and that compiles!</p>
<p>Next I can tried to implement the <code>NewCursor</code> variant:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldWith ::</span> forall m b c<span class="fu">.</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span>  m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c))
unfoldWith <span class="dt">NewCursor</span> <span class="fu">=</span> undefined <span class="co">-- I need to be able to use callTwitterApi here</span>
unfoldWith (<span class="dt">GoCursor</span> (<span class="dt">Cursor</span> nextCursor)) <span class="fu">=</span> undefined
unfoldWith <span class="dt">StopCursor</span> <span class="fu">=</span> pure <span class="dt">Nothing</span></code></pre></div>
<p>generalising the <code>callTwitterApi</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">callTwitterApi ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DirectMessages</span>)
<span class="co">-- Since we need to reduce our Monad to an m, wrap the IO (Either String) in ExceptT</span>
<span class="co">-- ExceptT String IO is &#39;m&#39; (Essentially a wrapped (IO Either String))</span>
<span class="co">-- DirectMessages is &#39;a&#39;</span>
<span class="ot">callTwitterApi ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">String</span> <span class="dt">IO</span> <span class="dt">DirectMessages</span>
<span class="co">-- which simplifies to:</span>
<span class="ot">callTwitterApi ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> m <span class="dt">DirectMessages</span>

<span class="co">-- Now we should be able to define any API that gets some `a` as:</span>
<span class="ot">someApi ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> m a

<span class="co">-- passing in someApi to unfoldWith</span>
<span class="ot">unfoldWith ::</span> forall m a b c<span class="fu">.</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span>  m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c))
unfoldWith f <span class="dt">NewCursor</span> <span class="fu">=</span> f <span class="dt">Nothing</span> <span class="co">-- call it with Nothing because we don&#39;t have a Cursor</span>
unfoldWith f (<span class="dt">GoCursor</span> (<span class="dt">Cursor</span> nextCursor)) <span class="fu">=</span> undefined
unfoldWith _ <span class="dt">StopCursor</span> <span class="fu">=</span> pure <span class="dt">Nothing</span></code></pre></div>
<p>So far so good. But now we need to extract the result and the next cursor from response of the api call. When we call <code>someApi</code> we get a <code>m a</code> in return:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">someApi ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> m a</code></pre></div>
<p><em>Note: To add type annotation to let expressions you need to enable the <code>ScopedTypeVariables</code> language extension</em>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></code></pre></div>
<p>We need a function that transforms that <code>a</code> into a pair of <code>(b, CursorState c)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">extractPayload ::</span> a <span class="ot">-&gt;</span> (b, <span class="dt">CusorState</span> c)</code></pre></div>
<p>passing that into our <code>unfoldWith</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldWith ::</span> forall m a b c<span class="fu">.</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> (b, <span class="dt">CursorState</span> c)) <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span>  m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c))
unfoldWith extractPayload callApiWith <span class="dt">NewCursor</span> <span class="fu">=</span> 
  <span class="kw">let</span><span class="ot"> resultM ::</span> m a <span class="fu">=</span> callApiWith <span class="dt">Nothing</span>
  <span class="kw">in</span>  <span class="dt">Just</span> <span class="fu">.</span> extractPayload <span class="fu">&lt;$&gt;</span> resultM
unfoldWith extract callApiWith (<span class="dt">GoCursor</span> (<span class="dt">Cursor</span> nextCursor)) <span class="fu">=</span> undefined
unfoldWith _ _ <span class="dt">StopCursor</span> <span class="fu">=</span> pure <span class="dt">Nothing</span></code></pre></div>
<p>Seems to compile. Now we do the same of the <code>GoCursor</code> case:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldWith ::</span> forall m a b c<span class="fu">.</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> (b, <span class="dt">CursorState</span> c)) <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> <span class="dt">CursorState</span> <span class="ot">-&gt;</span>  m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span>))
unfoldWith extractPayload callApiWith <span class="dt">NewCursor</span> <span class="fu">=</span> 
  <span class="kw">let</span><span class="ot"> resultM ::</span> m a <span class="fu">=</span> callApiWith <span class="dt">Nothing</span>
  <span class="kw">in</span>  <span class="dt">Just</span> <span class="fu">.</span> extractPayload <span class="fu">&lt;$&gt;</span> resultM
unfoldWith extract callApiWith (<span class="dt">GoCursor</span> (<span class="dt">Cursor</span> nextCursor)) <span class="fu">=</span> 
  <span class="kw">let</span><span class="ot"> resultM ::</span> m a <span class="fu">=</span> callApiWith (<span class="dt">Just</span> nextCursor)
  <span class="kw">in</span>  <span class="dt">Just</span> <span class="fu">.</span> extractPayload <span class="fu">&lt;$&gt;</span> resultM
unfoldWith _ _ <span class="dt">StopCursor</span> <span class="fu">=</span> pure <span class="dt">Nothing</span></code></pre></div>
<p>A <code>DirectMessages</code> is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DirectMessages</span> <span class="fu">=</span> <span class="dt">DirectMessages</span> {<span class="ot"> messages ::</span> [<span class="dt">DirectMessage</span>],<span class="ot"> cursorPosition ::</span> <span class="dt">Maybe</span> <span class="dt">T.Text</span> } <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>And now I just define a function that takes in a <code>DirectMessages</code> type and returns a pair of <code>([DirectMessage], CursorState T.Text)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">extractState ::</span> <span class="dt">DirectMessages</span> <span class="ot">-&gt;</span> ([<span class="dt">DirectMessage</span>], <span class="dt">CursorState</span> <span class="dt">T.Text</span>)
extractState (<span class="dt">DirectMessages</span> [] (<span class="dt">Just</span> c)) <span class="fu">=</span> ([], <span class="dt">GoCursor</span> (<span class="dt">Cursor</span> c)) <span class="co">-- No messages, but we have a cursor, then try to get more</span>
extractState (<span class="dt">DirectMessages</span> [] <span class="dt">Nothing</span>)  <span class="fu">=</span> ([], <span class="dt">StopCursor</span>)          <span class="co">-- No messages and no cursor, then stop</span>
extractState (<span class="dt">DirectMessages</span> msgs _)  <span class="fu">=</span> (msgs, <span class="dt">StopCursor</span>)            <span class="co">-- Messages so we can stop irrespective of the cursor</span></code></pre></div>
<p>Now I can call <code>unfoldrM</code> with:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Control.Monad.Except</span> <span class="kw">as</span> <span class="dt">Ex</span>

<span class="ot">callTwitterApi ::</span> <span class="dt">Ex.ExceptT</span> <span class="dt">String</span> <span class="dt">IO</span> <span class="dt">DirectMessages</span>

<span class="ot">getDirectMessages ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DirectMessages</span>)
getDirectMessages <span class="fu">=</span> Ex.runExceptT <span class="fu">$</span> unfoldrM (unfoldWith extractState callTwitterApi) <span class="dt">NewCursor</span></code></pre></div>
<p>and we have pagination!</p>
<p><em>Note how we had to unwrap the <a href="https://www.stackage.org/haddock/lts-14.20/mtl-2.2.2/Control-Monad-Except.html#t:ExceptT">ExceptT</a> with <code>Ex.runExceptT</code> to retrieve the wrapped <code>IO (Either String DirectMessages)</code></em>.</p>
<p>The interesting point is that we now have a reusable function <code>unfoldWith</code> which we can use with any paginated API that returns us a payload with a result and a cursor.</p>
<h2 id="a-simpler-example">A Simpler Example</h2>
<p>If you got a little lost in the details of the above example, don’t worry. Here’s a simpler example to give you some intuition.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- Payload type</span>
<span class="kw">data</span> <span class="dt">Packet</span> <span class="fu">=</span> <span class="dt">Packet</span> {<span class="ot"> value ::</span> <span class="dt">String</span>,<span class="ot"> cursor ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> <span class="dt">Int</span>) }

<span class="co">-- Function that mimicks a server response</span>
<span class="ot">serviceCall ::</span> forall m <span class="fu">.</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> m <span class="dt">Packet</span>
serviceCall <span class="dt">Nothing</span> <span class="fu">=</span> pure <span class="fu">$</span> <span class="dt">Packet</span> <span class="st">&quot;packet one&quot;</span> (<span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Cursor</span> <span class="dv">1</span>)
serviceCall (<span class="dt">Just</span> (<span class="dt">Cursor</span> cur))
  <span class="fu">|</span> cur <span class="fu">==</span> <span class="dv">1</span>  <span class="fu">=</span> pure <span class="fu">$</span> <span class="dt">Packet</span> <span class="st">&quot;packet two&quot;</span>   (<span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Cursor</span> <span class="dv">2</span>)
  <span class="fu">|</span> cur <span class="fu">==</span> <span class="dv">2</span>  <span class="fu">=</span> pure <span class="fu">$</span> <span class="dt">Packet</span> <span class="st">&quot;packet three&quot;</span> (<span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Cursor</span> <span class="dv">3</span>)
  <span class="fu">|</span> cur <span class="fu">==</span> <span class="dv">3</span>  <span class="fu">=</span> pure <span class="fu">$</span> <span class="dt">Packet</span> <span class="st">&quot;packet four&quot;</span>  (<span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Cursor</span> <span class="dv">4</span>)
  <span class="fu">|</span> otherwise <span class="fu">=</span> pure <span class="fu">$</span> <span class="dt">Packet</span> <span class="st">&quot;packet five&quot;</span>  <span class="dt">Nothing</span>

<span class="co">-- Function that splits the payload into a result and the next CursorState</span>
<span class="ot">extractState ::</span> <span class="dt">Packet</span> <span class="ot">-&gt;</span> (<span class="dt">String</span>, <span class="dt">CursorState</span> <span class="dt">Int</span>)
extractState (<span class="dt">Packet</span> v (<span class="dt">Just</span> c)) <span class="fu">=</span> (v, <span class="dt">GoCursor</span> c)
extractState (<span class="dt">Packet</span> v <span class="dt">Nothing</span>)  <span class="fu">=</span> (v, <span class="dt">StopCursor</span>)</code></pre></div>
<p>As before we can use it with:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">unfoldrM (unfoldWith extractState serviceCall) <span class="dt">NewCursor</span></code></pre></div>
<p>Using the above to log out the first three page responses:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Loops</span> (unfoldrM)
<span class="kw">import </span><span class="dt">Data.List</span> (intercalate)

<span class="ot">run ::</span> <span class="dt">IO</span> ()
run <span class="fu">=</span> 
  <span class="kw">let</span><span class="ot"> resultsIO ::</span> <span class="dt">IO</span> [<span class="dt">String</span>] <span class="fu">=</span> unfoldrM (unfoldWith extractState serviceCall) <span class="dt">NewCursor</span>
<span class="ot">      stringyfied ::</span> <span class="dt">IO</span> <span class="dt">String</span> <span class="fu">=</span> (intercalate <span class="st">&quot;,&quot;</span> <span class="fu">.</span> take <span class="dv">3</span>) <span class="fu">&lt;$&gt;</span> resultsIO
  <span class="kw">in</span> stringyfied <span class="fu">&gt;&gt;=</span> putStrLn</code></pre></div>
<p>which prints out:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">packet one,packet two,packet three</code></pre></div>
<p>I’m not sure if this is a “pattern” that people generally use but I can see myself using this for other paginated APIs.</p>
<p>The code for the <a href="https://github.com/ssanj/unfoldExample">Simpler Example</a>.</p>]]></description>
    <pubDate>Tue, 07 Jan 2020 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2020-01-07-following-a-paginated-api-with-haskell-and-unfoldrm.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Running Hoogle Locally for Haskell Dev</title>
    <link>http://blog.ssanj.net/posts/2019-10-19-running-hoogle-locally-for-haskell-dev.html</link>
    <description><![CDATA[<p><a href="https://www.stackage.org/">Stackage</a> is a neat tool to use when developing Software in Haskell. It’s integrated with the <a href="http://www.haskell.org/hoogle/">Hoogle</a> search engine that can search on type signatures (and function names) which lets you find almost any function easily.</p>
<p>One of the downsides of Hoogle is that it can be slow (at least for me from Australia) and so looking up any kind of documentation becomes a really frustrating experience.</p>
<p>The other issue with using Hoogle is that when you look up documentation for a function of a library that you use in a project, you need to make sure you are looking at the documentation for the exact version of that library that you are using in your <code>package.yml</code> or <code>.cabal</code> file; otherwise you maybe looking at an entirely different api and end up wasting a lot of time.</p>
<p>Stackage solves this by letting you search against a particular snapshot where all the versions of your libraries will be pinned against that snapshot (see the <em>resolver</em> field in <code>stackage.yaml</code>). But I find Stackage searches slow as well. :(</p>
<p>Wouldn’t it be nice if we could run Hoogle locally for our project with all the documentation we need available at our fingertips? What would be even better is that Hoogle was seeded with only the versions of dependencies in our project that we care about.</p>
<p>Well thanks to the fantastic <a href="https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/">An opinionated guide to Haskell in 2018</a> by <a href="https://lexi-lambda.github.io/resume.html">Alexis King</a> we now know how!</p>
<p>The basic steps are:</p>
<ol style="list-style-type: decimal">
<li>Generate Haddock documentation when you compile your project</li>
</ol>
<pre class="terminal scrollx"><code>stack test --fast --haddock-deps</code></pre>
<p>The first time you run this it can take a while.</p>
<ol start="2" style="list-style-type: decimal">
<li>Generate a local Hoogle database</li>
</ol>
<pre class="terminal scrollx"><code>stack hoogle -- generate --local</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>Run your local Hoogle server</li>
</ol>
<pre class="terminal scrollx"><code>stack hoogle -- server --local --port=8080</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>Profit</li>
</ol>
<p>You can get full access to your local Hoogle with:</p>
<pre class="terminal scrollx"><code>open localhost:8080</code></pre>
<p>or open the documentation of a specific library only:</p>
<pre class="terminal scrollx"><code>stack haddock --open lens</code></pre>
<p>Something to be aware of is that when you add new dependencies or change existing ones in your project you need to generate your local Hoogle database again:</p>
<blockquote>
<p>Unfortunately, you will have to manually regenerate the Hoogle database when you install new packages and their documentation, which you can do by re-running stack hoogle – generate –local. Fortunately, regenerating the database doesn’t take very long, as long as you’ve been properly rebuilding the documentation with –haddock-deps.</p>
</blockquote>
<p>This shouldn’t take too long though if you’ve been generating your Haddock as per step 1.</p>
<p>Thanks Alexis! You rock! :)</p>]]></description>
    <pubDate>Sat, 19 Oct 2019 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2019-10-19-running-hoogle-locally-for-haskell-dev.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Pretty Printing Json in Haskell</title>
    <link>http://blog.ssanj.net/posts/2019-09-24-pretty-printing-json-in-haskell.html</link>
    <description><![CDATA[<p>While working on <a href="https://github.com/ssanj/milo">Milo</a> - a small twitter client, I came across an issue where I wanted to dump the full response Json I received from the Twitter API to the console. While I could write this response out as a <code>String</code>, it was very hard to read as it was not nicely indented. I had to resort to copying this text into Sublime Text and pretty printing the Json there using a plugin. Certainly not ideal.</p>
<p>What would be nice is to be able to pretty print the Json content of the response directly to the console without the need for external tools. I got some hints on how to do it from <a href="https://onoffswitch.net/2015/08/15/adventures-pretty-printing-json-haskell/">Adventures in pretty printing JSON in haskell</a>.</p>
<p>To do this I first had to convert the response text into a Json value. I was using <a href="https://www.stackage.org/lts-14.3/package/aeson-1.4.4.0">Aeson</a> Json library in Haskell and all Json is presented by the <a href="https://www.stackage.org/haddock/lts-14.3/aeson-1.4.4.0/Data-Aeson.html#t:Value">Value</a> data type:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">Object</span> <span class="fu">!</span><span class="dt">Object</span>
           <span class="fu">|</span> <span class="dt">Array</span> <span class="fu">!</span><span class="dt">Array</span>
           <span class="fu">|</span> <span class="dt">String</span> <span class="fu">!</span><span class="dt">Text</span>
           <span class="fu">|</span> <span class="dt">Number</span> <span class="fu">!</span><span class="dt">Scientific</span>
           <span class="fu">|</span> <span class="dt">Bool</span> <span class="fu">!</span><span class="dt">Bool</span>
           <span class="fu">|</span> <span class="dt">Null</span></code></pre></div>
<p>The primary way to convert some type <code>a</code> to a <code>Value</code> is by the use of the <code>ToJSON</code> typeclass:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ToJSON</span> a <span class="kw">where</span>
    <span class="co">-- | Convert a Haskell value to a Json-friendly intermediate type.</span>
<span class="ot">    toJSON     ::</span> a <span class="ot">-&gt;</span> <span class="dt">Value</span>
    <span class="co">-- The rest of the class has been omitted for brevity</span></code></pre></div>
<p>While I had written conversions from some concrete types to a Json value, I did not have a way to convert from a <code>ByteString</code> (which was what was returned to me from the <a href="https://www.stackage.org/lts-14.3/package/http-client-0.6.4">http-client</a> library) to a Json <code>Value</code>. It seemed obvious that there should be an instance of <code>ToJSON</code> for <code>ByteString</code> - but there wasn’t. There were instances for <code>String</code> via <code>[Char]</code> and <code>Text</code> though and it seemed like the obvious way to make this conversion happen was by converting the <code>ByteString</code> to one of these two types.</p>
<p>I also came across the <a href="https://www.stackage.org/lts-14.3/package/aeson-pretty-0.8.7">aeson-pretty</a> library which pretty prints Json values. The <code>encodePretty</code> and <code>encodePretty'</code> functions looked of particular interest:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="ot">encodePretty ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span>

<span class="ot">encodePretty&#39; ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span></code></pre></div>
<p>In order to use one of the <code>encodePretty</code> functions I would have to find some way of converting the lazy <code>ByteString</code> (<code>LBS.ByteString</code>) into a <code>ToJSON</code> instance and then have it converted back into a <code>LBS.ByteString</code> by one of the <code>encodePretty</code> functions. A little weird to say the least.</p>
<p>So how do we convert a <code>LBS.ByteString</code> into a <code>ToJSON</code> value? Not surprisingly there is an instance of <code>TOJSON</code> for <code>Value</code> which just returns the supplied Json <code>Value</code>. This seems obvious in hindsight but had me stumped for a while. Given a Json <code>Value</code> we should be able to get a pretty-printed <code>LBS.ByteString</code> representation of that Json <code>Value</code> using one of the <code>encodePretty</code> functions:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="ot">jsonToText ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">LBS.ByteString</span>
jsonToText <span class="fu">=</span> encodePretty</code></pre></div>
<p>Now that we have a <code>LBS.ByteString</code> with our pretty Json content, we need to convert it to a format that can be printed out to the console.</p>
<p>But first a quick primer on a few different ways of representing Strings in Haskell:</p>
<ul>
<li>ByteStrings</li>
</ul>
<blockquote>
<p>A time and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. This has both lazy and strict variants.</p>
</blockquote>
<ul>
<li>Text</li>
</ul>
<blockquote>
<p>A time and space-efficient implementation of Unicode text. Suitable for performance critical use, both in terms of large data quantities and high speed. This also has lazy and strict variants.</p>
</blockquote>
<p>Given that Tweets use a lot of unicode characters for emojis, internationalisation and the like, using <code>Text</code> (Data.Text) seemed to be the best option for this conversion.</p>
<p>The <code>decodeUtf8</code> function in <code>Data.Text.Encoding</code> which is defined as:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="ot">decodeUtf8 ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></code></pre></div>
<p>seems useful and is in the general direction we want to go. Unfortunately it requires a strict <code>ByteString</code> and we need a way to convert from our <code>LBS.ByteString</code> into a strict one.</p>
<p>The <code>toStrict</code> function in <code>Data.ByteString.Lazy</code> which is defined as:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="ot">toStrict ::</span> <span class="dt">LSB.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span></code></pre></div>
<p>can handle the coversion for us.</p>
<p>Now that we have all the pieces we can convert from our lazy <code>ByteString</code> to <code>Text</code>:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Encoding</span> <span class="kw">as</span> <span class="dt">E</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">LBS</span>
<span class="kw">import </span><span class="dt">Data.Aeson.Encode.Pretty</span> (encodePretty)

<span class="ot">lsbToText ::</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
lsbToText <span class="fu">=</span> E.decodeUtf8 <span class="fu">.</span> LBS.toStrict

<span class="ot">jsonToText ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
jsonToText <span class="fu">=</span> lsbToText <span class="fu">.</span> encodePretty</code></pre></div>
<p><code>Data.Text.IO</code> has the <code>Text</code> equivalent of <code>putStrLn</code> and <code>putStr</code> for <code>String</code>:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell">putStr<span class="ot">   ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
putStrLn<span class="ot"> ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>We can use these functions so that we don’t need to convert between <code>String</code> and <code>Text</code> to print out our Json content.</p>
<p>Here’s the final code to write out pretty Json:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Encoding</span> <span class="kw">as</span> <span class="dt">E</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">LBS</span>
<span class="kw">import </span><span class="dt">Data.Aeson.Encode.Pretty</span> (encodePretty)
<span class="kw">import qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">TIO</span>

<span class="ot">lsbToText ::</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
lsbToText <span class="fu">=</span> E.decodeUtf8 <span class="fu">.</span> LBS.toStrict

<span class="ot">jsonToText ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
jsonToText <span class="fu">=</span> lsbToText <span class="fu">.</span> encodePretty

<span class="ot">prettyPrint ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
prettyPrint <span class="fu">=</span> TIO.putStrLn <span class="fu">.</span> jsonToText</code></pre></div>
<p>With the sample Json of:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="ot">tweetJson ::</span> <span class="dt">Value</span>
tweetJson <span class="fu">=</span> 
  object [
           <span class="st">&quot;created_at&quot;</span> <span class="fu">.=</span> <span class="dt">A.String</span> <span class="st">&quot;Wed Sep 18 01:28:16 +0000 2019&quot;</span>, 
           <span class="st">&quot;user&quot;</span> <span class="fu">.=</span> object [
                              <span class="st">&quot;screen_name&quot;</span> <span class="fu">.=</span> <span class="dt">A.String</span> <span class="st">&quot;tweetbot&quot;</span>, 
                              <span class="st">&quot;name&quot;</span> <span class="fu">.=</span> <span class="dt">A.String</span> <span class="st">&quot;The Twittebot&quot;</span> 
                           ],
           <span class="st">&quot;full_text&quot;</span> <span class="fu">.=</span> <span class="dt">A.String</span> <span class="st">&quot;this is a strange tweet&quot;</span>,
           <span class="st">&quot;lang&quot;</span> <span class="fu">.=</span> <span class="dt">A.String</span> <span class="st">&quot;en&quot;</span>
        ]</code></pre></div>
<p>The following output is printed:</p>
<div class="sourceCode"><pre class="sourceCode scrollx json"><code class="sourceCode json"><span class="fu">{</span>
    <span class="dt">&quot;user&quot;</span><span class="fu">:</span> <span class="fu">{</span>
        <span class="dt">&quot;screen_name&quot;</span><span class="fu">:</span> <span class="st">&quot;tweetbot&quot;</span><span class="fu">,</span>
        <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;The Twittebot&quot;</span>
    <span class="fu">},</span>
    <span class="dt">&quot;lang&quot;</span><span class="fu">:</span> <span class="st">&quot;en&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;created_at&quot;</span><span class="fu">:</span> <span class="st">&quot;Wed Sep 18 01:28:16 +0000 2019&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;full_text&quot;</span><span class="fu">:</span> <span class="st">&quot;this is a strange tweet&quot;</span>
<span class="fu">}</span></code></pre></div>]]></description>
    <pubDate>Tue, 24 Sep 2019 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2019-09-24-pretty-printing-json-in-haskell.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Using Validated for Error Accumulation in Scala with Cats</title>
    <link>http://blog.ssanj.net/posts/2019-08-18-using-validated-for-error-accumulation-in-scala-with-cats.html</link>
    <description><![CDATA[<p>The <code>Either</code> data type allows us to represent a computation that may fail. A simplified definition of an <code>Either</code> is given below:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Either[+A, +B]
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Left[+A, +B](value: A) <span class="kw">extends</span> Either[A, B]
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Right[+A, +B](value: B) <span class="kw">extends</span> Either[A, B]</code></pre></div>
<p>We use the two data constructors of Either to represent an error or a success. We wrap an error in the <code>Left</code> constructor or a successful value in the <code>Right</code> constructor. Let’s look at a simple example to make that clearer.</p>
<p>Say we want to validate a person’s name, age and email address. We could use the following ADT (algebraic data type) to do that:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">sealed</span> <span class="kw">trait</span> PersonErrorType
  <span class="kw">case</span> <span class="kw">object</span> NameInvalid <span class="kw">extends</span> PersonErrorType
  <span class="kw">case</span> <span class="kw">object</span> AgeInvalid <span class="kw">extends</span> PersonErrorType
  <span class="kw">case</span> <span class="kw">object</span> EmailInvalid <span class="kw">extends</span> PersonErrorType

  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> <span class="fu">PersonError</span>(value: String, errorType: PersonErrorType)

  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Name(value: String)
  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Age</span>(value: Int)
  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Email</span>(value: String)

  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Person</span>(name: Name, age: Age, email: Email)</code></pre></div>
<p>The <code>PersonErrorType</code> models the various errors we may encounter during the creation of a <code>Person</code>and <code>PersonError</code> captures that error with some extra information as to why it failed. We also have wrapper classes around name, age and email to differentiate them from regular <code>String</code>s.</p>
<p>Now we could use an <code>Either</code> type, which has a <code>PersonError</code> on the <code>Left</code> and some valid type <code>A</code> on the <code>Right</code> to represent our validations. We define the type alias <code>ErrorOr</code> to represent this:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">type</span> ErrorOr[A] = Either[PersonError, A]</code></pre></div>
<p>Notice that in <code>ErrorOr</code>, the error type or the left-side of the <code>Either</code> is fixed to <code>PersonError</code> and we can only vary the success type or the right-side of the Either. This is represented by the type variable <code>A</code>. <code>A</code> could be any type.</p>
<p>We can imagine having three functions that represent validating our name, age and email address:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateName</span>(name: String): ErrorOr[Name] = ???
  
  <span class="kw">def</span> <span class="fu">validateAge</span>(age: String): ErrorOr[Age] = ???

  <span class="kw">def</span> <span class="fu">validateEmail</span>(email: String): ErrorOr[Email] = ???</code></pre></div>
<p>We will leave their definitions for a little later.</p>
<p>Notice that all the functions above return an <code>ErrorOr</code> with different types for the success value.</p>
<p>In addition we would need some kind of validation function that combines the above functions together to return a valid <code>Person</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validatePerson</span>(name: String, age: String, email: String): ErrorOr[Person] = ???</code></pre></div>
<p>Now let’s go ahead and implement the validation functions according to the following rules:</p>
<ol style="list-style-type: decimal">
<li>The supplied name must not be empty and has to start with an uppercase character.</li>
<li>The supplied age must be a number and must be between one and a hundred and twenty.</li>
<li>The supplied email address must not be empty and must have at least a single <code>@</code> character.</li>
</ol>
<p>Following is a sample implementation of the above rules:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateName</span>(name: String): ErrorOr[Name] = {
    <span class="kw">if</span> (name.<span class="fu">headOption</span>.<span class="fu">exists</span>(_.<span class="fu">isUpper</span>)) <span class="fu">Right</span>(Name(name))
    <span class="kw">else</span> <span class="fu">Left</span>(<span class="fu">PersonError</span>(s<span class="st">&quot;Name is empty or does not start with an uppercase character: $name&quot;</span>, NameInvalid))
  }
  
  <span class="kw">def</span> <span class="fu">validateAge</span>(age: String): ErrorOr[Age] = <span class="kw">for</span> {
    numericAge &lt;- <span class="fu">Try</span>(age.<span class="fu">toInt</span>).<span class="fu">toEither</span>.<span class="fu">left</span>.<span class="fu">map</span>(ex =&gt; <span class="fu">PersonError</span>(ex.<span class="fu">getMessage</span>, AgeInvalid))
    validAge &lt;- { 
      <span class="kw">if</span> (numericAge &lt;= <span class="dv">0</span> || numericAge &gt; <span class="dv">120</span>) <span class="fu">Left</span>(<span class="fu">PersonError</span>(s<span class="st">&quot;Age must be a number between 1-120: ${numericAge}&quot;</span>, AgeInvalid))
      <span class="kw">else</span> <span class="fu">Right</span>(numericAge)
    }
  } <span class="kw">yield</span> <span class="fu">Age</span>(validAge)

  
  <span class="kw">def</span> <span class="fu">validateEmail</span>(email: String): ErrorOr[Email] = {
    <span class="kw">if</span> (email.<span class="fu">isEmpty</span> || !email.<span class="fu">contains</span>(<span class="st">&quot;@&quot;</span>)) <span class="fu">Left</span>(<span class="fu">PersonError</span>(s<span class="st">&quot;Email address is empty or does not contain an `@` symbol: $email&quot;</span>, EmailInvalid))
    <span class="kw">else</span> <span class="fu">Right</span>(<span class="fu">Email</span>(email))
  }</code></pre></div>
<p>Don’t worry too much about the implementation.</p>
<p>Notice that we wrap the errors in a <code>PersonError</code> and put it in the <code>Left</code> constructor. Similarly we put the success values in the <code>Right</code> constructor. We also lift all success values into their wrapper types: <code>Name</code>, <code>Age</code> and <code>Email</code>.</p>
<p>Given the above validation implementations, how do we go about combining them to give us either a valid <code>Person</code> instance or an error of type <code>PersonError</code>?</p>
<p>Fortunately for us, the <code>Either</code> datatype implements both the <code>flatMap</code> and <code>map</code> methods which allows us to use a for-comprehension to sequence the validations we have:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validatePerson</span>(name: String, age: String, email: String): ErrorOr[Person] = <span class="kw">for</span> {
    validName   &lt;- <span class="fu">validateName</span>(name)
    validAge    &lt;- <span class="fu">validateAge</span>(age)
    validEmail  &lt;- <span class="fu">validateEmail</span>(email)
  } <span class="kw">yield</span> <span class="fu">Person</span>(validName, validAge, validEmail)</code></pre></div>
<p>Now given a valid name, age and email, the <code>validatePerson</code> function returns a <code>Right</code> with a <code>Person</code> instance:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">validatePerson</span>(<span class="st">&quot;Benjamin Sisko&quot;</span>, <span class="st">&quot;50&quot;</span>, <span class="st">&quot;b.sisko@dsn.st&quot;</span>)
<span class="co">//Right(Person(Name(Benjamin Sisko),Age(50),Email(b.sisko@dsn.st)))</span></code></pre></div>
<p>And it returns a <code>Left</code> with the first error of type <code>PersonError</code> for an invalid person:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">validatePerson</span>(<span class="st">&quot;odo&quot;</span>, <span class="st">&quot;200&quot;</span>, <span class="st">&quot;odo.founder.net&quot;</span>)
<span class="co">//Left(PersonError(Name is empty or does not start with an uppercase character: odo,NameInvalid))</span></code></pre></div>
<p>Now in the above invalid example, we can see that Odo’s age is not between one and a hundred and twenty and his email address does not have a single <code>@</code> character in it and would be invalid. Unfortunately <code>Either</code> bails on the first error and we don’t get to see what any of the other errors are. This could get annoying if we keep getting new errors each time we run this code.</p>
<p>What we want is to get all the errors returned to us at once. How do we do that?</p>
<h2 id="validated">Validated</h2>
<p>This is where we need to lean on the <a href="https://typelevel.org/cats/datatypes/validated.html">Validated</a> datatype. The <code>Validated</code> datatype also lets us represent a computation that may fail - but with one crucial difference. It accumulates any errors that may occur.</p>
<p>The <code>Validated</code> datatype is not defined in the Scala standard library and has to be sourced from the <a href="https://typelevel.org/cats/">Cats</a> functional programming library.</p>
<p>A simplified definition of the <code>Validated</code> type is given below:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Validated[+E, +A]
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Invalid[+E](e: E) <span class="kw">extends</span> Validated[E, Nothing]
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Valid[+A](a: A) <span class="kw">extends</span> Validated[Nothing, A]</code></pre></div>
<p>We can see that the similarity to <code>Either</code> is uncanny. The <code>Invalid</code> data constructor is used to wrap some type of error while the <code>Valid</code> data constructor wraps success types. So what is it about this datatype that makes it accumulate errors in the <code>Invalid</code> case?</p>
<p>Before we answer that question, let’s look at transforming our previous validation example to use <code>Validated</code> instead of <code>Either</code>.</p>
<p>Let’s start off by creating a type alias called <code>AllErrorsOr</code> to accumulate our errors or return our success value:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">type</span> AllErrorsOr[A] = Validated[PersonError, A]

<span class="kw">type</span> ErrorOr[A]     =    Either[PersonError, A]</code></pre></div>
<p>The code is almost identical to <code>ErrorOr</code>; we just swapped out <code>Either</code> for <code>Validated</code>. Let’s change the return type of all our validation function to use <code>AllErrorsOr</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateName</span>(name: String): AllErrorsOr[Name] = ???
  
  <span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = ???

  <span class="kw">def</span> <span class="fu">validateEmail</span>(email: String): AllErrorsOr[Email] = ???

  <span class="kw">def</span> <span class="fu">validatePerson</span>(name: String, age: String, email: String): AllErrorsOr[Person] = ???</code></pre></div>
<p>All we did is swap the <code>ErrorOr</code> type alias for <code>AllErrorsOr</code> and we have the definitions we need.</p>
<h3 id="construction">Construction</h3>
<p>Let’s go ahead and implement our validators. We can change our <code>validateName</code> function quite easily:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateName</span>(name: String): AllErrorsOr[Name] = {
    <span class="kw">if</span> (name.<span class="fu">headOption</span>.<span class="fu">exists</span>(_.<span class="fu">isUpper</span>)) <span class="fu">Valid</span>(Name(name))
    <span class="kw">else</span> Invalid(<span class="fu">PersonError</span>(s<span class="st">&quot;Name is empty or does not start with an uppercase character: $name&quot;</span>, NameInvalid))
  }</code></pre></div>
<p>We just simply swap <code>Left</code> for <code>Invalid</code> and <code>Right</code> for <code>Valid</code> data constructors and we are done. We could have also used the <code>invalid</code> and <code>valid</code> helper functions as well:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateName</span>(name: String): AllErrorsOr[Name] = {
    <span class="kw">if</span> (name.<span class="fu">headOption</span>.<span class="fu">exists</span>(_.<span class="fu">isUpper</span>)) Name(name).<span class="fu">valid</span>
    <span class="kw">else</span> <span class="fu">PersonError</span>(s<span class="st">&quot;Name is empty or does not start with an uppercase character: $name&quot;</span>, NameInvalid).<span class="fu">invalid</span>
  }</code></pre></div>
<p><code>validateAge</code> requires a little more work.</p>
<p>The <code>Either</code> implementation of <code>validateAge</code> was defined as:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = <span class="kw">for</span> {
    numericAge &lt;- <span class="fu">Try</span>(age.<span class="fu">toInt</span>).<span class="fu">toEither</span>.<span class="fu">left</span>.<span class="fu">map</span>(ex =&gt; <span class="fu">PersonError</span>(ex.<span class="fu">getMessage</span>, AgeInvalid))
    validAge &lt;- { 
      <span class="kw">if</span> (numericAge &lt;= <span class="dv">0</span> || numericAge &gt;= <span class="dv">120</span>) <span class="fu">Left</span>(<span class="fu">PersonError</span>(s<span class="st">&quot;Age must be a number between 1-120: ${numericAge}&quot;</span>, AgeInvalid))
      <span class="kw">else</span> <span class="fu">Valid</span>(numericAge)
    }
  } <span class="kw">yield</span> <span class="fu">Age</span>(validAge)</code></pre></div>
<p>So we have a couple of hurdles we need to jump over:</p>
<ol style="list-style-type: decimal">
<li>How do we convert a <code>Try</code> instance to a <code>Validated</code>?</li>
<li><code>Validated</code> does not implement <code>flatMap</code>; only <code>map</code>. This means we can’t use a for-comprehension to sequence <code>Validated</code> instances.</li>
</ol>
<p>We can solve the first problem by using the function <code>fromEither</code> on <code>Validated</code> that converts an <code>Either[A, B]</code> to a <code>Validated[A, B]</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> fromEither[A, B](e: Either[A, B]): Validated[A, B]</code></pre></div>
<p>Updating <code>validatedAge</code> we get:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = {

    <span class="kw">val</span> ageEither: Either[PersonError, Int] = 
      <span class="fu">Try</span>(age.<span class="fu">toInt</span>).
        toEither.
        left.<span class="fu">map</span>(ex =&gt; <span class="fu">PersonError</span>(ex.<span class="fu">getMessage</span>, AgeInvalid))

    <span class="kw">val</span> validatedIntAge: Validated[PersonError, Int] = Validated.<span class="fu">fromEither</span>(ageEither)

    ...
  }</code></pre></div>
<p>We can also use the <code>toValidated</code> to achieve the same result and IMO it’s a little nicer:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = {

    <span class="kw">val</span> validatedIntAge: Validated[PersonError, Int] Either[PersonError, Int] = 
      <span class="fu">Try</span>(age.<span class="fu">toInt</span>).
       toEither.
       left.<span class="fu">map</span>(ex =&gt; <span class="fu">PersonError</span>(ex.<span class="fu">getMessage</span>, AgeInvalid)).
       toValidated

    <span class="kw">val</span> numericAge = ??? <span class="co">//we need some way to get the Int age out of validatedIntAge</span>

    <span class="kw">val</span> validateAge: Validated[PersonError, Age] =
      <span class="kw">if</span> (numericAge &lt;= <span class="dv">0</span> || numericAge &gt; <span class="dv">120</span>) Invalid(<span class="fu">PersonError</span>(s<span class="st">&quot;Age must be a number between 1-120: ${numericAge}&quot;</span>, AgeInvalid))
      <span class="kw">else</span> <span class="fu">Valid</span>(numericAge)
    }

    validatedAge
  }</code></pre></div>
<p>We are almost there but we still need a way of sequencing two <code>Validated</code> instances together; where one <code>Validated</code> instance depends on the value returned from the previous <code>Validated</code> instance.</p>
<h3 id="combining">Combining</h3>
<p>Let’s see how we can answer our previous question:</p>
<blockquote>
<p>So what is it about this datatype that makes it accumulate errors in the <code>Invalid</code> case?</p>
</blockquote>
<p>In order to combine errors in a <code>Validated</code> we need the <u>types used as errors</u> to have some behaviours such as <a href="https://typelevel.org/cats/typeclasses/functor.html">Functor</a> (think something that can be mapped over) and <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Semigroupal.scala">Semigroupal</a> (think combining two effectful values into a pair of effectful values) or we need to <u>put the errors in a type</u> that has the above behaviours. One type that has those behaviours already defined is <a href="https://typelevel.org/cats/datatypes/nel.html">NonEmptyList</a>. A <code>NonEmptyList</code> is as the name suggests, a <code>List</code> that is guaranteed not to be empty (it has at least one element); which means you can safely call <code>head</code> on it among other things.</p>
<p>Cats already has a pre-build <code>Validated</code> type that uses <code>NonEmptyList</code> as its error type called <code>ValidatedNel</code>. The type definition of <code>ValidatedNel</code> reveals its form to us:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">type</span> ValidatedNel[+E, +A] = Validated[NonEmptyList[E], A]</code></pre></div>
<p>We can see that <code>ValidatedNel</code> is a simple type alias for a <code>Validated</code> with a <code>NonEmptyList</code> of some error type <code>E</code> or a success type of <code>A</code>.</p>
<p>The <code>Nel</code> part in <code>ValidatedNel</code> refers to the <code>N</code>on<code>E</code>mpty<code>L</code>ist of the error type. There are also <code>NonEmptyVector</code> and <code>NonEmptyChain</code> variations but they encapsulate the same thing - some data structure that is not empty that is used to accumulate any errors.</p>
<p>Let’s start off by updating our <code>AllErrorsOr</code> type alias to work with <code>ValidatedNel</code> instead of <code>Validated</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="co">//old</span>
<span class="co">//type AllErrorsOr[A] = Validated[PersonError, A]</span>

<span class="co">//new</span>
<span class="kw">type</span> AllErrorsOr[A]   = ValidatedNel[PersonError, A]</code></pre></div>
<p>To lift our invalid and valid values into a <code>ValidateNel</code> we can use the helper functions: <code>invalidNel</code> and <code>validNel</code> respectively. Here’s how we’d change the <code>validateName</code> function to use <code>ValidatedNel</code> instead of <code>Validated</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateName</span>(name: String): AllErrorsOr[Name] = {
  <span class="kw">if</span> (name.<span class="fu">headOption</span>.<span class="fu">exists</span>(_.<span class="fu">isUpper</span>)) Name(name).<span class="fu">validNel</span>
  <span class="kw">else</span> <span class="fu">PersonError</span>(s<span class="st">&quot;Name is empty or does not start with an uppercase character: $name&quot;</span>, NameInvalid).<span class="fu">invalidNel</span>
  }</code></pre></div>
<p>We can also use the usual <code>Valid</code> and <code>Invalid</code> data constructors but it’s a little cumbersome to wrap the <code>Invalid</code> case within a <code>NonEmptyList</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">data</span>.<span class="fu">Validated</span>.<span class="fu">_</span>
<span class="kw">import</span> cats.<span class="fu">data</span>.<span class="fu">NonEmptyList</span>

<span class="kw">def</span> <span class="fu">validateName</span>(name: String): AllErrorsOr[Name] = {
  <span class="kw">if</span> (name.<span class="fu">headOption</span>.<span class="fu">exists</span>(_.<span class="fu">isUpper</span>)) <span class="fu">Valid</span>(Name(name))
  <span class="kw">else</span> Invalid(NonEmptyList.<span class="fu">of</span>(<span class="fu">PersonError</span>(s<span class="st">&quot;Name is empty or does not start with an uppercase character: $name&quot;</span>, NameInvalid)))
}</code></pre></div>
<p>So far so good. Let’s try and update the <code>validateAge</code> function:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = {
    <span class="kw">val</span> numericAgeV: AllErrorsOr[Int] = <span class="fu">Try</span>(age.<span class="fu">toInt</span>).<span class="fu">toEither</span>.<span class="fu">left</span>.<span class="fu">map</span>(ex =&gt; <span class="fu">PersonError</span>(ex.<span class="fu">getMessage</span>, AgeInvalid)).<span class="fu">toValidatedNel</span>
    
    ...
  }</code></pre></div>
<p>We can quite easily convert an <code>Either</code> to a <code>ValidateNel</code> by calling <code>toValidatedNel</code> on it. Next let’s try and update the <code>validateAge</code> function:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = {

    <span class="kw">val</span> numericAgeV: AllErrorsOr[Int] = <span class="co">//from before</span>
    
    <span class="kw">def</span> <span class="fu">validAgeV</span>(numericAge: Int): AllErrorsOr[Int] = {
      <span class="kw">if</span> (numericAge &lt;= <span class="dv">0</span> || numericAge &gt; <span class="dv">120</span>) <span class="fu">PersonError</span>(s<span class="st">&quot;Age must be a number between 1-120: ${numericAge}&quot;</span>, AgeInvalid).<span class="fu">invalidNel</span>
      <span class="kw">else</span> numericAge.<span class="fu">validNel</span>
    }
  }</code></pre></div>
<p>Also quite easy. The next question is how do we combine these two validations to give us an <code>Age</code>?</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  numericAgeV ??? validAgeV =&gt; Age</code></pre></div>
<h4 id="andthen">andThen</h4>
<p>Here’s where the <code>andThen</code> method on <code>Validated</code> comes into play. It is defined as:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Validated[+E, +A] {
  ...
  <span class="kw">def</span> andThen[EE &gt;: E, B](f: (A) ⇒ Validated[EE, B]): Validated[EE, B]
}</code></pre></div>
<p>We can see that this method definition is similar to <code>Either</code>’s <code>flatMap</code> definition, in that it sequences together two computations that may fail, returning the latter as the result:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Either[+E, +A] {
  ...
  flatMap[EE &gt;: E, B](f: (A) =&gt; Either[EE, B]): Either[EE, B]
}</code></pre></div>
<p>We can also see that the first computation has to complete, to supply the <code>A</code> before the next computation can proceed. So let’s use it:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">val</span> combineAgeV: AllErrorsOr[Int] = numericAgeV.<span class="fu">andThen</span>(validAgeV)</code></pre></div>
<p>We can see that when we run <code>numericAgeV</code> validator we get a <code>AllErrorsOr[Int]</code>. This <code>Int</code> is then needed by the <code>validAgeV</code> function, which will then produce another <code>AllErrorsOr[Int]</code> if all goes well.</p>
<p>We still don’t have an <code>Age</code> instance, only an <code>Int</code>. To lift the validated <code>Int</code> value into the <code>Age</code> constructor we can use the <code>map</code> function. <code>map</code> is defined on <code>Validated</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Validated[+E, +A] {
  ...
  <span class="kw">def</span> map[B](f: (A) ⇒ B): Validated[E, B]
}</code></pre></div>
<p>Using <code>map</code> on <code>combineAgeV</code> with the <code>Age</code> constructor gives us the final result:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">val</span> result: AllErrorsOr[Age] = combineAgeV.<span class="fu">map</span>(n =&gt; <span class="fu">Age</span>(n))</code></pre></div>
<p>The complete <code>validateAge</code> function is as follows:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = {
    <span class="kw">val</span> numericAgeV: AllErrorsOr[Int] = <span class="fu">Try</span>(age.<span class="fu">toInt</span>).<span class="fu">toEither</span>.<span class="fu">left</span>.<span class="fu">map</span>(ex =&gt; <span class="fu">PersonError</span>(ex.<span class="fu">getMessage</span>, AgeInvalid)).<span class="fu">toValidatedNel</span>
    
    <span class="kw">def</span> <span class="fu">validAgeV</span>(numericAge: Int): AllErrorsOr[Int] = {
      <span class="kw">if</span> (numericAge &lt;= <span class="dv">0</span> || numericAge &gt;= <span class="dv">120</span>) <span class="fu">PersonError</span>(s<span class="st">&quot;Age must be a number between 1-120: ${numericAge}&quot;</span>, AgeInvalid).<span class="fu">invalidNel</span>
      <span class="kw">else</span> numericAge.<span class="fu">validNel</span>
    }

    numericAgeV.<span class="fu">andThen</span>(validAgeV).<span class="fu">map</span>(Age)
  }</code></pre></div>
<p>Next lets convert our <code>validateEmail</code> function to use <code>ValidatedNel</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateEmail</span>(email: String): AllErrorsOr[Email] = {
  <span class="kw">if</span> (email.<span class="fu">isEmpty</span> || !email.<span class="fu">contains</span>(<span class="st">&quot;@&quot;</span>)) <span class="fu">PersonError</span>(s<span class="st">&quot;Email address is empty or does not contain an `@` symbol: $email&quot;</span>, EmailInvalid).<span class="fu">invalidNel</span>
  <span class="kw">else</span> <span class="fu">Email</span>(email).<span class="fu">validNel</span>
  }</code></pre></div>
<p>That’s very similar to how we modified the <code>validateName</code> function.</p>
<p>Now let’s try and implement the <code>validatePerson</code> function. As mentioned previously, <code>Validated</code> does not implement the <code>flatMap</code> function and hence it <a href="https://stackoverflow.com/questions/35761043/how-to-make-your-own-for-comprehension-compliant-scala-monad">can’t be used in a for-comprehension</a>. So how can we combine these three <code>Validated</code> instances? We can use the <code>andThen</code> method again but it gets quite messy:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">validateName</span>(name).<span class="fu">andThen</span>(validName =&gt; 
  <span class="fu">validateAge</span>(age).<span class="fu">andThen</span>(validAge =&gt; 
    <span class="fu">validateEmail</span>(email).<span class="fu">map</span>(validEmail =&gt; 
      <span class="fu">Person</span>(validName, validAge, validEmail)))) <span class="co">//ValidatedNel[PersonError, Person]</span></code></pre></div>
<p>If only there were a neater way of combining these validations. What we need is a function that is given each of the validated values if successful:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validatePerson</span>(name: String, age: String, email: String): AllErrorsOr[Person] = {
    <span class="fu">validateName</span>(name) ??? <span class="fu">validateAge</span>(age) ??? <span class="fu">validateEmail</span>(email) ??? (validName, validAge, validEmail) =&gt; <span class="fu">Person</span>(validName, validAge, validEmail)
  }</code></pre></div>
<h4 id="mapn">mapN</h4>
<p>To combine two or more <code>ValidatedNel</code> instances that don’t depend on each others’ values we can use the <code>mapN</code> method. A simplified definition of <code>mapN</code> is given below:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="co">//A: 1st successful value</span>
<span class="co">//B: 2nd successful value</span>
<span class="co">//Z: Result of applying function `f`</span>
<span class="co">//E: The failure type</span>
<span class="kw">def</span> mapN[Z](f: (A, B) =&gt; Z)(<span class="kw">implicit</span> functor: Functor[ValidatedNel[E, ?]],<span class="kw">implicit</span> semigroupal: Semigroupal[ValidatedNel[E,?]]): ValidatedNel[E,Z]</code></pre></div>
<p>Luckily we already know that <code>ValidatedNel</code> has <code>Functor</code> and <code>Semigroupal</code> instances so we can just use <code>mapN</code>. <code>mapN</code> is specialised for combining <code>Validated</code> instances from two to twenty two parameters. Using the product capabilities which we get from <code>Semigroupal</code>, we can write a function that uses the three validated values from our validators in the <code>validatePerson</code> function to create an <code>AllErrorsOr[Person]</code> instance.</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validatePerson</span>(name: String, age: String, email: String): AllErrorsOr[Person] = {
    (<span class="fu">validateName</span>(name), <span class="fu">validateAge</span>(age), <span class="fu">validateEmail</span>(email)).<span class="fu">mapN</span>((validName, validAge, validEmail) =&gt; <span class="fu">Person</span>(validName, validAge, validateEmail))
  }</code></pre></div>
<p>Now let’s see what happens when all of the validations fail:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">validatePerson</span>(<span class="st">&quot;odo&quot;</span>, <span class="st">&quot;200&quot;</span>, <span class="st">&quot;odo.founder.net&quot;</span>)
<span class="co">//Invalid(NonEmptyList(PersonError(Name is empty or does not start with an uppercase character: odo,NameInvalid), PersonError(Age must be a number between 1-120: 200,AgeInvalid), PersonError(Email address is empty or does not contain an `@` symbol: odo.founder.net,EmailInvalid)))</span></code></pre></div>
<p>We can see that all the errors have been accumulated for us!</p>
<p>Let’s see what happens when there are no errors:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">validatePerson</span>(<span class="st">&quot;Benjamin Sisko&quot;</span>, <span class="st">&quot;50&quot;</span>, <span class="st">&quot;b.sisko@dsn.st&quot;</span>)
<span class="co">//Valid(Person(Name(Benjamin Sisko),Age(50),Email(b.sisko@dsn.st)))</span></code></pre></div>
<p>We can see the output is as expected.</p>
<h4 id="productl-and-productr">productL and productR</h4>
<p>Now let’s assume that we rewrote <code>validateName</code> such that it depended on two separate validators; one for validating a non empty name (<code>validateNonEmptyName</code>) and one for validating whether the name starts with an uppercase character (<code>validateStartsWithUpper</code>):</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateNonEmptyName</span>(nameString: String): AllErrorsOr[String] = 
  <span class="kw">if</span> (nameString.<span class="fu">nonEmpty</span>) nameString.<span class="fu">validNel</span> <span class="kw">else</span> <span class="fu">PersonError</span>(s<span class="st">&quot;Name is empty&quot;</span>, NameInvalid).<span class="fu">invalidNel</span>

<span class="kw">def</span> <span class="fu">validateStartsWithUpper</span>(nameString: String): AllErrorsOr[String] = 
  <span class="kw">if</span> (nameString.<span class="fu">headOption</span>.<span class="fu">exists</span>(_.<span class="fu">isUpper</span>)) nameString.<span class="fu">validNel</span> <span class="kw">else</span> <span class="fu">PersonError</span>(s<span class="st">&quot;$nameString does not start with an uppercase character&quot;</span>, NameInvalid).<span class="fu">invalidNel</span></code></pre></div>
<p>We might compose them as follows within the <code>validateName</code> function:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateName</span>(name: String): AllErrorsOr[Name] = {
  <span class="fu">validateNonEmptyName</span>(name).<span class="fu">andThen</span>(_ =&gt; <span class="fu">validateStartsWithUpper</span>(name)).<span class="fu">map</span>(Name)
}</code></pre></div>
<p>Notice that we are discarding the success value returned from <code>validateNonEmptyName</code> when using the <code>andThen</code> function. We can directly use the value of the argument <code>name</code> in the <code>validateStartsWithUpper</code> function.</p>
<p>A more succinct way of writing this function composition is by using the <code>productR</code> function to ignore the result of the validator on the left and use the result of the validator on the right (hence the <code>R</code> in <code>productR</code>):</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateNameWithProduct</span>(name: String): AllErrorsOr[Name] = {
  (<span class="fu">validateNonEmptyName</span>(name) productR <span class="fu">validateStartsWithUpper</span>(name)).<span class="fu">map</span>(Name)
}</code></pre></div>
<p>There is an inverse method to <code>productR</code> called <code>productL</code> which uses the result of the validator on the left and ignores the result of the validator on the right. The important thing to realise is that both validators still get run, but only one of the success results is returned. This is a nice shorthand when you need to ignore one of the results from a validator. The <code>productL</code> and <code>productR</code> functions are available to any <a href="https://typelevel.org/cats/typeclasses/applicative.html">Applicative</a> <a href="https://typelevel.org/cats/typeclasses.html">typeclass</a> (via <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Apply.scala#L40">Apply</a>) and since <code>Validated</code> has an <code>Applicative</code> instance we get these methods for free.</p>
<h4 id="combine">combine</h4>
<p>Using <code>productL</code> and <code>productR</code> is similar to using the <code>combine</code> function available to any instance of the <a href="https://typelevel.org/cats/typeclasses/semigroup.html">Semigroup</a> typeclass (think something that can combine values similar to addition or multiplication of numbers) - with one important difference: The successes are accumulated in the event of all the validators succeeding - if your success type has an instance for <code>Semigroup</code>. Some common <code>Semigroup</code>s are <code>String</code>, <code>List</code> and <code>NoneEmptyList</code>.</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="co">//captures all errors if there are any errors</span>
<span class="fu">validateNonEmptyName</span>(<span class="st">&quot;&quot;</span>) combine <span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;joe&quot;</span>)
res11: Validated[NonEmptyList[PersonError],String] = Invalid(<span class="fu">NonEmptyList</span>(<span class="fu">PersonError</span>(Name is empty,NameInvalid), <span class="fu">PersonError</span>(joe does not start <span class="kw">with</span> an uppercase character,NameInvalid)))

<span class="co">//accumulates successes when the success value is a Semigroup</span>
<span class="fu">validateNonEmptyName</span>(<span class="st">&quot;joe1&quot;</span>) combine <span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;Joe2&quot;</span>)
res12: Validated[NonEmptyList[PersonError],String] = <span class="fu">Valid</span>(joe1Joe2)</code></pre></div>
<p>This is just something to be aware of so you won’t get tripped up when your successes are also accumulated.</p>
<p>I’m not really sure when this accumulation of successes would be useful. Send me a comment if you have a problem that this solves.</p>
<h4 id="combinek">combineK</h4>
<p>What if you want to choose between two or more validators, where you only want the one that passed? Think something similar to short-circuiting <code>Boolean</code> operators such as <code>&amp;&amp;</code> or <code>||</code>. In this scenario you could use <code>combineK</code> which comes from the <a href="https://typelevel.org/cats/typeclasses/semigroupk.html">SemigroupK</a> typeclass:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> combineK[A](x: F[A], y: F[A]): F[A] <span class="co">//can choose between `x` and `y` for some types of `F`</span></code></pre></div>
<p>Here’s how we could use it with our validators:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="co">//returns the first validator that succeeds</span>
<span class="fu">validateNonEmptyName</span>(<span class="st">&quot;joe&quot;</span>) combineK  <span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;Joe2&quot;</span>)
res16: net.<span class="fu">ssanj</span>.<span class="fu">validated</span>.<span class="fu">ValidatedValidations</span>.<span class="fu">AllErrorsOr</span>[String] = <span class="fu">Valid</span>(joe)

<span class="co">//tries the second validator if the first fails</span>
<span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;joe1&quot;</span>) combineK  <span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;Joe2&quot;</span>)
res17: net.<span class="fu">ssanj</span>.<span class="fu">validated</span>.<span class="fu">ValidatedValidations</span>.<span class="fu">AllErrorsOr</span>[String] = <span class="fu">Valid</span>(Joe2)

<span class="co">//accumulates errors if all validators fail</span>
<span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;joe1&quot;</span>) combineK  <span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;joe2&quot;</span>)
res18: net.<span class="fu">ssanj</span>.<span class="fu">validated</span>.<span class="fu">ValidatedNelValidations</span>.<span class="fu">AllErrorsOr</span>[String] = Invalid(<span class="fu">NonEmptyList</span>(<span class="fu">PersonError</span>(joe1 does not start <span class="kw">with</span> an uppercase character,NameInvalid), <span class="fu">PersonError</span>(joe2 does not start <span class="kw">with</span> an uppercase character,NameInvalid)))</code></pre></div>
<h3 id="extracting">Extracting</h3>
<p>And finally you can run a <code>fold</code> on a <code>Validated</code> instance (just like you for <code>Option</code> or <code>Either</code>) to extract the value of failure or success:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Validated[+E, +A] {
  ...
  <span class="kw">def</span> fold[B](fe: (E) ⇒ B, fa: (A) ⇒ B): B
}</code></pre></div>
<p>An example usage of <code>fold</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">validateNonEmptyName</span>(<span class="st">&quot;joe&quot;</span>).
  <span class="fu">fold</span>(failure =&gt; s<span class="st">&quot;you failed: $failure&quot;</span>, success =&gt; s<span class="st">&quot;you succeeded with $success&quot;</span>)
res19: String = you succeeded <span class="kw">with</span> joe</code></pre></div>
<p>You can also use pattern matching instead to achieve the same result:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">data</span>.<span class="fu">Validated</span>.<span class="fu">_</span>

<span class="fu">validateNonEmptyName</span>(<span class="st">&quot;joe&quot;</span>) <span class="kw">match</span>  {
  <span class="kw">case</span> Invalid(failure) =&gt; s<span class="st">&quot;you failed: $failure&quot;</span>
  <span class="kw">case</span> <span class="fu">Valid</span>(success) =&gt; s<span class="st">&quot;you succeeded with $success&quot;</span>
}
res22: String = you succeeded <span class="kw">with</span> joe</code></pre></div>
<p>While it can seem like <code>Validated</code> is complex to use, in practise it is quite straight forward once you know a few rules. Hopefully this article has given you some confidence in using <code>Validated</code> the next time you need to accumulate some errors. Also be sure to read the <a href="https://typelevel.org/cats/datatypes/validated.html">Cats documentation on Validated</a> to give you more insight into their usage. Sample code for this article can be found <a href="https://github.com/ssanj/validated-examples">here</a></p>]]></description>
    <pubDate>Sun, 18 Aug 2019 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2019-08-18-using-validated-for-error-accumulation-in-scala-with-cats.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>How to set Fatal Warnings in Scala 2.13?</title>
    <link>http://blog.ssanj.net/posts/2019-07-15-how-to-set-fatal-warnings-in-scala-2.13.html</link>
    <description><![CDATA[<p>With the introduction of Scala 2.13, a bunch of commonly used compiler options have been moved.</p>
<p><code>-Xfatal-warnings</code> has been replaced with <code>-Werror</code>. In fact a lot of <em>warning</em> options which were previously <code>-Ywarn</code> have been moved to <code>-W</code> such as <code>-Ywarn-dead-code</code> which is now <code>-Wdead-code</code>.</p>
<p>Here’s a full list of <code>-W</code> options:</p>
<ul>
<li><strong>-Wdead-code</strong> Warn when dead code is identified.</li>
<li><strong>-Wextra-implicit</strong> Warn when more than one implicit parameter section is defined.</li>
<li><strong>-Wmacros:</strong>&lt;mode&gt; Enable lint warnings on macro expansions. Default: <code>before</code>, <code>help</code> to list choices.</li>
<li><strong>-Wnumeric-widen</strong> Warn when numerics are widened.</li>
<li><strong>-Woctal-literal</strong> Warn on obsolete octal syntax.</li>
<li><strong>-Wself-implicit</strong> Warn when an implicit resolves to an enclosing self-definition.</li>
<li><strong>-Wunused:imports</strong> Warn if an import selector is not referenced.</li>
<li><strong>-Wunused:patvars</strong> Warn if a variable bound in a pattern is unused.</li>
<li><strong>-Wunused:privates</strong> Warn if a private member is unused.</li>
<li><strong>-Wunused:locals</strong> Warn if a local definition is unused.</li>
<li><strong>-Wunused:explicits</strong> Warn if an explicit parameter is unused.</li>
<li><strong>-Wunused:implicits</strong> Warn if an implicit parameter is unused.</li>
<li><strong>-Wunused:params</strong> Enable -Wunused:explicits,implicits.</li>
<li><strong>-Wunused:linted</strong> -Xlint:unused.</li>
<li><strong>-Wvalue-discard</strong> Warn when non-Unit expression results are unused.</li>
</ul>
<p>A lot of <code>-Ywarn</code> options have also now become <code>-Xlint</code>options such as <code>-Ywarn-infer-any</code> which is now <code>-Xlint:infer-any</code>. Here’s a full list of the <code>-Xlint</code> options:</p>
<ul>
<li><strong>-Xlint:adapted-args</strong> Warn if an argument list is modified to match the receiver.</li>
<li><strong>-Xlint:nullary-unit</strong> Warn when nullary methods return Unit.</li>
<li><strong>-Xlint:inaccessible</strong> Warn about inaccessible types in method signatures.</li>
<li><strong>-Xlint:nullary-override</strong> Warn when non-nullary <code>def f()' overrides nullary</code>def f’.</li>
<li><strong>-Xlint:infer-any</strong> Warn when a type argument is inferred to be <code>Any</code>.</li>
<li><strong>-Xlint:missing-interpolator</strong> A string literal appears to be missing an interpolator id.</li>
<li><strong>-Xlint:doc-detached</strong> A Scaladoc comment appears to be detached from its element.</li>
<li><strong>-Xlint:private-shadow</strong> A private field (or class parameter) shadows a superclass field.</li>
<li><strong>-Xlint:type-parameter-shadow</strong> A local type parameter shadows a type already in scope.</li>
<li><strong>-Xlint:poly-implicit-overload</strong> Parameterized overloaded implicit methods are not visible as view bounds.</li>
<li><strong>-Xlint:option-implicit</strong> Option.apply used implicit view.</li>
<li><strong>-Xlint:delayedinit-select</strong> Selecting member of DelayedInit.</li>
<li><strong>-Xlint:package-object-classes</strong> Class or object defined in package object.</li>
<li><strong>-Xlint:stars-align</strong> Pattern sequence wildcard must align with sequence component.</li>
<li><strong>-Xlint:constant</strong> Evaluation of a constant arithmetic expression results in an error.</li>
<li><strong>-Xlint:unused</strong> Enable -Ywarn-unused:imports,privates,locals,implicits.</li>
<li><strong>-Xlint:nonlocal-return</strong> A return statement used an exception for flow control.</li>
<li><strong>-Xlint:implicit-not-found</strong> Check <span class="citation">@implicitNotFound</span> and <span class="citation">@implicitAmbiguous</span> messages.</li>
<li><strong>-Xlint:serial</strong> <span class="citation">@SerialVersionUID</span> on traits and non-serializable classes.</li>
<li><strong>-Xlint:valpattern</strong> Enable pattern checks in val definitions.</li>
<li><strong>-Xlint:eta-zero</strong> Warn on eta-expansion (rather than auto-application) of zero-ary method.</li>
<li><strong>-Xlint:eta-sam</strong> Warn on eta-expansion to meet a Java-defined functional interface that is not explicitly annotated with <span class="citation">@FunctionalInterface</span>.</li>
<li><strong>-Xlint:deprecation</strong> Enable linted deprecations.</li>
</ul>
<p>For a full list of options checkout <a href="https://sanj.ink/posts/2019-06-14-scalac-2.13-options-and-flags.html">scalac 2.13 options and flags</a></p>]]></description>
    <pubDate>Mon, 15 Jul 2019 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2019-07-15-how-to-set-fatal-warnings-in-scala-2.13.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Scalac 2.13 Options and Flags</title>
    <link>http://blog.ssanj.net/posts/2019-06-14-scalac-2.13-options-and-flags.html</link>
    <description><![CDATA[<p>Given that Scala <a href="https://www.scala-lang.org/news/2.13.0">2.13</a> has just landed, there are a bunch of new flags and options available to the compiler. Below is a full list of options to choose from.</p>
<h1 id="standard-options">Standard Options</h1>
<ul>
<li><strong>-Dproperty=value</strong> Pass -Dproperty=value directly to the runtime system.</li>
<li><strong>-J</strong>&lt;flag&gt; Pass &lt;flag&gt; directly to the runtime system.</li>
<li><strong>-P</strong>:&lt;plugin&gt;:&lt;opt&gt; Pass an option to a plugin</li>
<li><strong>-V</strong> Print a synopsis of verbose options.</li>
<li><strong>-W</strong> Print a synopsis of warning options.</li>
<li><strong>-Werror</strong> Fail the compilation if there are any warnings.</li>
<li><strong>-X</strong> Print a synopsis of advanced options.</li>
<li><strong>-Y</strong> Print a synopsis of private options.</li>
<li><strong>-bootclasspath</strong> &lt;path&gt; Override location of bootstrap class files.</li>
<li><strong>-classpath</strong> &lt;path&gt; Specify where to find user class files.</li>
<li><strong>-d</strong> &lt;directory|jar&gt; destination for generated classfiles.</li>
<li><strong>-dependencyfile</strong> &lt;file&gt; Set dependency tracking file.</li>
<li><strong>-deprecation</strong> Emit warning and location for usages of deprecated APIs.</li>
<li><strong>-encoding</strong> &lt;encoding&gt; Specify character encoding used by source files.</li>
<li><strong>-explaintypes</strong> Explain type errors in more detail.</li>
<li><strong>-extdirs</strong> &lt;path&gt; Override location of installed extensions.</li>
<li><strong>-feature</strong> Emit warning and location for usages of features that should be imported explicitly.</li>
<li><strong>-g</strong>:&lt;level&gt; Set level of generated debugging info. (none,source,line,[vars],notailcalls)</li>
<li><strong>-help</strong> Print a synopsis of standard options</li>
<li><strong>-javabootclasspath</strong> &lt;path&gt; Override java boot classpath.</li>
<li><strong>-javaextdirs</strong> &lt;path&gt; Override java extdirs classpath.</li>
<li><strong>-language</strong>:&lt;features&gt; Enable or disable language features</li>
<li><strong>-no-specialization</strong> Ignore <span class="citation">@specialize</span> annotations.</li>
<li><strong>-nobootcp</strong> Do not use the boot classpath for the scala jars.</li>
<li><strong>-nowarn</strong> Generate no warnings.</li>
<li><strong>-opt</strong>:&lt;optimizations&gt; Enable optimizations</li>
<li><strong>-opt-inline-from</strong>:&lt;patterns&gt; Patterns for classfile names from which to allow inlining, <code>help</code> for details.</li>
<li><strong>-opt-warnings</strong>:&lt;warnings&gt; Enable optimizer warnings</li>
<li><strong>-print</strong> Print program with Scala-specific features removed.</li>
<li><strong>-release</strong> &lt;release&gt; Compile for a specific version of the Java platform. Supported targets: 6, 7, 8, 9</li>
<li><strong>-sourcepath</strong> &lt;path&gt; Specify location(s) of source files.</li>
<li><strong>-target</strong>:&lt;target&gt; Target platform for object files. All JVM 1.5 - 1.7 targets are deprecated. (jvm-1.5,jvm-1.6,jvm-1.7,[jvm-1.8])</li>
<li><strong>-toolcp</strong> &lt;path&gt; Add to the runner classpath.</li>
<li><strong>-unchecked</strong> Enable additional warnings where generated code depends on assumptions.</li>
<li><strong>-uniqid</strong> Uniquely tag all identifiers in debugging output.</li>
<li><strong>-usejavacp</strong> Utilize the java.class.path in classpath resolution.</li>
<li><strong>-usemanifestcp</strong> Utilize the manifest in classpath resolution.</li>
<li><strong>-verbose</strong> Output messages about what the compiler is doing.</li>
<li><strong>-version</strong> Print product version and exit.</li>
<li><strong>@</strong>&lt;file&gt; A text file containing compiler arguments (options and source files)</li>
</ul>
<h2 id="deprecated-settings">Deprecated settings:</h2>
<ul>
<li>-optimize Enables optimizations. deprecated: Since 2.12, enables -opt:l:inline -opt-inline-from:**. See -opt:help.</li>
</ul>
<h1 id="verbose-options--v">Verbose Options (-V)</h1>
<ul>
<li><strong>-Vbrowse</strong>:&lt;phases&gt; Browse the abstract syntax tree after &lt;phases&gt;</li>
<li><strong>-Vclasspath</strong> Output information about what classpath is being applied.</li>
<li><strong>-Vdebug</strong> Increase the quantity of debugging output.</li>
<li><strong>-Vdoc</strong> Trace scaladoc activity.</li>
<li><strong>-Vfree-terms</strong> Print a message when reification creates a free term.</li>
<li><strong>-Vfree-types</strong> Print a message when reification resorts to generating a free type.</li>
<li><strong>-Vhot-statistics</strong> Enable <strong>-Vstatistics</strong> to also print hot statistics.</li>
<li><strong>-Vide</strong> Generate, validate and output trees using the interactive compiler.</li>
<li><strong>-Vimplicit-conversions</strong> Print a message whenever an implicit conversion is inserted.</li>
<li><strong>-Vimplicits</strong> Show more detail on why some implicits are not applicable.</li>
<li><strong>-Vinline</strong> &lt;package/Class.method&gt; Print a summary of inliner activity; <code>_</code> to print all, prefix match to select.</li>
<li><strong>-Vissue</strong> Print stack traces when a context issues an error.</li>
<li><strong>-Vlog</strong>:&lt;phases&gt; Log operations during &lt;phases&gt;</li>
<li><strong>-Vmacro</strong> Trace macro activities: compilation, generation of synthetics, classloading, expansion, exceptions.</li>
<li><strong>-Vmacro-lite</strong> Trace macro activities with less output.</li>
<li><strong>-Vopt</strong> &lt;package/Class.method&gt; Trace the optimizer progress for methods; <code>_</code> to print all, prefix match to select.</li>
<li><strong>-Vpatmat</strong> Trace pattern matching translation.</li>
<li><strong>-Vphases</strong> Print a synopsis of compiler phases.</li>
<li><strong>-Vpos</strong> Trace position validation.</li>
<li><strong>-Vprint</strong>:&lt;phases&gt; Print out program after &lt;phases&gt;</li>
<li><strong>-Vprint-args</strong> &lt;file&gt; Print all compiler arguments to the specified location. Use - to echo to the reporter.</li>
<li><strong>-Vprint-pos</strong> Print tree positions, as offsets.</li>
<li><strong>-Vprint-types</strong> Print tree types (debugging option).</li>
<li><strong>-Vquasiquote</strong> Trace quasiquotations.</li>
<li><strong>-Vreflective-calls</strong> Print a message when a reflective method call is generated</li>
<li><strong>-Vreify</strong> Trace reification.</li>
<li><strong>-Vshow</strong>:&lt;phases&gt; (Requires -Xshow-class or -Xshow-object) Show after &lt;phases&gt;</li>
<li><strong>-Vshow-class</strong> &lt;class&gt; Show internal representation of class.</li>
<li><strong>-Vshow-member-pos</strong> &lt;output style&gt; Show start and end positions of members (implies -Yrangepos)</li>
<li><strong>-Vshow-object</strong> &lt;object&gt; Show internal representation of object.</li>
<li><strong>-Vshow-symkinds</strong> Print abbreviated symbol kinds next to symbol names.</li>
<li><strong>-Vshow-symowners</strong> Print owner identifiers next to symbol names.</li>
<li><strong>-Vstatistics</strong>[:phases] Print compiler statistics for specific phases &lt;phases&gt; (default: parser,typer,patmat,erasure,cleanup,jvm)</li>
<li><strong>-Vsymbols</strong> Print the AST symbol hierarchy after each phase.</li>
<li><strong>-Vtyper</strong> Trace type assignments.</li>
<li><strong>Note</strong>:
<ul>
<li>Boolean settings are false unless set: -Xdev -Xcheck-init:true -Xprompt:false</li>
<li>Multi-valued settings are comma-separated: -Xlint:infer-any,unused,-missing-interpolator</li>
<li>Phases are a list of names, ids, or ranges of ids: -Xprint:parser,typer,5-10 -Ylog:-4_</li>
<li>Use _ to enable all: -language:_ -Xprint:_</li>
</ul></li>
</ul>
<h1 id="warning-options--w">Warning Options (-W)</h1>
<ul>
<li><strong>-Wdead-code</strong> Warn when dead code is identified.</li>
<li><strong>-Wextra-implicit</strong> Warn when more than one implicit parameter section is defined.</li>
<li><strong>-Wmacros:</strong>&lt;mode&gt; Enable lint warnings on macro expansions. Default: <code>before</code>, <code>help</code> to list choices.</li>
<li><strong>-Wnumeric-widen</strong> Warn when numerics are widened.</li>
<li><strong>-Woctal-literal</strong> Warn on obsolete octal syntax.</li>
<li><strong>-Wself-implicit</strong> Warn when an implicit resolves to an enclosing self-definition.</li>
<li><strong>-Wunused:imports</strong> Warn if an import selector is not referenced.</li>
<li><strong>-Wunused:patvars</strong> Warn if a variable bound in a pattern is unused.</li>
<li><strong>-Wunused:privates</strong> Warn if a private member is unused.</li>
<li><strong>-Wunused:locals</strong> Warn if a local definition is unused.</li>
<li><strong>-Wunused:explicits</strong> Warn if an explicit parameter is unused.</li>
<li><strong>-Wunused:implicits</strong> Warn if an implicit parameter is unused.</li>
<li><strong>-Wunused:params</strong> Enable -Wunused:explicits,implicits.</li>
<li><strong>-Wunused:linted</strong> -Xlint:unused.</li>
<li><strong>-Wvalue-discard</strong> Warn when non-Unit expression results are unused.</li>
<li><strong>-Xlint:adapted-args</strong> Warn if an argument list is modified to match the receiver.</li>
<li><strong>-Xlint:nullary-unit</strong> Warn when nullary methods return Unit.</li>
<li><strong>-Xlint:inaccessible</strong> Warn about inaccessible types in method signatures.</li>
<li><strong>-Xlint:nullary-override</strong> Warn when non-nullary <code>def f()' overrides nullary</code>def f’.</li>
<li><strong>-Xlint:infer-any</strong> Warn when a type argument is inferred to be <code>Any</code>.</li>
<li><strong>-Xlint:missing-interpolator</strong> A string literal appears to be missing an interpolator id.</li>
<li><strong>-Xlint:doc-detached</strong> A Scaladoc comment appears to be detached from its element.</li>
<li><strong>-Xlint:private-shadow</strong> A private field (or class parameter) shadows a superclass field.</li>
<li><strong>-Xlint:type-parameter-shadow</strong> A local type parameter shadows a type already in scope.</li>
<li><strong>-Xlint:poly-implicit-overload</strong> Parameterized overloaded implicit methods are not visible as view bounds.</li>
<li><strong>-Xlint:option-implicit</strong> Option.apply used implicit view.</li>
<li><strong>-Xlint:delayedinit-select</strong> Selecting member of DelayedInit.</li>
<li><strong>-Xlint:package-object-classes</strong> Class or object defined in package object.</li>
<li><strong>-Xlint:stars-align</strong> Pattern sequence wildcard must align with sequence component.</li>
<li><strong>-Xlint:constant</strong> Evaluation of a constant arithmetic expression results in an error.</li>
<li><strong>-Xlint:unused</strong> Enable -Ywarn-unused:imports,privates,locals,implicits.</li>
<li><strong>-Xlint:nonlocal-return</strong> A return statement used an exception for flow control.</li>
<li><strong>-Xlint:implicit-not-found</strong> Check <span class="citation">@implicitNotFound</span> and <span class="citation">@implicitAmbiguous</span> messages.</li>
<li><strong>-Xlint:serial</strong> <span class="citation">@SerialVersionUID</span> on traits and non-serializable classes.</li>
<li><strong>-Xlint:valpattern</strong> Enable pattern checks in val definitions.</li>
<li><strong>-Xlint:eta-zero</strong> Warn on eta-expansion (rather than auto-application) of zero-ary method.</li>
<li><strong>-Xlint:eta-sam</strong> Warn on eta-expansion to meet a Java-defined functional interface that is not explicitly annotated with <span class="citation">@FunctionalInterface</span>.</li>
<li><strong>-Xlint:deprecation</strong> Enable linted deprecations.</li>
</ul>
<h1 id="advanced-options--x">Advanced Options (-X)</h1>
<ul>
<li><strong>-Xcheckinit</strong> Wrap field accessors to throw an exception on uninitialized access.</li>
<li><strong>-Xdev</strong> Indicates user is a developer - issue warnings about anything which seems amiss</li>
<li><strong>-Xdisable-assertions</strong> Generate no assertions or assumptions.</li>
<li><strong>-Xelide-below</strong> &lt;n&gt; Calls to <span class="citation">@elidable</span> methods are omitted if method priority is lower than argument</li>
<li><strong>-Xgenerate-phase-graph</strong> &lt;file&gt; Generate the phase graphs (outputs .dot files) to fileX.dot.</li>
<li><strong>-Xlint</strong>:&lt;warnings&gt; Enable recommended warnings</li>
<li><strong>-Xmacro-settings</strong>:&lt;option&gt; Custom settings for macros.</li>
<li><strong>-Xmain-class</strong> &lt;path&gt; Class for manifest’s Main-Class entry (only useful with -d &lt;jar&gt;)</li>
<li><strong>-Xmaxerrs</strong> &lt;n&gt; Maximum errors to print</li>
<li><strong>-Xmaxwarns</strong> &lt;n&gt; Maximum warnings to print</li>
<li><strong>-Xmigration</strong>:&lt;version&gt; Warn about constructs whose behavior may have changed since version.</li>
<li><strong>-Xmixin-force-forwarders</strong>:&lt;mode&gt; Generate forwarder methods in classes inhering concrete methods from traits. Default: <code>true</code>, <code>help</code> to list choices.</li>
<li><strong>-Xno-forwarders</strong> Do not generate static forwarders in mirror classes.</li>
<li><strong>-Xno-patmat-analysis</strong> Don’t perform exhaustivity/unreachability analysis. Also, ignore <span class="citation">@switch</span> annotation.</li>
<li><strong>-Xno-uescape</strong> Disable handling of nicode escapes.</li>
<li><strong>-Xnojline</strong> Do not use JLine for editing.</li>
<li><strong>-Xplugin</strong>:&lt;paths&gt; Load a plugin from each classpath.</li>
<li><strong>-Xplugin-disable</strong>:&lt;plugin&gt; Disable plugins by name.</li>
<li><strong>-Xplugin-list</strong> Print a synopsis of loaded plugins.</li>
<li><strong>-Xplugin-require</strong>:&lt;plugin&gt; Abort if a named plugin is not loaded.</li>
<li><strong>-Xpluginsdir</strong> &lt;path&gt; Path to search for plugin archives.</li>
<li><strong>-Xprompt</strong> Display a prompt after each error (debugging option).</li>
<li><strong>-Xreporter</strong> &lt;classname&gt; Specify a custom reporter for compiler messages.</li>
<li><strong>-Xresident</strong> Compiler stays resident: read source filenames from standard input.</li>
<li><strong>-Xscript</strong> &lt;object&gt; Treat the source file as a script and wrap it in a main method.</li>
<li><strong>-Xsource</strong>:&lt;version&gt; Treat compiler input as Scala source for the specified version, see <a href="https://github.com/scala/bug/issues/8126">scala/bug#8126</a>.</li>
<li><strong>-Xsource-reader</strong> &lt;classname&gt; Specify a custom method for reading source files.</li>
<li><strong>-Xverify</strong> Verify generic signatures in generated bytecode.</li>
<li><strong>-Xxml</strong>:&lt;propertys&gt; Configure XML parsing.</li>
</ul>
<h1 id="private-options--y">Private Options (-Y)</h1>
<ul>
<li><strong>-Ybackend-parallelism</strong> &lt;n&gt; maximum worker threads for backend</li>
<li><strong>-Ybackend-worker-queue</strong> &lt;n&gt; backend threads worker queue size</li>
<li><strong>-Ybreak-cycles</strong> Attempt to break cycles encountered during typing</li>
<li><strong>-Ycache-macro-class-loader</strong>:&lt;policy&gt; Policy for caching class loaders for macros that are dynamically loaded. Default: <code>none</code>, <code>help</code> to list choices.</li>
<li><strong>-Ycache-plugin-class-loader</strong>:&lt;policy&gt; Policy for caching class loaders for compiler plugins that are dynamically loaded. Default: <code>none</code>, <code>help</code> to list choices.</li>
<li><strong>-Ycheck</strong>:&lt;phases&gt; Check the tree at the end of &lt;phases&gt;</li>
<li><strong>-Ycompact-trees</strong> Use compact tree printer when displaying trees.</li>
<li><strong>-Ydelambdafy</strong>:&lt;strategy&gt; Strategy used for translating lambdas into JVM code. (inline,[method])</li>
<li><strong>-Ydump-classes</strong> &lt;dir&gt; Dump the generated bytecode to .class files (useful for reflective compilation that utilizes in-memory classloaders).</li>
<li><strong>-Ygen-asmp</strong> &lt;dir&gt; Generate a parallel output directory of .asmp files (ie ASM Textifier output).</li>
<li><strong>-Yimports</strong>:&lt;import&gt; Custom root imports, default is <code>java.lang,scala,scala.Predef</code>.</li>
<li><strong>-Yjar-compression-level</strong> &lt;n&gt; compression level to use when writing jar files</li>
<li><strong>-Ymacro-annotations</strong> Enable support for macro annotations, formerly in macro paradise.</li>
<li><strong>-Ymacro-classpath</strong> &lt;path&gt; The classpath used to reflectively load macro implementations, default is the compilation classpath.</li>
<li><strong>-Ymacro-expand</strong>:&lt;policy&gt; Control expansion of macros, useful for scaladoc and presentation compiler. ([normal],none,discard)</li>
<li><strong>-Ymacro-global-fresh-names</strong> Should fresh names in macros be unique across all compilation units</li>
<li><strong>-Yno-completion</strong> Disable tab-completion in the REPL.</li>
<li><strong>-Yno-flat-classpath-cache</strong> Do not cache flat classpath representation of classpath elements from jars across compiler instances.</li>
<li><strong>-Yno-generic-signatures</strong> Suppress generation of generic signatures for Java.</li>
<li><strong>-Yno-imports</strong> Compile without importing scala.<em>, java.lang.</em>, or Predef.</li>
<li><strong>-Yno-predef</strong> Compile without importing Predef.</li>
<li><strong>-Yopt-inline-heuristics</strong>:&lt;strategy&gt; Set the heuristics for inlining decisions. (at-inline-annotated,everything,[default])</li>
<li><strong>-Ypatmat-exhaust-depth</strong> &lt;n&gt; off</li>
<li><strong>-Ypresentation-any-thread</strong> Allow use of the presentation compiler from any thread</li>
<li><strong>-Ypresentation-debug</strong> Enable debugging output for the presentation compiler.</li>
<li><strong>-Ypresentation-delay</strong> &lt;n&gt; Wait number of ms after typing before starting typechecking</li>
<li><strong>-Ypresentation-log</strong> &lt;file&gt; Log presentation compiler events into file</li>
<li><strong>-Ypresentation-replay</strong> &lt;file&gt; Replay presentation compiler events from file</li>
<li><strong>-Ypresentation-strict</strong> Do not report type errors in sources with syntax errors.</li>
<li><strong>-Ypresentation-verbose</strong> Print information about presentation compiler tasks.</li>
<li><strong>-Yprint-trees</strong>:&lt;style&gt; How to print trees when -Xprint is enabled. ([text],compact,format,text+format)</li>
<li><strong>-Yprofile-destination</strong> &lt;file&gt; Profiling output - specify a file or <code>-</code> for console.</li>
<li><strong>-Yprofile-enabled</strong> Enable profiling.</li>
<li><strong>-Yprofile-external-tool</strong>[:phases] Enable profiling for a phase using an external tool hook. Generally only useful for a single phase &lt;phases&gt; (default: typer)</li>
<li><strong>-Yprofile-run-gc</strong>[:phases] Run a GC between phases - this allows heap size to be accurate at the expense of more time. Specify a list of phases, or all &lt;phases&gt; (default: _)</li>
<li><strong>-Yprofile-trace</strong> &lt;file&gt; Capture trace of compilation in Chrome Trace format</li>
<li><strong>-Yrangepos</strong> Use range positions for syntax trees.</li>
<li><strong>-Yrecursion</strong> &lt;n&gt; Set recursion depth used when locking symbols.</li>
<li><strong>-Yreify-copypaste</strong> Dump the reified trees in copypasteable representation.</li>
<li><strong>-Yrepl-class-based</strong> Use classes to wrap REPL snippets instead of objects</li>
<li><strong>-Yrepl-outdir</strong> &lt;path&gt; Write repl-generated classfiles to given output directory (use “” to generate a temporary dir)</li>
<li><strong>-Yresolve-term-conflict</strong>:&lt;strategy&gt; Resolve term conflicts. (package,object,[error])</li>
<li><strong>-Yscriptrunner</strong> &lt;classname&gt; Specify a scala.tools.nsc.ScriptRunner (default, resident, shutdown, or a class name).</li>
<li><strong>-Yskip</strong>:&lt;phases&gt; Skip &lt;phases&gt;</li>
<li><strong>-Ystop-after</strong>:&lt;phases&gt; Stop after &lt;phases&gt;</li>
<li><strong>-Ystop-before</strong>:&lt;phases&gt; Stop before &lt;phases&gt;</li>
<li><strong>-Yvalidate-pos</strong>:&lt;phases&gt; Validate positions after the given phases (implies -Yrangepos) &lt;phases&gt;</li>
<li><strong>Note</strong>:
<ul>
<li>Boolean settings are false unless set: -Xdev -Xcheck-init:true -Xprompt:false</li>
<li>Multi-valued settings are comma-separated: -Xlint:infer-any,unused,-missing-interpolator</li>
<li>Phases are a list of names, ids, or ranges of ids: -Xprint:parser,typer,5-10 -Ylog:-4</li>
<li>Use _ to enable all: -language:_ -Xprint:_</li>
</ul></li>
</ul>]]></description>
    <pubDate>Fri, 14 Jun 2019 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2019-06-14-scalac-2.13-options-and-flags.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Running Scala Metals With Sublime Text on MacOSX</title>
    <link>http://blog.ssanj.net/posts/2019-06-11-running-scala-metals-with-sublime-text-on-macosx.html</link>
    <description><![CDATA[<p>I’ve finally got <a href="https://scalameta.org/metals">Scala Metals</a> working through Sublime Text 3 on MacOSX Mojave and I’m pretty happy about it! There are some quirks to getting it to work though, so I thought I’d document them here for anyone else who might be struggling to set this up.</p>
<div class="figure">
<img src="/images/metals/metals-sample.gif" alt="Metal Works" />
<p class="caption">Metal Works</p>
</div>
<h2 id="installation">Installation</h2>
<ul>
<li>Use the package manager to install the <em>LSP</em> plugin from <a href="https://packagecontrol.io/packages/LSP">tomv564/LSP</a> or from <a href="https://github.com/tomv564/LSP">Github</a>.</li>
<li>Make sure you have a Java 8 JDK installed and that it is returned as the default JDK. You can find out what your default JDK is by running:</li>
</ul>
<pre class="terminal scrollx"><code>  /usr/libexec/java-home</code></pre>
<p>If you don’t see a JDK 1.8.x version listed, then have a look at <a href="#invalid-java-version-something-other-than-jdk-8">Invalid Java Version</a></p>
<ul>
<li>Make sure you have a supported Scala version (2.11 and 2.12):</li>
</ul>
<blockquote>
<p>Metals works only with Scala versions 2.12.8, 2.12.7, 2.11.12, 2.12.6, 2.12.5, 2.12.4, 2.11.11, 2.11.10 and 2.11.9. Note that 2.10.x and 2.13.x are not supported.</p>
</blockquote>
<ul>
<li>Install <a href="https://get-coursier.io/">coursier</a> through <em>Homebrew</em>:</li>
</ul>
<pre class="terminal scrollx"><code>  brew tap coursier/formulas
  brew install coursier</code></pre>
<p>Once installed verify that you have the latest version with:</p>
<pre class="terminal scrollx"><code>  coursier --help</code></pre>
<p>Which should return you a version after <code>1.1.0-M9</code>. The latest version as of writing this post is:</p>
<pre class="terminal scrollx"><code>  Coursier 2.0.0-RC1</code></pre>
<ul>
<li>Install <a href="https://scalameta.org/metals/">Scala Metals</a> for <a href="https://scalameta.org/metals/docs/editors/sublime.html">Sublime Text</a>:</li>
</ul>
<pre class="terminal scrollx"><code>  coursier bootstrap \
    --java-opt -Xss4m \
    --java-opt -Xms100m \
    --java-opt -Dmetals.client=sublime \
    org.scalameta:metals_2.12:0.6.1 \
    -r bintray:scalacenter/releases \
    -r sonatype:snapshots \
    -o /usr/local/bin/metals-sublime -f</code></pre>
<p><em>The incantation above installs Metals <code>0.6.1</code>. Check the Metals site for the latest version</em>.</p>
<p>Ensure the generated <strong>metals-sublime</strong> binary is available on your <em>$PATH</em>.</p>
<ul>
<li>Ensure you have <a href="https://www.scala-sbt.org/">SBT</a> version 0.13.17+ or 1.x installed.</li>
</ul>
<h2 id="configuration">Configuration</h2>
<ul>
<li>Update your <em>key bindings</em> for LSP (<strong>Preferences</strong> &gt; <strong>Package Settings</strong> &gt; <strong>LSP</strong> &gt; <strong>Key Bindings</strong>) as needed. The snippet below adds the <strong>F12</strong> binding for going to a definition of a symbol and the <strong>CMD</strong> + <strong>ALT</strong> + <strong>H</strong> binding for signature help and <strong>SHIFT</strong> + <strong>F10</strong> to import a project:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode json scrollx"><code class="sourceCode json">    <span class="fu">{</span> <span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;f12&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp_symbol_definition&quot;</span><span class="fu">}</span><span class="er">,</span>
    <span class="fu">{</span> <span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;super+alt+h&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;noop&quot;</span><span class="fu">,</span> <span class="dt">&quot;context&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="fu">{</span> <span class="dt">&quot;key&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp.signature_help&quot;</span><span class="fu">,</span> <span class="dt">&quot;operator&quot;</span><span class="fu">:</span> <span class="st">&quot;equal&quot;</span><span class="fu">,</span> <span class="dt">&quot;operand&quot;</span><span class="fu">:</span> <span class="dv">0</span><span class="fu">}</span><span class="ot">]</span><span class="fu">,</span> <span class="fu">}</span><span class="er">,</span>
    <span class="fu">{</span> <span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;shift+f10&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp_execute&quot;</span><span class="fu">,</span> <span class="dt">&quot;args&quot;</span><span class="fu">:{</span><span class="dt">&quot;command_name&quot;</span><span class="fu">:</span> <span class="st">&quot;build-import&quot;</span><span class="fu">,</span> <span class="dt">&quot;command_args&quot;</span><span class="fu">:{}}}</span><span class="er">,</span></code></pre></div>
<ul>
<li>Update your <em>settings</em> for LSP (<strong>Preferences</strong> &gt; <strong>Package Settings</strong> &gt; <strong>LSP</strong> &gt; <strong>Settings</strong>) with the following:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode json scrollx"><code class="sourceCode json"><span class="fu">{</span>
  <span class="dt">&quot;log_payloads&quot;</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span>
  <span class="dt">&quot;log_debug&quot;</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span>
  <span class="dt">&quot;log_stderr&quot;</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span>
  <span class="dt">&quot;show_diagnostics_severity_level&quot;</span><span class="fu">:</span> <span class="dv">4</span><span class="fu">,</span>
  <span class="dt">&quot;show_code_actions_bulb&quot;</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span>
  <span class="dt">&quot;complete_all_chars&quot;</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span>
  <span class="dt">&quot;only_show_lsp_completions&quot;</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span>
  <span class="dt">&quot;prefer_label_over_filter_text&quot;</span><span class="fu">:</span> <span class="kw">true</span>
<span class="fu">}</span></code></pre></div>
<p>I’ve included a lot of diagnostic logging to ensure I can see when something goes wrong. If you are happy with your setup, feel free to remove this extra logging:</p>
<ul>
<li><strong>log_payloads</strong> - Log all payloads from the LSP server</li>
<li><strong>log_debug</strong> - Extra verbose logging</li>
<li><strong>log_stderr</strong> - Log server errors</li>
<li><strong>show_diagnostics_severity_level</strong> - Bumped to 4 which is INFO and below (everything). 3 is default.</li>
</ul>
<p>These are the non-diagnostic settings:</p>
<ul>
<li><strong>prefer_label_over_filter_text</strong> - Set to <strong>true</strong> to return full function definitions as suggestions. If set to <strong>false</strong> returns only the function name.</li>
<li><strong>show_code_actions_bulb</strong> - Show icon in the gutter when there is an action to take</li>
<li><strong>only_show_lsp_completions</strong> - When set to <strong>true</strong> Turns off all other suggestions for completions.</li>
<li><strong>complete_all_chars</strong> - Set to <strong>true</strong> to get completions for all characters</li>
</ul>
<p>You can find more detail on these settings in the <a href="https://lsp.readthedocs.io/en/latest/features/#configuring">docs</a>.</p>
<ul>
<li>Open a Scala project through Sublime Text.</li>
<li>Launch the Command Palette with <strong>CMD</strong> + <strong>SHIFT</strong> + <strong>P</strong> and choose <strong>LSP: Enable Language Server in Project</strong> &gt; <strong>metals</strong>. This will create a <em>.metals</em> directory in your root folder. It will contain a <em>metals.log</em> file which you can scan for any errors.</li>
<li>Open the console with <strong>CTRL</strong> + <strong>`</strong> to scan for any errors.</li>
<li>Browse to a Scala file and open it. This needs to be done to trigger the import process.</li>
<li><p>There should be a prompt asking you to import the project. Choose <strong>import</strong>. This will then proceed to download all your dependencies and create a <em>.bloop</em> directory in your root folder. You should see something like this in the console:</p>
<blockquote>
<p>server: running ‘sbt metalsEnable bloopInstall’</p>
</blockquote></li>
<li><p>Watch the console for any obvious errors such as:</p>
<blockquote>
<p>no functionality will work</p>
</blockquote></li>
<li><p>If everything worked you should see something like this in the logs:</p>
<blockquote>
<p>server: time: compiled project your_project_name in time_taken s</p>
</blockquote></li>
<li><p>If you didn’t see the import dialog, press <strong>SHIFT</strong> + <strong>F10</strong>. If you saw any errors in the log go to <a href="#workarounds">workarounds</a>.</p></li>
</ul>
<h2 id="workarounds">Workarounds</h2>
<h3 id="no-import-dialog">No Import Dialog</h3>
<ul>
<li>Try <strong>SHIFT</strong> + <strong>F10</strong>. If that does not work follow the steps below.</li>
<li>Launch the Command Palette with <strong>CMD</strong> + <strong>SHIFT</strong> + <strong>P</strong> and choose <strong>LSP: Disable Language Server in Project</strong> &gt; <strong>metals</strong>.</li>
<li>Delete the <em>.metals</em> directory. If you haven’t stopped the server, the <em>.metals</em> folder will keep reappearing.</li>
<li>Close the project window. You may see a message about the metals server crashing. Choose <strong>cancel</strong> not to restart it.</li>
<li><p>Open your project in Sublime Text again.</p></li>
<li>Launch the Command Palette with <strong>CMD</strong> + <strong>SHIFT</strong> + <strong>P</strong> and choose <strong>LSP: Enable Language Server in Project</strong> &gt; <strong>metals</strong>.</li>
<li>Open a Scala file.</li>
<li><p>You should now see the <strong>import</strong> dialog. Choose <strong>import</strong>.</p></li>
</ul>
<p><em>If you do not see the <em>import</em> dialog check the logs for one of the other errors listed below.</em></p>
<h3 id="invalid-sbt-version">Invalid SBT version</h3>
<p>You’ll see something like this in the Sublime Text console:</p>
<blockquote>
<p>Automatic build import is not supported for sbt 0.13.xyz. To fix this problem, upgrade to sbt v0.13.17+</p>
</blockquote>
<p>Bump your SBT version to at least <em>0.13.17</em> in your <em>project/properties</em> and then follow <a href="#no-import-dialog">No Import Dialog</a></p>
<h3 id="invalid-java-version-something-other-than-jdk-8">Invalid Java version (Something other than JDK 8)</h3>
<p>Metals only works with JDK 8 at the moment.</p>
<blockquote>
<p>OpenJDK or Oracle Java 8. Eclipse OpenJ9 and Java 11 are not supported, please make sure the JAVA_HOME environment variable points to valid Java 8 installation.</p>
</blockquote>
<p>Use <em>/usr/libexec/java-home</em> to verify your JDK version. When I initially ran it, I had a bunch of JDKs installed:</p>
<pre class="terminal scrollx"><code>jdk-10.0.2.jdk
jdk1.8.0_181.jdk
jdk1.8.0_131.jdk</code></pre>
<p>and <em>jdk-10.0.2</em> was chosen as the default - because it was the latest. And while the are a <a href="https://superuser.com/questions/682260/how-can-i-set-environment-variables-for-gui-apps-in-os-x-mavericks">number</a> of <a href="https://stackoverflow.com/questions/1348842/what-should-i-set-java-home-to-on-osx/16428639">workarounds</a> for <a href="https://www.ibm.com/support/knowledgecenter/en/SSPJLC_7.6.2/com.ibm.si.mpl.doc/tshoot/ts_java_home.html">this</a>, I chose to go the simple route and moved my <em>jdk-10.0.2</em> installation into an <em>other</em> folder since I didn’t really use it:</p>
<pre class="terminal scrollx"><code>other //my jdk-10.0.2.jdk installation is in here
jdk1.8.0_181.jdk
jdk1.8.0_131.jdk</code></pre>
<p>Consequently when I ran <em>/usr/libexec/java-home</em>, <em>jdk1.8.0_181</em> was the default JDK - which is what I wanted. You can also use something like <a href="https://github.com/jenv/jenv">Jenv</a> to manage your Java environments.</p>
<h3 id="no-build-target-using-presentation-compiler">no build target: using presentation compiler</h3>
<p>This means that <a href="https://github.com/scalacenter/bloop">bloop</a> has not run against your project, which means the project has not been imported. Follow <a href="#no-import-dialog">No Import Dialog</a> to fix.</p>
<h3 id="not-a-valid-command-metalsenable">Not a valid command: metalsEnable</h3>
<p>Sounds like this is some sort of corruption issue, documented <a href="https://github.com/scalameta/metals/issues/685">here</a> or <a href="https://github.com/scalameta/metals/issues/689">here</a>. The log file should reference a <em>sbt-launch.jar</em> in the <em>/tmp</em> directory:</p>
<blockquote>
<p>/tmp/metals-some-long-hash/sbt-launch.jar</p>
</blockquote>
<ul>
<li>Delete the above file</li>
<li>Delete <em>project/target</em> directory</li>
<li>Delete the <em>~/.sbt/1.0/plugins/target/</em> directory</li>
<li>Delete the <em>.bloop</em> directory in your project root</li>
</ul>
<p>Follow <a href="#no-import-dialog">No Import Dialog</a> to reimport the project.</p>
<h3 id="no-.metals-folder-created">No .metals folder created</h3>
<p>You launched the Command Palette with <strong>CMD</strong> + <strong>SHIFT</strong> + <strong>P</strong> and choose <strong>LSP: Enable Language Server in Project</strong> &gt; <strong>metals</strong>. Unfortunately no <em>.metals</em> folder appeared in your project root.</p>
<p>Launch the Command Palette and choose <strong>LSP: Disable Language Server in Project</strong> &gt; <strong>metals</strong>.</p>
<p>Give it a second and try enabling it again with <strong>LSP: Enable Language Server in Project</strong> &gt; <strong>metals</strong>. This should hopefully create the <em>.metals</em> folder. If not try closing the project window in Sublime and trying this workaround again.</p>
<h2 id="whats-not-working">What’s not working</h2>
<p>I couldn’t get imports working. It looks like this works in Visual Studio Code though. At the moment I use my <a href="https://github.com/ssanj/scuggest">Scuggest</a> plugin to fill this gap.</p>
<h2 id="glossary">Glossary</h2>
<h3 id="all-lsp-server-settings">All LSP Server Settings</h3>
<ul>
<li><strong>complete_all_chars</strong> true request completions for all characters, not just trigger characters</li>
<li><strong>only_show_lsp_completions</strong> false disable sublime word completion and snippets from autocomplete lists</li>
<li><strong>completion_hint_type</strong> “auto” override automatic completion hints with “detail”, “kind” or “none”</li>
<li><strong>prefer_label_over_filter_text</strong> false always use the “label” key instead of the “filterText” key in CompletionItems</li>
<li><strong>show_references_in_quick_panel</strong> false show symbol references in Sublime’s quick panel instead of the bottom panel</li>
<li><strong>quick_panel_monospace_font</strong> false use monospace font for the quick panel</li>
<li><strong>show_status_messages</strong> true show messages in the status bar for a few seconds</li>
<li><strong>show_view_status</strong> true show permanent language server status in the status bar</li>
<li><strong>auto_show_diagnostics_panel</strong> true open the diagnostics panel automatically if there are diagnostics</li>
<li><strong>show_diagnostics_phantoms</strong> false show diagnostics as phantoms while the file has no changes</li>
<li><strong>show_diagnostics_count_in_view_status</strong> false show errors and warnings count in the status bar</li>
<li><strong>show_diagnostics_in_view_status</strong> true when on a diagnostic with the cursor, show the text in the status bar</li>
<li><strong>diagnostics_highlight_style</strong> “underline” highlight style of code diagnostics, “underline” or “box”</li>
<li><strong>highlight_active_signature_parameter</strong>: highlight the active parameter of the currently active signature</li>
<li><strong>document_highlight_style</strong>: document highlight style: “underline”, “stippled”, “squiggly” or “”</li>
<li><strong>document_highlight_scopes</strong>: customize your sublime text scopes for document highlighting</li>
<li><strong>diagnostics_gutter_marker</strong> “dot” gutter marker for code diagnostics: “dot”, “circle”, “bookmark”, “cross” or “”</li>
<li><strong>show_code_actions_bulb</strong> false show a bulb in the gutter when code * -* <em>actions</em> are available log_debug false show debug logging in the sublime console</li>
<li><strong>log_server</strong> true show server/logMessage notifications from language - <em>servers</em> in the console</li>
<li><strong>log_stderr</strong> false show language server stderr output in the console log_payloads false show full JSON-RPC responses in the console</li>
</ul>
<h3 id="all-keybindings">All Keybindings</h3>
<div class="sourceCode"><pre class="sourceCode json scrollx"><code class="sourceCode json"><span class="ot">[</span>
    <span class="er">//</span> <span class="er">Show</span> <span class="er">Code</span> <span class="er">Actions</span>
    <span class="fu">{</span> <span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;super+.&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp_code_actions&quot;</span> <span class="fu">}</span><span class="ot">,</span>

    <span class="er">//</span> <span class="er">Show/Hide</span> <span class="er">Diagnostics</span> <span class="er">Panel</span>
    <span class="fu">{</span> <span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;super+alt+m&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp_show_diagnostics_panel&quot;</span> <span class="fu">}</span><span class="ot">,</span>

    <span class="er">//</span> <span class="er">Go</span> <span class="er">To</span> <span class="er">Next/Previous</span> <span class="er">Diagnostics</span> <span class="er">-</span> <span class="er">THIS</span> <span class="er">OVERRIDES</span> <span class="er">DEFAULT</span> <span class="er">SUBLIME</span> <span class="er">KEYBINDINGS</span>
    <span class="er">//</span> <span class="fu">{</span> <span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;f4&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;next_result&quot;</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="er">//</span> <span class="fu">{</span> <span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;shift+f4&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;prev_result&quot;</span> <span class="fu">}</span><span class="ot">,</span>

    <span class="er">//</span> <span class="er">Trigger</span> <span class="er">Signature</span> <span class="er">Help</span>
    <span class="fu">{</span> <span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;super+alt+space&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;noop&quot;</span><span class="fu">,</span> <span class="dt">&quot;context&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="fu">{</span> <span class="dt">&quot;key&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp.signature_help&quot;</span><span class="fu">,</span> <span class="dt">&quot;operator&quot;</span><span class="fu">:</span> <span class="st">&quot;equal&quot;</span><span class="fu">,</span> <span class="dt">&quot;operand&quot;</span><span class="fu">:</span> <span class="dv">0</span><span class="fu">}</span><span class="ot">]</span> <span class="fu">}</span><span class="ot">,</span>

    <span class="er">//</span> <span class="er">Move</span> <span class="er">Up/Down</span> <span class="er">in</span> <span class="er">Signature</span> <span class="er">Help</span>
    <span class="fu">{</span> <span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;up&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;noop&quot;</span><span class="fu">,</span> <span class="dt">&quot;context&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="fu">{</span> <span class="dt">&quot;key&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp.signature_help&quot;</span><span class="fu">,</span> <span class="dt">&quot;operator&quot;</span><span class="fu">:</span> <span class="st">&quot;equal&quot;</span><span class="fu">,</span> <span class="dt">&quot;operand&quot;</span><span class="fu">:</span> <span class="dv">-1</span> <span class="fu">}</span><span class="ot">]</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="fu">{</span> <span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;down&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;noop&quot;</span><span class="fu">,</span> <span class="dt">&quot;context&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="fu">{</span> <span class="dt">&quot;key&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp.signature_help&quot;</span><span class="fu">,</span> <span class="dt">&quot;operator&quot;</span><span class="fu">:</span> <span class="st">&quot;equal&quot;</span><span class="fu">,</span> <span class="dt">&quot;operand&quot;</span><span class="fu">:</span> <span class="dv">1</span> <span class="fu">}</span><span class="ot">]</span> <span class="fu">}</span><span class="ot">,</span>

     <span class="er">//</span> <span class="er">Find</span> <span class="er">Symbol</span> <span class="er">References</span>
    <span class="fu">{</span> <span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;shift+f12&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp_symbol_references&quot;</span> <span class="fu">}</span><span class="ot">,</span>

    <span class="er">//</span> <span class="er">Go</span> <span class="er">To</span> <span class="er">Definition</span>
    <span class="er">//</span> <span class="fu">{</span><span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;UNBOUND&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp_symbol_definition&quot;</span><span class="fu">}</span><span class="ot">,</span>

    <span class="er">//</span> <span class="er">Rename</span> <span class="er">Symbol</span>
    <span class="er">//</span> <span class="fu">{</span> <span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;UNBOUND&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp_symbol_rename&quot;</span> <span class="fu">}</span><span class="ot">,</span>

    <span class="er">//</span> <span class="er">Format</span> <span class="er">Document</span>
    <span class="er">//</span> <span class="fu">{</span><span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;UNBOUND&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp_format_document&quot;</span><span class="fu">}</span><span class="ot">,</span>

    <span class="er">//</span> <span class="er">Format</span> <span class="er">Selection</span>
    <span class="er">//</span> <span class="fu">{</span><span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;UNBOUND&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp_format_document_range&quot;</span><span class="fu">}</span><span class="ot">,</span>

    <span class="er">//</span> <span class="er">Document</span> <span class="er">Symbols</span>
    <span class="er">//</span> <span class="fu">{</span><span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;UNBOUND&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp_document_symbols&quot;</span><span class="fu">}</span><span class="ot">,</span>

    <span class="er">//</span> <span class="er">Symbol</span> <span class="er">Hover</span>
    <span class="er">//</span> <span class="fu">{</span><span class="dt">&quot;keys&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;UNBOUND&quot;</span><span class="ot">]</span><span class="fu">,</span> <span class="dt">&quot;command&quot;</span><span class="fu">:</span> <span class="st">&quot;lsp_hover&quot;</span><span class="fu">}</span><span class="ot">,</span>
<span class="ot">]</span></code></pre></div>]]></description>
    <pubDate>Tue, 11 Jun 2019 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2019-06-11-running-scala-metals-with-sublime-text-on-macosx.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Why are Default Parameter Values Considered Bad in Scala?</title>
    <link>http://blog.ssanj.net/posts/2019-05-01-why-are-default-parameter-values-considered-bad-in-scala.html</link>
    <description><![CDATA[<p>There is a very long issue under <a href="https://github.com/wartremover">Wartremover</a> titled: <a href="https://github.com/wartremover/wartremover/issues/116">“Default arguments are insane” needs explanation</a>. Wartremover is a Scala linter that I personally love using as it definitely increases the quality of any Scala code I write.</p>
<p>The issues around using Default Arguments or <a href="https://docs.scala-lang.org/tour/default-parameter-values.html">Default Parameter Values</a> (as Scala refers to them) are somewhat subtle. The Wartemover issue seems to go on forever, but there are lots of really great ideas in there and I though I could summarise some of them here.</p>
<h2 id="what-is-a-default-parameter-value">What is a Default Parameter Value?</h2>
<blockquote>
<p>Scala provides the ability to give parameters default values that can be used to allow a caller to omit those parameters.</p>
</blockquote>
<p>Here’s a quick example of Default Parameter Values (DPV):</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">log</span>(message: String, level: String = <span class="st">&quot;INFO&quot;</span>) = <span class="fu">println</span>(s<span class="st">&quot;$level: $message&quot;</span>)

<span class="fu">log</span>(<span class="st">&quot;System starting&quot;</span>)  <span class="co">//We didn&#39;t supply level which defaults to INFO; prints INFO: System starting</span>
<span class="fu">log</span>(<span class="st">&quot;User not found&quot;</span>, <span class="st">&quot;WARNING&quot;</span>)  <span class="co">// prints WARNING: User not found</span></code></pre></div>
<p>One of the main benefits of DPV is that you don’t need to supply all the parameters to a method - just the ones that are mandatory. This sounds like a really useful idea, so why are people recommending that we don’t use it?</p>
<h2 id="issues">Issues</h2>
<h3 id="unclear-code">1. Unclear Code</h3>
<p>Here’s an example of some code that uses DPV:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">val</span> streamName: String = ...
KinesisStream.<span class="fu">fromUrl</span>(streamName)</code></pre></div>
<p>Now if you just read the above method it looks like it might be doing the wrong thing. Why are we supplying a Stream name to a method that clearly states that it needs a Url?</p>
<p>The method is defined as:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">object</span> KinesisStream {
  <span class="kw">def</span> <span class="fu">fromUrl</span>(streamName: String, url: Option[String] = None): ...
}</code></pre></div>
<p>The default value for <code>url</code> hides the true nature of what this method needs. The <code>url</code> parameter has been made optional because under some circumstances it is not needed.</p>
<h3 id="breaks-currying-and-partial-application">2. <del>Breaks Currying and Partial Application</del></h3>
<p><a href="https://twitter.com/tpolecat">Rob Norris</a> has a nice article on <a href="https://tpolecat.github.io/2014/06/09/methods-functions.html">Methods are not Functions</a> which covers why currying and partial Application of Functions is broken with DPV. Here’s a simple example:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">log</span>(message: String, level: String = <span class="st">&quot;INFO&quot;</span>) = <span class="fu">println</span>(s<span class="st">&quot;$level: $message&quot;</span>)

scala&gt; <span class="fu">log</span>(<span class="st">&quot;hello!&quot;</span>) <span class="co">//one param</span>
INFO: hello!

scala&gt; <span class="fu">log</span>(<span class="st">&quot;hello!&quot;</span>, <span class="st">&quot;WARN&quot;</span>) <span class="co">//both params</span>
WARN: hello!

<span class="co">//can we map over log?</span>
scala&gt; <span class="kw">val</span> messages = List(<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;world&quot;</span>)
messages: List[String] = List(hello, world)

 <span class="co">//does not work</span>
scala&gt; messages.<span class="fu">map</span>(log)
&lt;console&gt;:<span class="dv">14</span>: error: <span class="kw">type</span> mismatch;
 found   : (String, String) =&gt; Unit
 required: String =&gt; ?
       messages.<span class="fu">map</span>(log)
                    ^
 <span class="co">//does not work</span>
scala&gt; messages.<span class="fu">map</span>(log _)
&lt;console&gt;:<span class="dv">14</span>: error: <span class="kw">type</span> mismatch;
 found   : (String, String) =&gt; Unit
 required: String =&gt; ?
       messages.<span class="fu">map</span>(log _)

<span class="co">//works!</span>
scala&gt; messages.<span class="fu">map</span>(<span class="fu">log</span>(_))
INFO: hello
INFO: world
res6: List[Unit] = List((), ())

<span class="co">//also works</span>
scala&gt; messages.<span class="fu">map</span>(x =&gt; <span class="fu">log</span>(x))
INFO: hello
INFO: world
res7: List[Unit] = List((), ())</code></pre></div>
<p>Weird. So it seems like you can use Currying and Partial Application if you tweak the syntax a little.</p>
<p>Let’s have a go with Rob’s example:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">scala&gt; <span class="kw">def</span> <span class="fu">foo</span>(n: Int = <span class="dv">3</span>, s: String) = s * n
foo: (n: Int, s: String)String

<span class="co">//works</span>
scala&gt; <span class="fu">foo</span>(s = <span class="st">&quot;$$&quot;</span>)
res36: String = $$$$$$

<span class="co">//works</span>
scala&gt; <span class="kw">val</span> p1 = <span class="fu">foo</span>(<span class="dv">42</span>, _:String)
p1: String =&gt; String = $$Lambda$<span class="dv">1192</span>/<span class="dv">1172016038</span>@6c826924

scala&gt; <span class="fu">p1</span>(<span class="st">&quot;@&quot;</span>)
res38: String = @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

<span class="co">//can we get defaults for free after conversion to a function?</span>
scala&gt; <span class="kw">val</span> f1 = foo _
f1: (Int, String) =&gt; String = $$Lambda$<span class="dv">1193</span>/<span class="dv">1526085518</span>@205b3a1a

<span class="co">//does not work</span>
scala&gt; <span class="fu">f1</span>(<span class="dv">10</span>)
&lt;console&gt;:<span class="dv">13</span>: error: not enough arguments <span class="kw">for</span> method apply: (v1: Int, v2: String)String in <span class="kw">trait</span> Function2.
Unspecified value parameter v2.
       <span class="fu">f1</span>(<span class="dv">10</span>)

<span class="co">//works</span>
scala&gt; <span class="kw">val</span> p2 = <span class="fu">f1</span>(<span class="dv">10</span>, _: String)
p2: String =&gt; String = $$Lambda$<span class="dv">1408</span>/<span class="dv">1660635397</span>@7f8ac326

scala&gt; <span class="fu">p2</span>(<span class="st">&quot;*&quot;</span>)
res44: String = **********

scala&gt; <span class="kw">val</span> p3 = <span class="fu">f1</span>(_:Int, <span class="st">&quot;$&quot;</span>)
p3 =&gt; String = $$Lambda$<span class="dv">1409</span>/<span class="dv">1435397638</span>@4047789d

scala&gt; <span class="fu">p3</span>(<span class="dv">5</span>)
res48: String = $$$$$

<span class="co">//we can also supply all arguments</span>
scala&gt; <span class="fu">f1</span>(<span class="dv">10</span>, <span class="st">&quot;*&quot;</span>)
res50: String = **********

<span class="co">//use in higher-order functions</span>
scala&gt; messages.<span class="fu">map</span>(p1)
res51: List[String] = List(hellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohello, worldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworldworld)

scala&gt; messages.<span class="fu">map</span>(p2)
res52: List[String] = List(hellohellohellohellohellohellohellohellohellohello, worldworldworldworldworldworldworldworldworldworld)

scala&gt; List(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>).<span class="fu">map</span>(p3)
res53: List[String] = List($, $$, $$$)</code></pre></div>
<p>This seems to be a moot issue. While the syntax is more awkward than necessary, Currying and Partial Application is certainly possible with DPV. Once we η-expand the method <code>foo</code> to the value <code>f1</code>, we lose the defaulted values defined in <code>foo</code> though; which seems a little odd.</p>
<p>Another way to partially apply methods with default parameters is create a wrapper method with only the mandatory fields:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">scala&gt; <span class="kw">def</span> <span class="fu">foo</span>(n: Int = <span class="dv">3</span>, s: String) = s * n
foo: (n: Int, s: String)String

<span class="co">//wrap foo with foo2</span>
scala&gt; <span class="kw">def</span> <span class="fu">foo2</span>(s: String) = <span class="fu">foo</span>(s = s)
foo2: (s: String)String

scala&gt; <span class="fu">foo2</span>(<span class="st">&quot;#&quot;</span>)
res29: String = ###

<span class="co">//now we can use foo2 in higher-order functions</span>
scala&gt; messages.<span class="fu">map</span>(foo2)
res30: List[String] = List(hellohellohello, worldworldworld)</code></pre></div>
<p>The above technique alludes that there should have been two separate methods all along.</p>
<h3 id="bugs-of-convenience">3. Bugs of Convenience</h3>
<p>In a project I worked on we had some asynchronous tasks that split a workload into chunks using a sliding window of ten elements. Here’s a simplified version of the code:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">scala&gt; <span class="kw">val</span> elements = (<span class="dv">1</span> to <span class="dv">30</span>).<span class="fu">toList</span>
elements: List[Int] = List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>, <span class="dv">15</span>, <span class="dv">16</span>, <span class="dv">17</span>, <span class="dv">18</span>, <span class="dv">19</span>, <span class="dv">20</span>, <span class="dv">21</span>, <span class="dv">22</span>, <span class="dv">23</span>, <span class="dv">24</span>, <span class="dv">25</span>, <span class="dv">26</span>, <span class="dv">27</span>, <span class="dv">28</span>, <span class="dv">29</span>, <span class="dv">30</span>)

scala&gt; <span class="kw">val</span> it = elements.<span class="fu">sliding</span>(<span class="dv">10</span>)
it: Iterator[List[Int]] = non-empty iterator

scala&gt; it.<span class="fu">next</span>
res22: List[Int] = List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>)

it.<span class="fu">next</span> ??? <span class="co">//what does this print?</span>
it.<span class="fu">next</span> ??? <span class="co">//what does this print?</span></code></pre></div>
<p>We witnessed a subtle bug where performance of our processing pipeline was terrible. What was going on?</p>
<p>The actual definition of <code>sliding</code> is:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> sliding[B &gt;: A](size: Int, step: Int = <span class="dv">1</span>): GroupedIterator[B]</code></pre></div>
<p>Notice the default <strong>step</strong> of 1. When we used the <code>sliding</code> function we assumed that the <code>size</code> supplied would also be the step. Everything compiled and there were no warnings. Here is the output of the above example:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">scala&gt; it.<span class="fu">next</span>
res22: List[Int] = List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>)

scala&gt; it.<span class="fu">next</span>
res23: List[Int] = List(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>)

scala&gt; it.<span class="fu">next</span>
res24: List[Int] = List(<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span>)</code></pre></div>
<p>As you can see we were processing the same items multiple times. If the <code>step</code> parameter were explicit this would not have happened. Once the mistake was corrected:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">scala&gt; <span class="kw">val</span> it = elements.<span class="fu">sliding</span>(<span class="dv">10</span>, <span class="dv">10</span>)
it: Iterator[List[Int]] = non-empty iterator

scala&gt; it.<span class="fu">next</span>
res25: List[Int] = List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>)

scala&gt; it.<span class="fu">next</span>
res26: List[Int] = List(<span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>, <span class="dv">15</span>, <span class="dv">16</span>, <span class="dv">17</span>, <span class="dv">18</span>, <span class="dv">19</span>, <span class="dv">20</span>)

scala&gt; it.<span class="fu">next</span>
res27: List[Int] = List(<span class="dv">21</span>, <span class="dv">22</span>, <span class="dv">23</span>, <span class="dv">24</span>, <span class="dv">25</span>, <span class="dv">26</span>, <span class="dv">27</span>, <span class="dv">28</span>, <span class="dv">29</span>, <span class="dv">30</span>)</code></pre></div>
<p>We can see the code slides over ten elements at a time as expected. These kind of bugs are hard to find. We lean on the compiler a lot to point out our mistakes. With DPV while our lives are more convenient because we have less parameters to supply our functions, the compiler fails to see our errors and omissions and can’t help.</p>
<h3 id="bugs-due-to-refactoring">4. Bugs due to Refactoring</h3>
<p>Consider an API at version 1.x that has the following method:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">object</span> Database
  <span class="kw">def</span> <span class="fu">fromUrl</span>(url: String): ...
}</code></pre></div>
<p>A client of the library may use it like:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">Database.<span class="fu">fromUrl</span>(<span class="st">&quot;someUrl&quot;</span>)</code></pre></div>
<p>The developer of the library decides to add a <code>tableName</code> parameter as the <code>url</code> is optional when run locally. Not wanting to introduce an additional method for this our developer then decides to make <code>url</code> a DPV.</p>
<p>As this is a breaking change, he bumps the version of the library to 2.x.</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">object</span> Database {
  <span class="kw">def</span> <span class="fu">fromUrl</span>(tableName: String, url: Option[String] = None): ...
}</code></pre></div>
<p>Now this all seems fine. The major version of the library has been bumped so it indicates potential for a breaking change.</p>
<p>Unfortunately, the client code still compiles after moving to version 2.x of the library:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">Database.<span class="fu">fromUrl</span>(<span class="st">&quot;someUrl&quot;</span>)</code></pre></div>
<p>But now we have problem. Since the location of the <code>url</code> parameter has changed, we are supplying a url as the <code>tableName</code> parameter, and the compiler can’t inform us that anything is broken. We have to find out at runtime that we have a problem.</p>
<h2 id="alternate-designs">Alternate Designs</h2>
<p>Here are some ways to get around using DPV.</p>
<h3 id="supply-all-parameters">Supply all Parameters</h3>
<p>Replace developer convenience for software correctness. Get the developer to supply all parameters. We can change the <code>log</code> function from:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">log</span>(message: String, level: String = <span class="st">&quot;INFO&quot;</span>) = <span class="fu">println</span>(s<span class="st">&quot;$level: $message&quot;</span>)</code></pre></div>
<p>to:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">log</span>(message: String, level: String) = <span class="fu">println</span>(s<span class="st">&quot;$level: $message&quot;</span>)</code></pre></div>
<p>Callers of the <code>log</code> method have to now supply both the <code>message</code> and the <code>level</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">log</span>(<span class="st">&quot;System starting&quot;</span>, <span class="st">&quot;INFO&quot;</span>)</code></pre></div>
<p>Better yet, convert the <code>level</code> parameter to an ADT so that the callers can’t pass through invalid values.</p>
<p>However this technique can get tedious if you have a lot of parameters that you don’t really care about.</p>
<h3 id="breakout-separate-methods">Breakout Separate Methods</h3>
<p>If you don’t want to supply all the parameters each time, consider creating separate methods for the situations you care about.</p>
<p>In the case of the bug with the Database refactoring, we could have pulled out some extra methods:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">object</span> Database {
  <span class="kw">def</span> <span class="fu">remote</span>(url: DatabaseUrl): ...
  <span class="kw">def</span> <span class="fu">remoteWithTable</span>(tableName: String, url: DatabaseUrl): ...
  <span class="kw">def</span> <span class="fu">local</span>(tableName: String): ...
}</code></pre></div>
<p><a href="https://github.com/wartremover/wartremover/issues/116#issuecomment-51173792">Rob Norris on splitting out methods</a>:</p>
<blockquote>
<p>If you have a method with a single default arg you could reasonably suggest splitting it into two methods (as you might do with a single option or boolean arg)</p>
</blockquote>
<h3 id="have-a-default-object">Have a Default Object</h3>
<p>If you have a lot of parameters to your function (and this might be a problem by itself) you could use a default object.</p>
<p>Take <code>tcpConnect</code> as an example:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">tcpConnect</span>(host: String, port: Int = <span class="dv">80</span>, sslEncryption: Boolean = <span class="kw">false</span>, localAddress: Option[String] = None):  String = <span class="st">&quot;connected&quot;</span></code></pre></div>
<p>This could be re-written with a default object:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="co">//original method with defaults removed</span>
<span class="kw">def</span> <span class="fu">tcpConnect</span>(host: String, port: Int, sslEncryption: Boolean, localAddress: Option[String]):  String = <span class="st">&quot;connected&quot;</span>

<span class="co">//config class</span>
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">TcpConnection</span>(host: String, port: Int, sslEncryption: Boolean, localAddress: Option[String])

<span class="co">//function that calls tcpConnect</span>
<span class="kw">def</span> <span class="fu">fromTcpConnection</span>(tcpConnection: TcpConnection): String =
  <span class="fu">tcpConnect</span>(tcpConnection.<span class="fu">host</span>, tcpConnection.<span class="fu">port</span>, tcpConnection.<span class="fu">sslEncryption</span>, tcpConnection.<span class="fu">localAddress</span>)

<span class="co">//default object</span>
<span class="kw">def</span> defaultTcpConnection: TcpConnection = <span class="fu">TcpConnction</span>(host: String = <span class="st">&quot;localhost&quot;</span>, port: Int = <span class="dv">80</span>, sslEncryption: Boolean = <span class="kw">false</span>, localAddress: Option[String] = None)

<span class="co">//usage for a specific URL</span>
<span class="fu">fromTcpConnection</span>(defaultTcpConnection.<span class="fu">copy</span>(host = <span class="st">&quot;http://....&quot;</span>))

<span class="co">//usage for a specific port</span>
<span class="fu">fromTcpConnection</span>(defaultTcpConnection.<span class="fu">copy</span>(port = <span class="dv">8080</span>))

<span class="co">//usage for a secure URL</span>
<span class="fu">fromTcpConnection</span>(defaultTcpConnection.<span class="fu">copy</span>(host = <span class="st">&quot;https://...&quot;</span>, port = <span class="dv">443</span>, sslEncryption = <span class="kw">true</span>))</code></pre></div>
<p><a href="https://github.com/wartremover/wartremover/issues/116#issuecomment-51173792">Rob Norris on using default config objects</a>:</p>
<blockquote>
<p>… right, but then you have the awful copy method to contend with, then you add lenses, then you add phantom types to ensure that options haven’t been set more than once, etc., etc., and I’m not convinced that the complexity is warranted, given the lack thus far of any convincing reason not to use default args</p>
</blockquote>
<p>As Rob mentions, depending on how far you want to take it, avoiding DPVs might lead to very complex solutions.</p>
<p>As <a href="https://github.com/wartremover/wartremover/issues/116#issuecomment-51172733">Maxwell Swadling points out</a> you could also break out separate methods for this:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">connectHTTP</span>(host: String):  String <span class="co">//where port = 80, sslEncryption = false, localAddress = None</span>
<span class="kw">def</span> <span class="fu">connectHTTPPort</span>(host: String, port: Int):  String <span class="co">//where sslEncryption = false, localAddress = None</span>
<span class="kw">def</span> <span class="fu">connectHTTPS</span>(host: String):  String <span class="co">//where port = 443, sslEncryption = true, , localAddress = None</span>
<span class="kw">def</span> <span class="fu">tcpConnect</span>(host: String, port: Int, sslEncryption: Boolean, localAddress: Option[String]):  String <span class="co">//the normal connect with all the arguments.</span></code></pre></div>
<p>If none of these alternates seem attractive, go ahead and use DPV but think hard about how it may introduce bugs into your code base.</p>
<h2 id="parting-thoughts">Parting Thoughts</h2>
<p><a href="https://twitter.com/markhibberd">Mark Hibberd</a> recommends not using DPV for the <a href="https://github.com/wartremover/wartremover/issues/116#issuecomment-51326211">following</a>:</p>
<ol style="list-style-type: decimal">
<li><strong>Allocation of resources</strong> (there are even examples of this in scalaz) - which is utterly wrong. Anything that is allocated by a default argument has no reasonable lifecycle and is unlikely (or impossible) to be closed properly.</li>
<li><strong>Default configurations</strong> - these are a developer convenience that lead to operational bugs. There is no such thing as a “safe” default, where it could mean forgetting to set something in production leads to an incorrect value rather than an error (this is closely related to what Minsky says as mentioned by Eric above).</li>
<li><strong>Common arguments through delegating methods</strong> - these are representative of what <span class="citation">@maxpow4h</span> originally stated. That if you have multiple methods with optional arguments, it is extremely easy for incorrect code to compile by forgetting to delegate one of the arguments.</li>
<li><strong>Faux overloading</strong> - it is cool to hate on overloading so I will avoid it by using named arguments with defaults, ending up with the exact same situation. Code that is subtly wrong (such as forgetting to pass argument) still compiles. This is not an acceptable situation.</li>
</ol>
<p><a href="https://github.com/wartremover/wartremover/issues/116#issuecomment-51268242">Eric Torreborre on when to use DPV</a>:</p>
<blockquote>
<p>So my own conclusion is that default arguments (and overloading) still have some value (for non-critical DSLs) but you need to be very careful where you use them.</p>
</blockquote>
<p><a href="https://github.com/wartremover/wartremover/issues/116#issuecomment-51280344">Mark Hibberd on focussing on correct programs</a>:</p>
<blockquote>
<p>But the most troublesome part of this thread, is that almost all of the discussion is about what developers find “convenient” and aesthetically pleasing, when we should be asking how a language feature adds or removes from our ability to build robust, correct programs - and, as quickly as possible. When held in this light, default arguments do not hold up. They are a mere syntactic convenience - that does not help us with this goal. This might be ok, if they didn’t come with risk or issues, but even the gentler arguments in this thread should be enough to highlight their use in a linting tool - especially given their inherent lack of motivation to begin with.</p>
</blockquote>
<blockquote>
<p>But yeh. Everyone gets to live in their own teams codebases. I just prefer mine without these undue risks.</p>
</blockquote>
<p>So in summary:</p>
<ol style="list-style-type: decimal">
<li>Don’t use DPV in production code. This could lead to bugs that are hard to find</li>
<li>Possibly use DPV in non-production code like such as test DSLs</li>
<li>If DPV helps to reduce the number of methods or the complexity of your solution, consider using it but be aware of the consequences. Alternatively redesign your code so it does not require DPV.</li>
</ol>]]></description>
    <pubDate>Wed, 01 May 2019 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2019-05-01-why-are-default-parameter-values-considered-bad-in-scala.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>

    </channel>
</rss>
