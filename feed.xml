<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>BabylonCandle</title>
        <link>http://blog.ssanj.net</link>
        <description><![CDATA[The blog of Sanjiv Sahayam]]></description>
        <atom:link href="http://blog.ssanj.net/feed.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sat, 13 Jun 2020 00:00:00 UT</lastBuildDate>
        <item>
    <title>contravariant functors are Weird</title>
    <link>http://blog.ssanj.net/posts/2020-06-13-contravariant-functors-are-weird.html</link>
    <description><![CDATA[<p>Just a note about nomenclature before we start; I’ll use “functor” to represent the <a href="https://bartoszmilewski.com/2015/01/20/functors/">categorical meaning</a> of the concept:</p>
<blockquote>
<p>A functor is a mapping between categories</p>
</blockquote>
<p>and <code>Functor</code> and <code>Contravariant</code> to specify the typeclass encodings of functors.</p>
<hr />
<p>Let’s begin!</p>
<p>contravariant functors are odd aren’t they? covariant functors are so straightforward but <strong>contra</strong>variant functors as their name implies are the complete opposite.</p>
<p>Before we get into what a contravariant functor is, it’s useful to look at the Functor <a href="https://wiki.haskell.org/Typeclassopedia">typeclass</a> which we know and love.</p>
<h1 id="functor">Functor</h1>
<p>A Functor is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>We often understand a <code>Functor</code> to be a “container” or a “producer” of some type, where the function supplied to <code>fmap</code> is applied to the elements that are “contained” or “produced” in some type constructor<a href="#type-constructor-1"><sup>1</sup></a> <code>f</code>.</p>
<p>A simple example would be the list (<code>[]</code>) type, that can represent zero or more values. Given a <code>[a]</code> we can turn it into a <code>[b]</code> when given a function <code>a -&gt; b</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">data</span> [] a <span class="fu">=</span> [] <span class="fu">|</span> a <span class="fu">:</span> [a]  <span class="co">-- an approximation of the [] data type</span>

<span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span>
  fmap _ [] <span class="fu">=</span> []
  fmap f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> fmap f xs</code></pre></div>
<p>In the example below we convert a <code>[Int]</code> into a <code>[String]</code> given a function <code>Int -&gt; String</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Semigroup</span> ((&lt;&gt;))

<span class="ot">myInts ::</span> [<span class="dt">Int</span>]
myInts <span class="fu">=</span> [<span class="dv">1</span> <span class="fu">..</span> <span class="dv">5</span>]

<span class="ot">emptyInts ::</span> [<span class="dt">Int</span>]
emptyInts <span class="fu">=</span> []

<span class="ot">intToString ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
intToString n <span class="fu">=</span> (show n) <span class="fu">&lt;&gt;</span> <span class="st">&quot;!&quot;</span>

<span class="ot">myStrings ::</span> [<span class="dt">String</span>]
myStrings <span class="fu">=</span> fmap intToString myInts <span class="co">-- [&quot;1!&quot;,&quot;2!&quot;,&quot;3!&quot;,&quot;4!&quot;,&quot;5!&quot;]</span>

<span class="ot">myEmptyString ::</span> []
myEmptyString <span class="fu">=</span> fmap intToString emptyInts  <span class="co">-- []</span></code></pre></div>
<p>Another example would the <code>Maybe</code> data type, that represents a value that may or may not exist.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  fmap _ <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Nothing</span>
  fmap f (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Just</span> (f x)</code></pre></div>
<p>In the example below we convert a <code>Maybe Int</code> into a <code>Maybe String</code> given a function <code>Int -&gt; String</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Semigroup</span> ((&lt;&gt;))

<span class="ot">maybeInt ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
maybeInt <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">10</span>

<span class="ot">notInt ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
notInt <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="ot">intToString ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
intToString n <span class="fu">=</span> (show n) <span class="fu">&lt;&gt;</span> <span class="st">&quot;!&quot;</span>

<span class="ot">maybeString ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
maybeString <span class="fu">=</span> fmap intToString maybeInt <span class="co">-- Just &quot;10!&quot;</span>

<span class="ot">notString ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
notString <span class="fu">=</span> fmap intToString notInt <span class="co">-- Nothing</span></code></pre></div>
<p>The <code>Functor</code> typeclass has laws, that ensure <code>Functor</code> instances behave in a predictable way.</p>
<h2 id="laws">Laws</h2>
<h3 id="identity">Identity</h3>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">fmap id <span class="fu">==</span> id</code></pre></div>
<p>Essentially if you do nothing to the value of a <code>Functor</code>, you get the same <code>Functor</code> you started with.</p>
<h3 id="composition">Composition</h3>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">fmap (f <span class="fu">.</span> g) <span class="fu">==</span> fmap f <span class="fu">.</span> fmap g</code></pre></div>
<p>If you convert the result of a Functor by <code>fmap</code>ing with a function <code>g</code> and then <code>fmap</code>ing that result with a subsequent function <code>f</code>, it’s the same as composing functions <code>g</code> and <code>f</code> (<code>f . g</code>) and then <code>fmap</code>ing once.</p>
<div class="figure">
<img src="/images/contravariant/functor-laws-ct.png" alt="Functor Laws" />
<p class="caption">Functor Laws</p>
</div>
<h2 id="the-wrong-type-of-fmap">The Wrong Type of fmap</h2>
<p>Now let’s look at something a little different. Let’s create a data type to wrap a predicate of some sort. A predicate is something that will evaluate to a <code>Bool</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Predicate</span> a <span class="fu">=</span> <span class="dt">Predicate</span> {<span class="ot"> getPredicate ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> }</code></pre></div>
<p>An example of a Predicate is <strong>greaterThanTen</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">greaterThanTen ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span>
greaterThanTen <span class="fu">=</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">10</span>)</code></pre></div>
<p>that tests whether a number is greater than ten.</p>
<p>We can run with it <strong>getPredicate</strong> and an <code>Int</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">getPredicate greateThanTen <span class="dv">5</span>  <span class="co">-- False</span>
getPredicate greateThanTen <span class="dv">11</span> <span class="co">-- True</span></code></pre></div>
<p>It could be useful to define a <code>Functor</code> instance for Predicate - say if we have a <code>Predicate Int</code> and we want to convert it into a <code>Predicate String</code> when we have a <code>Int -&gt; String</code> function. Let’s try and implement that:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Predicate</span> <span class="kw">where</span>
  <span class="co">-- fmap (a -&gt; b) -&gt; Predicate a -&gt; Predicate b</span>
  fmap f (<span class="dt">Predicate</span> p) <span class="fu">=</span> <span class="dt">Predicate</span> (\b <span class="ot">-&gt;</span> undefined)
  fmap f (<span class="dt">Predicate</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)) <span class="fu">=</span> <span class="dt">Predicate</span> (\b <span class="ot">-&gt;</span> undefined)  <span class="co">-- expanding p</span>
  fmap (a <span class="ot">-&gt;</span> b) (<span class="dt">Predicate</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)) <span class="fu">=</span> <span class="dt">Predicate</span> (\b <span class="ot">-&gt;</span> undefined) <span class="co">-- expanding f</span></code></pre></div>
<p>Now we’ve run into a small problem:</p>
<blockquote>
<p>How do we compose (a -&gt; Bool) and (a -&gt; b) to give us a (b -&gt; Bool) ?</p>
</blockquote>
<p>We are given a <code>b</code> but we don’t have access to any functions that actually use a <code>b</code>.</p>
<p>The problem is that we can’t. It’s because of something called “polarity” of the type variable <code>a</code>. No <code>Functor</code> instance for you <code>Predicate</code>.</p>
<div class="figure">
<img src="/images/contravariant/sad-panda.png" alt="sad-panda by Nick Bluth" />
<p class="caption">sad-panda by <a href="https://thenounproject.com/nickbluth/collection/pandas">Nick Bluth</a></p>
</div>
<h1 id="polarity">Polarity</h1>
<p>Polarity is a way of representing <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">variance</a> using the position of type variables. Let’s take a simple function <code>a -&gt; b</code> as an example.</p>
<div class="figure">
<img src="/images/contravariant/function-polarity.png" alt="Function Polarity" />
<p class="caption">Function Polarity</p>
</div>
<p>If a type variable is in <strong>input</strong> position like <code>a</code> it is given a <strong>negative</strong> polarity. If it is in an <strong>output</strong> position like <code>b</code> then it is given a <strong>positive</strong> polarity.</p>
<p>These polarities map directly to variant types.</p>
<table>
<thead>
<tr class="header">
<th align="left">Polarity</th>
<th align="left">Variance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Positive</td>
<td align="left">Covariant</td>
</tr>
<tr class="even">
<td align="left">Negative</td>
<td align="left">Contravariant</td>
</tr>
<tr class="odd">
<td align="left">Both</td>
<td align="left">Invariant</td>
</tr>
</tbody>
</table>
<p>What this means is that <code>Functor</code>s (which are actually covariant functors) require a type constructor in a covariant position in order for you to define a <code>Functor</code> instance for that type.</p>
<p>Let’s look at a type that we know has a <code>Functor</code> instance like <code>Maybe</code>:</p>
<div class="figure">
<img src="/images/contravariant/maybe-polarity.png" alt="Polarity of the Maybe data type" />
<p class="caption">Polarity of the Maybe data type</p>
</div>
<p>We can see that the type variable <code>a</code> occurs in a covariant (or output) position within the definition of the <code>Just</code> constructor.</p>
<p>Now let’s look at the definition of <code>Predicate</code> data type:</p>
<div class="figure">
<img src="/images/contravariant/predicate-polarity.png" alt="Polarity of the Predicate data type" />
<p class="caption">Polarity of the Predicate data type</p>
</div>
<p>We can see that the type variable <code>a</code> occurs in a contravariant (or input) position. This indicates that we can’t create a (covariant) <code>Functor</code> instance for this data type.</p>
<p>But we want to map things! What do we do?</p>
<h1 id="contravariant">Contravariant</h1>
<p>Welcome the <code>Contravariant</code> typeclass to the stage! It’s defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Contravariant</span> f <span class="kw">where</span>
<span class="ot">  contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</code></pre></div>
<p>Snazzy! <code>Contravariant</code> also takes some kind of type constructor <code>f</code> just like <code>Functor</code> but it has this weirdly named <code>contramap</code> function instead of <code>fmap</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">     fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="co">-- Functor</span>
<span class="ot">contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a <span class="co">-- Contravariant</span>
                         <span class="fu">^^^</span></code></pre></div>
<p>If we read <code>fmap</code> as:</p>
<blockquote>
<p>If you have an <code>a</code> in some context and a function that takes that <code>a</code> and converts it to a <code>b</code>, I can give you a context with a <code>b</code> in it.</p>
</blockquote>
<p>we can then read <code>contramap</code> as:</p>
<blockquote>
<p>If you have a context that needs an <code>a</code> and a function that can convert <code>b</code>s to <code>a</code>s, I can give you a context that needs <code>b</code>s.</p>
</blockquote>
<p>But that probably doesn’t make much sense. So let’s try and look at this in terms of our non-<code>Functor</code>: <code>Predicate</code>. <code>Predicate</code> has a <strong>need</strong> for an <code>a</code>, which it then uses to tell if something about that <code>a</code> is True or False.</p>
<p>Let’s try and write a <code>Contravariant</code> instance for <code>Predicate</code> given that we know that the type <code>a</code> in <code>Predicate</code> occurs in an input position.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Predicate</span> <span class="kw">where</span>
  <span class="co">-- contramp (a -&gt; b) -&gt; f b -&gt; f a</span>
  contramap (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Predicate</span> b <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="co">-- substituting for `f` for Predicate</span>
  contramap aToB (<span class="dt">Predicate</span> bToBool) <span class="fu">=</span> <span class="dt">Predicate</span> (\a <span class="ot">-&gt;</span> undefined)</code></pre></div>
<p>Given that we have a function <code>a -&gt; b</code> and essentially a function of type <code>b -&gt; Bool</code> (wrapped inside a <code>Predicate b</code>), we can if given an <code>a</code>, convert it to a <code>b</code> using <code>aToB</code> and then give that <code>b</code> to <code>bToBool</code> to give us a <code>Bool</code>.</p>
<p>Here’s a slightly long-form implementation of the <code>Contravariant</code> instance for <code>Predicate</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Predicate</span> <span class="kw">where</span>
<span class="ot">  contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Predicate</span> b <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a
  contramap aToB (<span class="dt">Predicate</span> bToBool) <span class="fu">=</span>
    <span class="dt">Predicate</span> <span class="fu">$</span> \a <span class="ot">-&gt;</span>
      <span class="kw">let</span> b    <span class="fu">=</span> aToB a
          bool <span class="fu">=</span> bToBool b
      <span class="kw">in</span> bool</code></pre></div>
<div class="figure">
<img src="/images/contravariant/contramap-predicate.png" alt="contramap on Predicate" />
<p class="caption">contramap on Predicate</p>
</div>
<p>or more succinctly:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Predicate</span> <span class="kw">where</span>
<span class="ot">  contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Predicate</span> b <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a
  contramap f (<span class="dt">Predicate</span> b) <span class="fu">=</span> <span class="dt">Predicate</span> <span class="fu">$</span> b <span class="fu">.</span> f</code></pre></div>
<p>We can see from the definition of <code>Predicate a</code> that all we are doing is running the supplied function <code>f</code> <strong>before</strong> the function within <code>Predicate b</code>. The reason we do that is to adapt a new input type to match an existing input type to gain some functionality.</p>
<p>If we revisit the (covariant) <code>Functor</code> instance for <code>Maybe</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  fmap _ <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Nothing</span>
  fmap aToB (<span class="dt">Just</span> a) <span class="fu">=</span> <span class="dt">Just</span> (aToB a)</code></pre></div>
<p>we can see that the function <code>aToB</code> is run <strong>after</strong> we have a value of <code>a</code>. We do that to convert a result of some type to another type.</p>
<div class="figure">
<img src="/images/contravariant/fmap-maybe.png" alt="fmap on Maybe" />
<p class="caption">fmap on Maybe</p>
</div>
<p>These are the essential differences between covariant and contravariant functors:</p>
<table>
<thead>
<tr class="header">
<th align="left">Typeclass</th>
<th align="left">Function runs</th>
<th align="left">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Functor</td>
<td align="left">after</td>
<td align="left">Convert results</td>
</tr>
<tr class="even">
<td align="left">Contravariant</td>
<td align="left">before</td>
<td align="left">Adapt inputs</td>
</tr>
</tbody>
</table>
<p>Now that we know the essential difference between <code>Functor</code> and <code>Contravariant</code>, let’s look at how we can use <code>contramap</code> with our <code>Predicate</code> class.</p>
<p>Given that we already have a <code>Predicate</code> that determines whether a number is greater than ten:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">numGreaterThanTen ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span>
numGreaterThanTen <span class="fu">=</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">10</span>)</code></pre></div>
<p>say we want to write another <code>Predicate</code> that verifies that the length of String is greater than ten characters.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">strLengthGreaterThanTen ::</span> <span class="dt">Predicate</span> <span class="dt">String</span>
strLengthGreaterThanTen <span class="fu">=</span> <span class="dt">Predicate</span> (\s <span class="ot">-&gt;</span> (length s) <span class="fu">&gt;</span> <span class="dv">10</span>)</code></pre></div>
<p>Sure, that’s pretty contrived but bear with me. Let’s also say we have a <code>Person</code> data type and we want to know if a person’s name is over ten characters long - if so we consider that to be a long name.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> {<span class="ot"> personName ::</span> <span class="dt">String</span>,<span class="ot"> personAge ::</span> <span class="dt">Int</span> }

<span class="ot">personLongName ::</span> <span class="dt">Predicate</span> <span class="dt">Person</span>
personLongName <span class="fu">=</span> <span class="dt">Predicate</span> (\p <span class="ot">-&gt;</span> (length <span class="fu">.</span> personName <span class="fu">$</span> p) <span class="fu">&gt;</span> <span class="dv">10</span>)</code></pre></div>
<p>And we can run these <code>Predicate</code>s as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">getPredicate numGreaterThanTen <span class="dv">5</span> <span class="co">-- False</span>
getPredicate numGreaterThanTen <span class="dv">20</span> <span class="co">-- True</span>

getPredicate strLengthGreaterThanTen <span class="st">&quot;hello&quot;</span>       <span class="co">-- False</span>
getPredicate strLengthGreaterThanTen <span class="st">&quot;hello world&quot;</span> <span class="co">-- True</span>

getPredicate personLongName <span class="fu">$</span> <span class="dt">Person</span> <span class="st">&quot;John&quot;</span> <span class="dv">30</span>        <span class="co">-- False</span>
getPredicate personLongName <span class="fu">$</span> <span class="dt">Person</span> <span class="st">&quot;Bartholomew&quot;</span> <span class="dv">30</span> <span class="co">-- True</span></code></pre></div>
<p>And this is fine, but there’s some duplication across each of the <code>Predicate</code>s - namely the part where we compare a number to ten:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(\n <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">10</span>)  <span class="co">-- Int</span>
(\s <span class="ot">-&gt;</span> (length s) <span class="fu">&gt;</span> <span class="dv">10</span>) <span class="co">-- String</span>
(\p <span class="ot">-&gt;</span> (length <span class="fu">.</span> personName <span class="fu">$</span> p) <span class="fu">&gt;</span> <span class="dv">10</span>) <span class="co">-- Person</span></code></pre></div>
<p>It would be nice if we didn’t have to repeat ourselves.</p>
<p>If we look at the differences between <code>numGreaterThanTen</code>, <code>strLengthGreaterThanTen</code> and <code>personLongName</code> we can see that the only difference is that one works on an <code>Int</code> and the others work on <code>String</code> and <code>Person</code> respectively. <code>strLengthGreaterThanTen</code> and <code>personLongName</code> each convert their input types to an <code>Int</code> and then do the same comparison:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="dt">Predicate</span> (\(<span class="ot">n ::</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span>
  <span class="kw">let</span> num <span class="fu">=</span> id n
  <span class="kw">in</span> num <span class="fu">&gt;</span> <span class="dv">10</span> <span class="co">-- (1)</span>
) <span class="co">-- numGreaterThanTen</span>


<span class="dt">Predicate</span> (\(<span class="ot">s ::</span> <span class="dt">String</span>) <span class="ot">-&gt;</span>
  <span class="kw">let</span> num <span class="fu">=</span> length s
  <span class="kw">in</span> num <span class="fu">&gt;</span> <span class="dv">10</span> <span class="co">-- (1)</span>
) <span class="co">-- strLengthGreaterThanTen</span>

<span class="dt">Predicate</span> (\(<span class="ot">p ::</span> <span class="dt">Person</span>) <span class="ot">-&gt;</span>
  <span class="kw">let</span> name <span class="fu">=</span> personName p
      num  <span class="fu">=</span> length name
  <span class="kw">in</span> num <span class="fu">&gt;</span> <span class="dv">10</span> <span class="co">-- (1)</span>
) <span class="co">-- personLongName</span></code></pre></div>
<p>The above expansion of the functions demonstrates that even though the <code>Predicate</code>s themselves have different input types, at the end they are all converted to a number which is compared against the number ten. This is tagged with <code>(1)</code> in the above example.</p>
<p>We can also see that the only changes between the <code>Predicate</code>s is the conversion from one type to another <strong>before</strong> running our comparison function <code>(1)</code>. This is our clue that we can use <code>contramap</code> here to reuse some functionality.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">numGreaterThanTen ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span>
numGreaterThanTen <span class="fu">=</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">10</span>)

<span class="ot">strLengthGreaterThanTen2 ::</span> <span class="dt">Predicate</span> <span class="dt">String</span>
strLengthGreaterThanTen2 <span class="fu">=</span> contramap length numGreaterThanTen <span class="co">-- convert the String to an Int, then pass it to numGreaterThanTen</span>

<span class="ot">personLongName2 ::</span> <span class="dt">Predicate</span> <span class="dt">Person</span>
personLongName2 <span class="fu">=</span> contramap (length <span class="fu">.</span> personName) numGreaterThanTen <span class="co">-- convert the Person to an Int, then pass it to numGreaterThanTen</span></code></pre></div>
<p>We get the same results as before:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">getPredicate strLengthGreaterThanTen2 <span class="st">&quot;hello&quot;</span>       <span class="co">-- False</span>
getPredicate strLengthGreaterThanTen2 <span class="st">&quot;hello world&quot;</span> <span class="co">-- True</span>

getPredicate personLongName2 <span class="fu">$</span> <span class="dt">Person</span> <span class="st">&quot;John&quot;</span> <span class="dv">30</span>        <span class="co">-- False</span>
getPredicate personLongName2 <span class="fu">$</span> <span class="dt">Person</span> <span class="st">&quot;Bartholomew&quot;</span> <span class="dv">30</span> <span class="co">-- True</span></code></pre></div>
<p>Now we have rewritten <code>strLengthGreaterThanTen</code> and <code>personLongName</code> in terms of <code>numGreaterThanTen</code> by just running a function before it to convert the types. This is a simple example of a Contravariant Functor where we can reuse some existing functionality for a given type if we can convert from our other types to that type through some mapping function.</p>
<p>We can also go a little further and reuse even more:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">personLongName3 ::</span> <span class="dt">Predicate</span> <span class="dt">Person</span>
personLongName3 <span class="fu">=</span> contramap personName strLengthGreaterThanTen <span class="co">-- convert the Person to a String, then pass it to strLengthGreaterThanTen</span></code></pre></div>
<h2 id="laws-1">Laws</h2>
<p>Just like <code>Functor</code> has laws, <code>Contravariant</code> also has laws. This is awesome - because laws make our lives easier.</p>
<h3 id="identity-1">Identity</h3>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">contramap id <span class="fu">==</span> id</code></pre></div>
<p>Essentially if you do not change the value of a <code>Contravariant</code> functor, you get the same <code>Contravariant</code> functor you started with.</p>
<h3 id="composition-1">Composition</h3>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">contramap f <span class="fu">.</span> contramap g <span class="fu">=</span> contramap (g <span class="fu">.</span> f)</code></pre></div>
<p>If you convert the input to some <code>Contravariant</code> functor by <code>contramap</code>ing with function <code>g</code> and then convert its input to some other type by <code>contramap</code>ing again with a function <code>f</code>, it’s the same as composing the functions <code>f</code> and <code>g</code> (<code>g . f</code>) and then <code>contramap</code>ing once. Notice the order of composition is switched as opposed to when we looked at the <code>Functor</code> laws.</p>
<div class="figure">
<img src="/images/contravariant/contravariant-laws-ct.png" alt="Contravariant Laws" />
<p class="caption">Contravariant Laws</p>
</div>
<p>Let’s take <code>Predicate</code> as an example and try out the identity law. The <code>Contravariant</code> instance for <code>Predicate</code> is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"> <span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Predicate</span> <span class="kw">where</span>
<span class="ot">   contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a
   contramap f (<span class="dt">Predicate</span> p) <span class="fu">=</span> <span class="dt">Predicate</span> (p <span class="fu">.</span> f)</code></pre></div>
<p>Given that we have a <code>Predicate Int</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">numGreaterThanTen ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span>
numGreaterThanTen <span class="fu">=</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">10</span>)</code></pre></div>
<p>Using <code>contramap id</code> on the above:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- identity law</span>
contramap id numGreaterThanTen <span class="fu">==</span> numGreaterThanTen

<span class="co">-- lhs</span>
<span class="dt">Predicate</span> (p <span class="fu">.</span> f) <span class="co">-- applying contramap</span>
<span class="dt">Predicate</span> (p <span class="fu">.</span> id) <span class="co">-- expanding f</span>
<span class="dt">Predicate</span> (p) <span class="co">-- applying f</span>
<span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">10</span>) <span class="co">-- expanding p</span>

<span class="co">-- rhs</span>
numGreaterThanTen
<span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">10</span>) <span class="co">-- expanding numGreaterThanTen</span>

<span class="co">-- equality</span>
lhs                      <span class="fu">==</span> rhs
<span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">10</span>) <span class="fu">==</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">10</span>)</code></pre></div>
<p>Once again using <code>Predicate</code> as an example, let’s explore the compositional law of <code>Contravariant</code>.</p>
<p>Given that we have the following <code>Predicate</code>s:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">numGreaterThanTen ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span>
numGreaterThanTen <span class="fu">=</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">10</span>)

length<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">personName ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<p>Using <code>numGreaterThanTen</code>, with <code>length</code> and <code>personName</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- composition law</span>
contramap personName <span class="fu">.</span> contramap length <span class="fu">$</span> numGreaterThanTen <span class="fu">=</span> contramap (length <span class="fu">.</span> personName) numGreaterThanTen


<span class="co">-- lhs</span>
contramap personName <span class="fu">.</span> contramap length <span class="fu">$</span> numGreaterThanTen
contramap personName <span class="fu">.</span> contramap length <span class="fu">$</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">10</span>) <span class="co">-- expanding numGreaterThanTen</span>
contramap personName (<span class="dt">Predicate</span> <span class="fu">$</span> \str <span class="ot">-&gt;</span>
  <span class="kw">let</span> num  <span class="fu">=</span> length str
     bool  <span class="fu">=</span> num <span class="fu">&gt;</span> <span class="dv">10</span>
  <span class="kw">in</span> bool
) <span class="co">-- applying length</span>
<span class="dt">Predicate</span> <span class="fu">$</span> \person <span class="ot">-&gt;</span>
  <span class="kw">let</span> str <span class="fu">=</span> personName person
      num <span class="fu">=</span> length str
     bool <span class="fu">=</span> num <span class="fu">&gt;</span> <span class="dv">10</span>
  <span class="kw">in</span> bool
) <span class="co">-- applying personName</span>
<span class="ot">=&gt;</span> <span class="dt">Predicate</span> <span class="dt">Person</span>

<span class="co">-- rhs</span>
contramap (length <span class="fu">.</span> personName) numGreaterThanTen
contramap (\person <span class="ot">-&gt;</span>
    <span class="kw">let</span> str <span class="fu">=</span> personName person
        num <span class="fu">=</span> length str
    <span class="kw">in</span> num
) numGreaterThanTen <span class="co">-- expanding length . personName</span>
<span class="dt">Predicate</span> (\person <span class="ot">-&gt;</span>
   <span class="kw">let</span> str  <span class="fu">=</span> personName person
       num  <span class="fu">=</span> length str
       bool <span class="fu">=</span> num <span class="fu">&gt;</span> <span class="dv">10</span> <span class="co">-- expanding numGreaterThanTen</span>
   <span class="kw">in</span> bool
)
<span class="ot">=&gt;</span> <span class="dt">Predicate</span> <span class="dt">Person</span>

<span class="co">-- equality</span>
lhs <span class="fu">==</span> rhs

<span class="dt">Predicate</span> (\person <span class="ot">-&gt;</span>
  <span class="kw">let</span> str  <span class="fu">=</span> personName person
      num  <span class="fu">=</span> length str
      bool <span class="fu">=</span> num <span class="fu">&gt;</span> <span class="dv">10</span>
  <span class="kw">in</span> bool

) <span class="fu">==</span>
<span class="dt">Predicate</span> (\person <span class="ot">-&gt;</span>
   <span class="kw">let</span> str  <span class="fu">=</span> personName person
       num  <span class="fu">=</span> length str
       bool <span class="fu">=</span> num <span class="fu">&gt;</span> <span class="dv">10</span>
   <span class="kw">in</span> bool
)</code></pre></div>
<h2 id="combinators">Combinators</h2>
<p>There are some built-in combinators that go with <code>Contravariant</code>.</p>
<h3 id="infix-contramap">Infix contramap</h3>
<p>Similar to the <code>contramap</code> function the following functions can be used infix:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- infixl 4</span>
<span class="ot">(&gt;$&lt;)        ::</span> <span class="dt">Contravariant</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a
<span class="co">-- contramap :: Contravariant f =&gt; (a -&gt; b) -&gt; f b -&gt; f a</span></code></pre></div>
<p>A simple example of it in use:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">p5 ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span>
p5 <span class="fu">=</span> <span class="dt">Predicate</span> <span class="fu">$</span> \n <span class="ot">-&gt;</span> n <span class="fu">==</span> <span class="dv">5</span>

<span class="ot">pLength5 ::</span> <span class="dt">Predicate</span> [a]
pLength5 <span class="fu">=</span> length <span class="fu">&gt;$&lt;</span> p5

getPredicate pLength5 <span class="st">&quot;hello&quot;</span>
<span class="co">-- True</span>

getPredicate pLength5 <span class="st">&quot;hello world&quot;</span>
<span class="co">-- False</span></code></pre></div>
<p>Same as <code>contramap</code> but with the parameters switched:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- infixl 4</span>
<span class="ot">(&gt;$$&lt;)       ::</span> <span class="dt">Contravariant</span> f <span class="ot">=&gt;</span> f b      <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a
<span class="co">-- contramap :: Contravariant f =&gt; (a -&gt; b) -&gt; f b      -&gt; f a</span></code></pre></div>
<h3 id="infix-const">Infix const</h3>
<p>These combinators take in a constant input and completely ignore the input supplied when running the <code>Contravariant</code> instance.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- infixl 4</span>
<span class="ot">(&gt;$) ::</span> b <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</code></pre></div>
<p>It has a default implementation of:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">(&gt;$) ::</span> b <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a
(<span class="fu">&gt;$</span>) <span class="fu">=</span> contramap <span class="fu">.</span> const</code></pre></div>
<p>Let’s see how that works:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- const when given two values returns the first value ignoring the second</span>
const<span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a
const x _ <span class="fu">=</span>  x

<span class="ot">contramap ::</span> <span class="dt">Contravariant</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a

<span class="ot">(&gt;$) ::</span> b <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a
(<span class="fu">&gt;$</span>)      <span class="fu">=</span> contramap <span class="fu">.</span> const
(<span class="fu">&gt;$</span>) b    <span class="fu">=</span> contramap (const b)   <span class="co">-- simplifying with b</span>
(<span class="fu">&gt;$</span>) b    <span class="fu">=</span> contramap (a <span class="ot">-&gt;</span> b)    <span class="co">-- applying `const b`</span>
(<span class="fu">&gt;$</span>) b fb <span class="fu">=</span> contramap (a <span class="ot">-&gt;</span> b) fb <span class="co">-- simplifying with fb</span>
(<span class="fu">&gt;$</span>) b fb <span class="fu">=</span> fa                    <span class="co">-- simplifying `contramap (a -&gt; b) fb`</span></code></pre></div>
<p>A simple example of it in use:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">p5 ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span>
p5 <span class="fu">=</span> <span class="dt">Predicate</span> <span class="fu">$</span> \n <span class="ot">-&gt;</span> n <span class="fu">==</span> <span class="dv">5</span>

<span class="ot">pLength5 ::</span> <span class="dt">Predicate</span> [a]
pLength5 <span class="fu">=</span> contramap length p5

getPredicate pLength5 <span class="st">&quot;hello&quot;</span>
<span class="co">-- True</span>

getPredicate pLength5 <span class="st">&quot;hello world&quot;</span>
<span class="co">-- False</span>

<span class="ot">pAlwaysFalse ::</span> <span class="dt">Predicate</span> [a]
pAlwaysFalse <span class="fu">=</span> <span class="dv">10</span> <span class="fu">&gt;$</span> p5

getPredicate pAlwaysFalse <span class="st">&quot;hello&quot;</span>
<span class="co">-- False (because 10 /= 5)</span>

getPredicate pAlwaysFalse <span class="st">&quot;hello world&quot;</span>
<span class="co">-- False</span></code></pre></div>
<p>Same as above but with the parameters switched:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- infixl 4</span>
<span class="ot">($&lt;) ::</span> <span class="dt">Contravariant</span> f <span class="ot">=&gt;</span> f b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> f a</code></pre></div>
<h2 id="logaction">LogAction</h2>
<p>Let’s look at another example of <code>Contravariant</code>. Imagine you have the following data type that encapsulates performing some side effect on some polymorphic type <code>a</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">LogAction</span> a <span class="fu">=</span> <span class="dt">LogAction</span> {<span class="ot"> unlog ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> () }</code></pre></div>
<p>For our purposes we can assume that we are going to use this to log some value either to the console or to a file or some other medium. This example has been adapted from the <a href="https://github.com/kowainik/co-log/blob/master/co-log-core/src/Colog/Core/Action.hs#L105">LogAction</a> class of the <a href="https://kowainik.github.io/posts/2018-09-25-co-log">CO-LOG</a> logging library. Definitely check out the library for real-world uses of <code>Contravariant</code> and friends.</p>
<p>As we can see the type variable <code>a</code> occurs in input position so we should be able to define a <code>Contravariant</code> instance for it:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">LogAction</span> <span class="kw">where</span>
<span class="ot">  contramap ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">LogAction</span> a <span class="ot">-&gt;</span> <span class="dt">LogAction</span> b
  contramap bToA logActionA <span class="fu">=</span> <span class="dt">LogAction</span> <span class="fu">$</span> \b <span class="ot">-&gt;</span> unlog logActionA (bToA b)</code></pre></div>
<p>There should be no surprises here; we run the supplied function <code>bToA</code> on the input <em>before</em> passing it to the log action.</p>
<p>Here’s a slightly simplified implementation of the above:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">LogAction</span> <span class="kw">where</span>
  contramap f logActionA <span class="fu">=</span> <span class="dt">LogAction</span> <span class="fu">$</span> unlog logActionA <span class="fu">.</span> f</code></pre></div>
<p>So how can we use <code>LogAction</code>? Let’s define a couple of implementations:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">putStrLog ::</span> <span class="dt">LogAction</span> <span class="dt">String</span>
putStrLog <span class="fu">=</span> <span class="dt">LogAction</span> putStr

<span class="ot">putStrLnLog ::</span> <span class="dt">LogAction</span> <span class="dt">String</span>
putStrLnLog <span class="fu">=</span> <span class="dt">LogAction</span> putStrLn</code></pre></div>
<p><code>putStrLog</code> and <code>putStrLn</code> are just wrappers around <code>putStr</code> and <code>putStrLn</code> from <code>base</code>. Both log a String to the console, the difference being that <code>putStrLn</code> sends a newline character to the console after each call.</p>
<p>Here’s how we’d use <code>putStrLnLog</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">unlog putStrLnLog <span class="st">&quot;Hello World&quot;</span>
<span class="co">-- Hello World</span></code></pre></div>
<p>Remember that <code>LogAction</code> <em>needs</em> an <code>a</code> which in this case is a <code>String</code>.</p>
<p>Now because we have the power of contravariance, we should be able to log out other types if we can convert them to a <code>String</code>.</p>
<p>Here are some examples:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- simple function around contramap for LogAction</span>
<span class="ot">putStringlyLnLog ::</span> (a <span class="ot">-&gt;</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">LogAction</span> a
putStringlyLnLog f <span class="fu">=</span> contramap f putStrLnLog

<span class="co">-- Now we can log Ints</span>
<span class="ot">putStrLnInt ::</span> <span class="dt">LogAction</span> <span class="dt">Int</span>
putStrLnInt <span class="fu">=</span> putStringlyLnLog show

<span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> {<span class="ot"> name ::</span> <span class="dt">String</span>,<span class="ot"> age ::</span> <span class="dt">Int</span> }

<span class="co">-- custom String representation of Person</span>
<span class="ot">showPerson ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showPerson (<span class="dt">Person</span> name age) <span class="fu">=</span> <span class="st">&quot;Person(name:&quot;</span> <span class="fu">&lt;&gt;</span> name <span class="fu">&lt;&gt;</span> <span class="st">&quot;, age: &quot;</span> <span class="fu">&lt;&gt;</span> (show age) <span class="fu">&lt;&gt;</span> <span class="st">&quot;)&quot;</span>

<span class="co">-- Now we can log people</span>
<span class="ot">putStrLnPerson ::</span> <span class="dt">LogAction</span> <span class="dt">Person</span>
putStrLnPerson <span class="fu">=</span> putStringlyLnLog showPerson

<span class="co">-- custom String representation of Person that only displays age</span>
<span class="ot">showPersonAge ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showPersonAge person <span class="fu">=</span>  <span class="st">&quot;age: &quot;</span> <span class="fu">&lt;&gt;</span> (show <span class="fu">$</span> age person)

<span class="co">-- Additional Person LogAction which outputs only age</span>
<span class="ot">putStrLnPersonAge ::</span> <span class="dt">LogAction</span> <span class="dt">Person</span>
putStrLnPersonAge <span class="fu">=</span> putStringlyLnLog showPersonAge</code></pre></div>
<p>Here’s how we can run the above:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">unlog putStrLnInt <span class="dv">42</span>
<span class="co">-- 42</span>

unlog putStrLnPerson <span class="fu">$</span> <span class="dt">Person</span> <span class="st">&quot;Neelix&quot;</span> <span class="dv">60</span>
<span class="co">-- Person(name:Neelix, age: 60)</span>

unlog putStrLnPersonAge <span class="fu">$</span> <span class="dt">Person</span> <span class="st">&quot;Tuvok&quot;</span> <span class="dv">240</span>
<span class="co">-- age: 240</span></code></pre></div>
<p>We can see that <code>LogAction</code> for <code>Person</code>, <em>needs</em> a <code>Person</code> instance as input to perform the log action.</p>
<p>Something that might not be obvious is that we can also adapt an input type to itself. It’s not necessary to always convert from one type to another.</p>
<p>Here are some example functions which we can use with <code>contramap</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">hello ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
hello <span class="fu">=</span> (<span class="st">&quot;Hello&quot;</span> <span class="fu">&lt;&gt;</span>)

<span class="ot">there ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
there <span class="fu">=</span> (<span class="st">&quot;there&quot;</span> <span class="fu">&lt;&gt;</span>)

<span class="ot">doctor ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
doctor <span class="fu">=</span> (<span class="st">&quot;Doctor&quot;</span> <span class="fu">&lt;&gt;</span>)

<span class="ot">space ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
space <span class="fu">=</span> (<span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span>)</code></pre></div>
<p>Here’s how we compose the above functions into a <code>LogAction</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">putStrLnGreeting ::</span> <span class="dt">LogAction</span> <span class="dt">String</span>
putStrLnGreeting <span class="fu">=</span> contramap space <span class="fu">.</span> contramap doctor <span class="fu">.</span> contramap space <span class="fu">.</span> contramap there <span class="fu">.</span> contramap space <span class="fu">.</span> contramap hello <span class="fu">$</span> putStrLnLog</code></pre></div>
<p>Whoa! That’s even hard to read. What does it do? Remember from the second law of <code>Contravariant</code> that:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">contramap f <span class="fu">.</span> contramap g <span class="fu">=</span> contramap (g <span class="fu">.</span> f)</code></pre></div>
<p>Given that, we can rewrite our highly compositional <code>LogAction</code> like so:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">putStrLnGreeting ::</span> <span class="dt">LogAction</span> <span class="dt">String</span>
putStrLnGreeting <span class="fu">=</span> contramap  (hello <span class="fu">.</span> space <span class="fu">.</span> there <span class="fu">.</span> space <span class="fu">.</span> doctor <span class="fu">.</span> space) <span class="fu">$</span> putStrLnLog</code></pre></div>
<p>At least this is somewhat more readable - but the great thing is that knowing the laws helped us make our code more legible. But still - what does this do?</p>
<p>The trick is to remember that <code>Contravaraint</code> composition works in <strong>reverse</strong> to normal composition:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">contramap f <span class="fu">.</span> contramap g <span class="fu">=</span> contramap (g <span class="fu">.</span> f) <span class="co">-- notice the (g . f) instead of (f. g)</span></code></pre></div>
<p>This is how <code>putStrLnGreeting</code> is evaluated:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">putStrLnGreeting ::</span> <span class="dt">LogAction</span> <span class="dt">String</span>
putStrLnGreeting <span class="fu">=</span> contramap  (hello <span class="fu">.</span> space <span class="fu">.</span> there <span class="fu">.</span> space <span class="fu">.</span> doctor <span class="fu">.</span> space) <span class="fu">$</span> putStrLnLog

unlog putStrLnGreeting <span class="st">&quot;Switzer&quot;</span> <span class="co">-- run the logger with &quot;Switzer&quot; as the input</span>

<span class="co">-- the input is going to go through this sequence of functions:</span>
<span class="co">-- (hello . space . there . space . doctor . space)</span>

<span class="co">-- applying space</span>
<span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> <span class="dt">Switzer</span>
<span class="co">-- applying doctor</span>
<span class="st">&quot;Doctor&quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> <span class="dt">Switzer</span>
<span class="co">-- applying space</span>
<span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot;Doctor&quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> <span class="dt">Switzer</span>
<span class="co">-- applying there</span>
<span class="st">&quot;there&quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot;Doctor&quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> <span class="dt">Switzer</span>
<span class="co">-- applying space</span>
<span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot;there&quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot;Doctor&quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> <span class="dt">Switzer</span>
<span class="co">-- applying hello</span>
<span class="st">&quot;Hello&quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot;there&quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot;Doctor&quot;</span> <span class="fu">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> <span class="dt">Switzer</span>
<span class="co">-- final output:</span>
<span class="co">-- Hello there Doctor Switzer</span></code></pre></div>
<p>Let’s look at one more <code>LogAction</code> which might be interesting; One where we ignore the input and return some constant output:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">override ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
override value <span class="fu">=</span> const value</code></pre></div>
<p>A we mentioned previously, <code>const</code> is defined as <code>a -&gt; b -&gt; a</code>, where it accepts two inputs but returns the value of the first input (ignoring the second input).</p>
<p>Here’s how we use it with <code>LogAction</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">qPutStrLn ::</span><span class="dt">LogAction</span> <span class="dt">String</span>
qPutStrLn <span class="fu">=</span> contramap (override <span class="st">&quot;This is Q!!&quot;</span>) putStrLnLog

<span class="co">-- run it</span>
unlog qPutStrLn <span class="st">&quot;Picard J L&quot;</span>
<span class="co">-- This is Q!!</span></code></pre></div>
<p>Now if our memory serves, we should be able to do the same with <code>&gt;$</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">qPutStrLnOp ::</span> <span class="dt">LogAction</span> <span class="dt">String</span>
qPutStrLnOp <span class="fu">=</span> <span class="st">&quot;This is Q!!&quot;</span> <span class="fu">&gt;$</span> putStrLnLog

<span class="co">-- run it</span>
unlog qPutStrLnOp <span class="st">&quot;Sisko B L&quot;</span>
<span class="co">-- This is Q!!</span></code></pre></div>
<h2 id="equality-and-ordering">Equality and Ordering</h2>
<p>Now let’s look at two somewhat related concepts: equality and ordering</p>
<h3 id="equivalence">Equivalence</h3>
<p>Let’s imagine that we have a datatype called <code>Equivalence</code> that wraps an equality expression:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Equivalence</span> a <span class="fu">=</span> <span class="dt">Equivalence</span> {<span class="ot"> getEquivalence ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> }</code></pre></div>
<p>Given two values of type <code>a</code> the <code>getEquivalence</code> function will return a <code>Bool</code> indicating if they are equal or not.</p>
<p>Now we can see that both <code>a</code> type variables are in input position. Let’s define a <code>Contravariant</code> instance for it:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Equivalence</span> <span class="kw">where</span>
<span class="ot">  contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Equivalence</span> b <span class="ot">-&gt;</span> <span class="dt">Equivalence</span> a
  contramap aToB (<span class="dt">Equivalence</span> eqB1B2) <span class="fu">=</span> <span class="dt">Equivalence</span> <span class="fu">$</span> \a1 a2 <span class="ot">-&gt;</span>
    <span class="kw">let</span> b1 <span class="fu">=</span> aToB a1
        b2 <span class="fu">=</span> aToB a2
    <span class="kw">in</span> eqB1B2 b1 b2</code></pre></div>
<p>Something important to note is that the function we supply to <code>contramap</code> (<code>a -&gt; b</code>) is run on twice - once on each of the input parameters (<code>b</code>).</p>
<div class="figure">
<img src="/images/contravariant/equivalence-polarity.png" alt="Polarity of Equivalence" />
<p class="caption">Polarity of Equivalence</p>
</div>
<p>Given an <code>Equivalence</code> for <code>Int</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">intEq ::</span> <span class="dt">Equivalence</span> <span class="dt">Int</span>
intEq <span class="fu">=</span> <span class="dt">Equivalence</span> (<span class="fu">==</span>)</code></pre></div>
<p>We can run it as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">getEquivalence intEq <span class="dv">1</span> <span class="dv">2</span>
<span class="co">-- False</span>

getEquivalence intEq <span class="dv">1</span> <span class="dv">1</span>
<span class="co">-- True</span></code></pre></div>
<p>We can calculate the equivalence of other types using <code>contramap</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">strLengthEq ::</span> <span class="dt">Equivalence</span> <span class="dt">String</span>
strLengthEq <span class="fu">=</span> contramap length intEq

<span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> {<span class="ot"> name ::</span> <span class="dt">String</span>,<span class="ot"> age ::</span> <span class="dt">Int</span> }

<span class="ot">personAgeEq ::</span> <span class="dt">Equivalence</span> <span class="dt">Person</span> <span class="co">-- equality by age</span>
personAgeEq <span class="fu">=</span> contramap age intEq

<span class="ot">personNameLengthEq ::</span> <span class="dt">Equivalence</span> <span class="dt">Person</span> <span class="co">-- equality by length of name</span>
personNameLengthEq <span class="fu">=</span> contramap name strLengthEq</code></pre></div>
<p>Here’s how we can run the above:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- t1 = Person &quot;Tuvok1&quot; 240</span>
<span class="co">-- t2 = Person &quot;Tuvok2&quot; 340</span>
<span class="co">-- t3 = Person &quot;Neelix&quot; 60</span>
<span class="co">-- t4 = Person &quot;Janeway&quot; 40</span>

getEquivalence personAgeEq t1 t2
<span class="co">-- False</span>

getEquivalence personAgeEq t1 t1
<span class="co">-- True</span>

getEquivalence personAgeEq t2 t2
<span class="co">-- True</span>

getEquivalence personAgeEq t2 t3
<span class="co">-- False</span>

getEquivalence personNameLengthEq t1 t2
<span class="co">-- True</span>

getEquivalence personNameLengthEq t3 t4
<span class="co">-- False</span>

getEquivalence personNameLengthEq t1 t4
<span class="co">-- False</span></code></pre></div>
<h3 id="comparison">Comparison</h3>
<p>Let’s imagine that we have a datatype called <code>Comparison</code> that wraps a comparison expression:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Comparison</span> a <span class="fu">=</span> <span class="dt">Comparison</span> {<span class="ot"> getComparison ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span> }</code></pre></div>
<p>Given two values of type <code>a</code> the <code>getComparison</code> function will return an <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#t:Ordering">Ordering</a> (<code>LT</code>, <code>GT</code> or <code>EQ</code>) with respect to each other.</p>
<p>Now we can see that both <code>a</code> type variables are in input position as before. Let’s define a <code>Contravariant</code> instance for it:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Comparison</span> <span class="kw">where</span>
<span class="ot">  contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Comparison</span> b <span class="ot">-&gt;</span> <span class="dt">Comparison</span> a
  contramap aToB (<span class="dt">Comparison</span> cmpB1B2) <span class="fu">=</span> <span class="dt">Comparison</span> <span class="fu">$</span> \a1 a2 <span class="ot">-&gt;</span>
    <span class="kw">let</span> b1 <span class="fu">=</span> aToB a1
        b2 <span class="fu">=</span> aToB a2
    <span class="kw">in</span> cmpB1B2 b1 b2</code></pre></div>
<div class="figure">
<img src="/images/contravariant/comparison-polarity.png" alt="Polarity of Comparison" />
<p class="caption">Polarity of Comparison</p>
</div>
<p>We can see that the wrappers for <code>Equivalence</code> and <code>Comparison</code> are almost the same, as are their <code>Contravariant</code> instances.</p>
<p>Given a <code>Comparison</code> for Int as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">intCmp ::</span> <span class="dt">Comparison</span> <span class="dt">Int</span>
intCmp <span class="fu">=</span> <span class="dt">Comparison</span> compare</code></pre></div>
<p>We can run it as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">getComparison intCmp <span class="dv">1</span> <span class="dv">1</span>
<span class="co">-- EQ</span>

getComparison intCmp <span class="dv">1</span> <span class="dv">2</span>
<span class="co">-- LT</span>

getComparison intCmp <span class="dv">2</span> <span class="dv">1</span>
<span class="co">-- GT</span></code></pre></div>
<p>We can now calculate the comparison of other types using <code>contramap</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">strCmp ::</span> <span class="dt">Comparison</span> <span class="dt">String</span>
strCmp <span class="fu">=</span> contramap length intCmp

<span class="ot">personAgeCmp ::</span> <span class="dt">Comparison</span> <span class="dt">Person</span>
personAgeCmp <span class="fu">=</span> contramap age intCmp

<span class="ot">fstCmp ::</span> <span class="dt">Comparison</span> a <span class="ot">-&gt;</span> <span class="dt">Comparison</span> (a, b)
fstCmp compA <span class="fu">=</span> contramap fst compA</code></pre></div>
<p>Nothing new here. Let’s have a look at how to sort numbers. We use the <code>sortBy</code> function defined in <code>Data.List</code> from the <code>base</code> package:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">sortBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</code></pre></div>
<p>We can see from the <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:sortBy">sortBy</a> function definition that it can accept the data wrapped in the <code>Comparison</code> data type:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">sortBy        ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">getComparison ::</span>  a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span></code></pre></div>
<p>Sorting numbers with the above function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- unsortedNumbers = [3, 5, 1, 4, 2]</span>

<span class="co">-- ascending sort</span>
sortBy (getComparison intCmp) unsortedNumbers
<span class="co">-- [1,2,3,4,5]</span>

<span class="co">-- descending sort</span>
sortBy (flip <span class="fu">$</span> getComparison intCmp) unsortedNumbers
<span class="co">-- [5,4,3,2,1]</span></code></pre></div>
<p>Notice how we just use the <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:flip">flip</a> function to change between ascending and descending sort:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">flip<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</code></pre></div>
<p><code>flip</code> just changes the order of input parameters. <code>flip</code> is awesome :) I saw this technique first used at <a href="https://ro-che.info/articles/2016-04-02-descending-sort-haskell">Roman Cheplyaka</a>’s blog.</p>
<p>But here’s something interesting: since we know how to sort <code>Int</code>s we also know how to sort people by age via <code>personAgeCmp</code>! Let’s see that in action:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- unsortedPeople = [Person &quot;Tuvok1&quot; 240, Person &quot;Janeway&quot; 40, Person &quot;Neelix&quot; 60]</span>

<span class="co">-- ascending sort</span>
sortBy (getComparison personAgeCmp) unsortedPeople
<span class="co">-- [Person {name = &quot;Janeway&quot;, age = 40},Person {name = &quot;Neelix&quot;, age = 60},Person {name = &quot;Tuvok1&quot;, age = 240}]</span>

<span class="co">-- descending sort</span>
sortBy (flip <span class="fu">$</span> getComparison personAgeCmp)
<span class="co">-- [Person {name = &quot;Tuvok1&quot;, age = 240},Person {name = &quot;Neelix&quot;, age = 60},Person {name = &quot;Janeway&quot;, age = 40}]</span></code></pre></div>
<h2 id="function-types">Function Types</h2>
<p>A regular function can be though of being defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RegularFunc</span> a b <span class="fu">=</span> <span class="dt">RegularFunc</span> {<span class="ot"> getRegular ::</span> a <span class="ot">-&gt;</span> b }</code></pre></div>
<p>We can define a <code>Functor</code> instance for <code>RegularFunc</code> because <code>b</code> is in output position. But what about <code>a</code>, which is in input position? More on that below.</p>
<p>Let’s recall what the definition of the <code>Functor</code> type class looks like:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>In the above declaration, <code>f</code> is a type constructor with one type hole. Given <code>RegularFunc</code> which has two type holes (<code>a</code> and <code>b</code>), we need to fill one in, in order to use it with the <code>Functor</code> instance implementation. To do this we fix <code>a</code> and get the type constructor <code>RegularFunc a</code>. We can’t fix <code>b</code> as partial application of types is done from left to right (holes can only be on the right).</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">RegularFunc</span> a) <span class="kw">where</span>
<span class="ot">  fmap ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c
  fmap <span class="fu">=</span> (<span class="fu">.</span>)</code></pre></div>
<p>We can’t define a <code>Contravariant</code> instance for <code>a</code> because we have to fix <code>a</code> (we can’t define behaviour over it). All we have to play with is <code>b</code> which is in output position (and hence covariant)</p>
<p>Oh! Come on! If only we didn’t have to fix <code>a</code>. What if we could fix <code>b</code> instead? We don’t care about <code>b</code>. <code>b</code> is dead to us.</p>
<p>Let’s dream up such a type and call it <code>Op</code> - for <strong>op</strong>posite of regular:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Op</span> a b <span class="fu">=</span> <span class="dt">Op</span> {<span class="ot"> getOp ::</span> b <span class="ot">-&gt;</span> a }</code></pre></div>
<p>Now we can see that the type <code>b</code> is in input position within the data type. It’s also on the right of <code>Op a b</code> which means we don’t have to fix it.</p>
<p><code>Op a b</code> can be a little confusing because we have switched the position of type parameters <code>a</code> and <code>b</code> as they were in <code>RegularFunc</code>; <code>a</code> is the output and <code>b</code> is the input.</p>
<table>
<thead>
<tr class="header">
<th align="left">Data type</th>
<th align="left">Polarity of a</th>
<th align="left">Polarity of b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RegularFunc a b</td>
<td align="left">Input</td>
<td align="left">Output</td>
</tr>
<tr class="even">
<td align="left">Op a b</td>
<td align="left">Output</td>
<td align="left">Input</td>
</tr>
</tbody>
</table>
<p>And guess what? We can now fix <code>a</code> (which is now our output) and can define a <code>Contravariant</code> instance for <code>Op</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Contravariant</span> (<span class="dt">Op</span> a) <span class="kw">where</span>
<span class="ot">  contramap ::</span> (c <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Op</span> a b <span class="ot">-&gt;</span> <span class="dt">Op</span> a c
  contramap cToB (<span class="dt">Op</span> bToA) <span class="fu">=</span> <span class="dt">Op</span> <span class="fu">$</span> \c <span class="ot">-&gt;</span>
    <span class="kw">let</span> b <span class="fu">=</span> cToB c
    <span class="kw">in</span> bToA b</code></pre></div>
<p>Here’s a simple example of how to use it:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">stringsLength ::</span> <span class="dt">Op</span> <span class="dt">Int</span> [<span class="dt">String</span>]
stringsLength <span class="fu">=</span> <span class="dt">Op</span> <span class="fu">$</span> sum <span class="fu">.</span> fmap length

<span class="ot">unqiueStringsLength ::</span> <span class="dt">Op</span> <span class="dt">Int</span> (<span class="dt">S.Set</span> <span class="dt">String</span>)
unqiueStringsLength <span class="fu">=</span> contramap S.toList stringsLength</code></pre></div>
<p>If we know how to sum all the lengths of a <code>[String]</code> we can adapt that function to sum the lengths of a <code>Set</code> of <code>String</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Set</span> (fromList)

namesList <span class="fu">=</span> [<span class="st">&quot;Paris&quot;</span>, <span class="st">&quot;Kim&quot;</span>, <span class="st">&quot;B&#39;Elanna&quot;</span>, <span class="st">&quot;Seven&quot;</span>]
namesSet  <span class="fu">=</span> fromList namesList

getOp stringsLength <span class="fu">$</span> namesList
<span class="co">-- 21</span>

getOp unqiueStringsLength <span class="fu">$</span> namesSet
<span class="co">-- 21</span></code></pre></div>
<p>Now <code>Predicate</code>, <code>Comparison</code>, <code>Equivalence</code> and <code>Op</code> seem like useful data structures. The good news is that they already exist in the <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Functor-Contravariant.html">Data.Functor.Contravariant</a> package from <code>base</code> so you don’t have to write them yourself.</p>
<p>One interesting implementation detail of the <code>Comparison</code> and <code>Equivalence</code> <code>Contravariant</code> instances is that they are implemented using the <code>on</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Equivalence</span> a <span class="fu">=</span> <span class="dt">Equivalence</span> {<span class="ot"> getEquivalence ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> }

<span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Equivalence</span> <span class="kw">where</span>
  contramap f g <span class="fu">=</span> <span class="dt">Equivalence</span> <span class="fu">$</span> on (getEquivalence g) f</code></pre></div>
<p>The <code>on</code> function is <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/src/Data.Function.html#on">defined</a> as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">on ::</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
(<span class="fu">.*.</span>) <span class="ot">`on`</span> f <span class="fu">=</span> \x y <span class="ot">-&gt;</span> f x <span class="fu">.*.</span> f y</code></pre></div>
<p>Essentially given a function <code>b -&gt; b -&gt; c</code> and a function <code>a -&gt; b</code>, the second function will be applied to each input of type <code>a</code> converting it to a <code>b</code> and then the first function is applied on the transformed inputs. Such reuse. :)</p>
<h1 id="more-polarity">More Polarity</h1>
<p>Let’s take a look at the <code>CallbackRunner</code> example from <a href="https://tech.fpcomplete.com/blog/2016/11/covariance-contravariance/">FP Complete</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">CallbackRunner</span> a <span class="fu">=</span>
  <span class="dt">CallbackRunner</span> {
<span class="ot">    runCallback ::</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
  }</code></pre></div>
<p>Type variable <code>a</code> is in input position so we should be able to write a <code>Contravariant</code> instance for it:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">CallbackRunner</span> <span class="kw">where</span>
<span class="ot">  contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">CallbackRunner</span> b <span class="ot">-&gt;</span> <span class="dt">CallbackRunner</span> a
  contramap aToB (<span class="dt">CallbackRunner</span> runCallbackB) <span class="fu">=</span> <span class="dt">CallbackRunner</span> <span class="fu">$</span> \aToIO <span class="ot">-&gt;</span>
    runCallbackB <span class="fu">$</span> \b <span class="ot">-&gt;</span>
      <span class="kw">let</span> a <span class="fu">=</span> undefined <span class="co">-- where do we get an `a` from?</span>
      <span class="kw">in</span> aToIO a

<span class="co">-- if we had a (b -&gt; a) we could convert the `b` to an `a`</span></code></pre></div>
<p>Hmm. Now it looks like we have a problem. There doesn’t seem to anyway for us to get an <code>a</code> to pass to <code>aToIO</code> to complete the implementation. We have a <code>b</code> and if there was a function <code>b -&gt; a</code> instead of our <code>a -&gt; b</code>, we could convert that <code>b</code> to an <code>a</code> and it would all work.</p>
<p>This is because there’s more to the polarity story than I’ve shared up until now. While <code>a</code> is in input position in <code>a -&gt; IO()</code>, it’s polarity changes when it’s also used as an input to the function <code>(a -&gt; IO ()) -&gt; IO ()</code>. I <a href="#Polarity">previously mentioned</a> that an input position is a <code>negative</code> polarity and an output position is a <code>positive</code> polarity.</p>
<p>To figure out the final polarity of something we need to multiply its polarities at every context it is used within in the function definition. More on this below.</p>
<p>Polarity multiplication is similar to the multiplication of positive and negative numbers:</p>
<h2 id="polarity-multiplication-table">Polarity Multiplication Table</h2>
<table>
<thead>
<tr class="header">
<th align="left">Polarity1</th>
<th align="left">x</th>
<th align="left">Polarity2</th>
<th align="left">Polarity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Positive</td>
<td align="left">x</td>
<td align="left">Positive</td>
<td align="left">Positive</td>
</tr>
<tr class="even">
<td align="left">Positive</td>
<td align="left">x</td>
<td align="left">Negative</td>
<td align="left">Negative</td>
</tr>
<tr class="odd">
<td align="left">Negative</td>
<td align="left">x</td>
<td align="left">Positive</td>
<td align="left">Negative</td>
</tr>
<tr class="even">
<td align="left">Negative</td>
<td align="left">x</td>
<td align="left">Negative</td>
<td align="left">Positive</td>
</tr>
</tbody>
</table>
<p>Let’s try and figure out the polarity of <code>a</code> given our new found multiplication skills. Given <code>runCallback</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">runCallback ::</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p><code>a</code> is in input or negative position in:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>but within whole function it’s a slightly different story:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> () <span class="co">-- func</span>
x <span class="fu">=</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> ())      <span class="co">-- assigning (a -&gt; IO ()) to x in func</span>
x <span class="ot">-&gt;</span> <span class="dt">IO</span> ()            <span class="co">-- substituting x in func</span></code></pre></div>
<p>We can see that <code>x</code> in the above example is in input or negative position as well. Given that <code>x</code> is <code>a -&gt; IO ()</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">(a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="co">-- a -&gt; IO (a is negative)</span>
<span class="co">-- (a -&gt; IO ()) -&gt; IO () (the whole parenthesis are in negative position)</span>
<span class="co">-- polarity of a: negative * negative = positive</span></code></pre></div>
<div class="figure">
<img src="/images/contravariant/callbackRunner-polarity.png" alt="Polarity Multiplication" />
<p class="caption">Polarity Multiplication</p>
</div>
<p>Given that <code>a</code> is now in output or positive position, we should be able to write a <code>Functor</code> instance for it:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">CallbackRunner</span> <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">CallbackRunner</span> a <span class="ot">-&gt;</span> <span class="dt">CallbackRunner</span> b
  fmap aToB (<span class="dt">CallbackRunner</span> runCallbackA) <span class="fu">=</span> <span class="dt">CallbackRunner</span> <span class="fu">$</span> \bToIO <span class="ot">-&gt;</span>
    runCallbackA <span class="fu">$</span> \a <span class="ot">-&gt;</span>
      <span class="kw">let</span> b      <span class="fu">=</span> aToB a
          result <span class="fu">=</span> bToIO b
      <span class="kw">in</span> result</code></pre></div>
<p>And we can!! If you want to dig more into polarities there are some good exercises at the <a href="https://tech.fpcomplete.com/blog/2016/11/covariance-contravariance/">FP Complete article</a>.</p>
<h1 id="invariant-functors">Invariant Functors</h1>
<p>We briefly mentioned invariant functors when talking about <a href="#Polarity">Polarity</a> but never mentioned them again until now. The <code>Invariant</code> typeclass is the parent typeclass of both <code>Functor</code> and <code>Contravariant</code>)</p>
<div class="figure">
<img src="/images/contravariant/functor-hierarchy-aligned.png" alt="Simplified Functor Hierarchy" />
<p class="caption">Simplified Functor Hierarchy</p>
</div>
<p>Given that this post is quite long, I’m only going to mention that <code>Invariant</code> has both covariant and contravariant functions in its definition:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Invariant</span> f <span class="kw">where</span>
<span class="ot">  invmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>where <code>a -&gt; b</code> is the function to use if <code>f a</code> is a <code>Functor</code> and <code>b -&gt; a</code> is the function to use if <code>f a</code> is <code>Contravariant</code>.</p>
<p>I may write another article about invariant functors if I feel the need for it, but in the meantime <a href="http://oleg.fi/gists/posts/2017-12-23-functor-optics.html#t:Invariant">checkout</a> <a href="https://stackoverflow.com/questions/22103445/example-of-invariant-functor">these</a> <a href="https://cvlad.info/functor-of/">articles</a> to get you <a href="https://www.lesswrong.com/posts/KRb2x2RJjGbBMbE4M/my-functor-is-rich">started</a>.</p>
<h1 id="summary">Summary</h1>
<p>Hopefully this has shed some light onto contravariant functors and how they are used and how they can be implemented. In a future article I hope to cover <code>Divisible</code> and <code>Decidable</code> typeclasses that build up from <code>Contravariant</code>.</p>
<p>The <a href="https://github.com/ssanj/contravariant-functors">source</a> for this article can be found on Github.</p>
<p>A big “Thank You” to <a href="https://twitter.com/georgetalkscode">George Wilson</a> for inspiring me to dig deeper into this topic with his excellent <a href="#video">presentations</a> on Functors.</p>
<p>A big thanks also to <a href="https://twitter.com/andrewfnewman">Andrew Newman</a> who reviewed this article.</p>
<h1 id="links">Links</h1>
<h2 id="articles">Articles</h2>
<ul>
<li><a href="http://oleg.fi/gists/posts/2017-12-23-functor-optics.html#t:Contravariant">Functor Optics - Oleg’s Gists</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html">24 days of Hackage - Contravariant - Ocharles</a></li>
<li><a href="https://tech.fpcomplete.com/blog/2016/11/covariance-contravariance/">Covariance and Contravariance - FP Complete</a></li>
<li><a href="https://typeclasses.com/contravariance">Understanding Contravariance - Type classes</a></li>
<li><a href="https://kowainik.github.io/posts/2018-09-25-co-log">CO-LOG - Kowainik</a></li>
</ul>
<h2 id="video">Video</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=JZPXzJ5tp9w">The Extended Functor Family - George Wilson</a></li>
<li><a href="https://www.youtube.com/watch?v=IJ_bVVsQhvc&amp;t">Contravariant Functors - The Other Side of the Coin - George Wilson</a></li>
<li><a href="https://www.youtube.com/watch?v=OJtGECfksds">Fun with Profunctors - Phil Freeman</a></li>
<li><a href="https://www.youtube.com/watch?v=SxfZ_6ynhi0">A Fistful of Functors - Itamar Ravid</a></li>
</ul>
<h2 id="books">Books</h2>
<ul>
<li><a href="https://github.com/hmemcpy/milewski-ctfp-pdf">Category Theory for Programmers - Bartosz Milewski</a></li>
<li><a href="https://leanpub.com/thinking-with-types">Thinking in Types - Sandy Maguire</a></li>
</ul>
<h2 id="questions-and-answers">Questions and Answers</h2>
<ul>
<li><a href="https://www.reddit.com/r/haskell/comments/2p7toa/looking_for_an_abstraction_to_compose/">Looking for an abstraction to compose - Reddit</a></li>
<li><a href="https://www.reddit.com/r/haskelltil/comments/bqiyr9/datafunctorcontravariant_some_simple_applications/">datafunctorcontravariant some simple applications - Reddit</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/4rvtzy/what_is_the_motivation_behind_contravariant/">The motivation behind Contravariant - Reddit</a></li>
</ul>
<h2 id="packages">Packages</h2>
<ul>
<li><a href="http://hackage.haskell.org/package/contravariant-1.5.2">Contravariant Package</a></li>
</ul>
<h1 id="definitions">Definitions</h1>
<h2 id="type-constructor-1">Type constructor (1)</h2>
<p>A data type that needs one or more type variables to be fully defined.</p>
<p>For example, <code>Maybe</code> is a type constructor and <code>Maybe Int</code> is a type.</p>]]></description>
    <pubDate>Sat, 13 Jun 2020 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2020-06-13-contravariant-functors-are-weird.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Everything is Temporary</title>
    <link>http://blog.ssanj.net/posts/2020-06-03-everything-is-temporary.html</link>
    <description><![CDATA[<p>That’s easy to forget when enduring something challenging. Everything has its start and end. The lock down due to COVID-19, your health, your job, your friends and even your life. Everything. Remembering this stops you from stressing over every little inconvenience or taking your good fortune for granted.</p>
<p>The Zen parable about “The glass that is already broken” reminds us of this beautifully:</p>
<div>
<div class="quote">
“You see this goblet? For me this glass is already broken. I enjoy it. I drink out of it. It holds my water admirably, sometimes even reflecting the sun in beautiful patterns. If I should tap it, it has a lovely ring to it. But when I put this glass on a shelf and the wind knocks it over, or my elbow brushes it off the table and it falls to the ground and shatters, I say, ‘Of course.’ When I understand that this glass is already broken, every moment with it is precious. Every moment is just as it is, and nothing need be otherwise.”
</div>
<div class="attribution">
<a href="https://www.awakin.org/read/view.php?tid=2162">via Awakin.org</a>
</div>
</div>
<p>Enjoy every moment.</p>]]></description>
    <pubDate>Wed, 03 Jun 2020 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2020-06-03-everything-is-temporary.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Loading your Stack Project into GHCi</title>
    <link>http://blog.ssanj.net/posts/2020-05-20-loading-a-test-package-into-ghci-through-stack.html</link>
    <description><![CDATA[<p>Sometimes it’s quite useful to play around with functions and data types in your Stack project from within the GHCi. You can do this by simply running:</p>
<pre class="terminal scrollx"><code>stack ghci</code></pre>
<p>from the root of your Stack project.</p>
<p>This however does not include any test sources or dependencies you may have. To include those as well run:</p>
<pre class="terminal scrollx"><code>stack ghci --test --no-load</code></pre>]]></description>
    <pubDate>Wed, 20 May 2020 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2020-05-20-loading-a-test-package-into-ghci-through-stack.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>An even Easier Way to Define a Multiline Function in Haskell using GHCi</title>
    <link>http://blog.ssanj.net/posts/2020-05-20-an-even-easier-way-to-define-a-multiline-function-in-haskell-using-ghci.html</link>
    <description><![CDATA[<p>I previously blogged about <a href="https://sanj.ink/posts/2018-08-09-defining-a-multiline-function-in-haskell-using-ghci.html">Defining a multiline function in Haskell using Ghci</a>. The solution was somewhat cumbersome and while hunting around for other options, <a href="https://stackoverflow.com/questions/45362445/defining-function-signature-in-ghci">I came across what I consider to be the simplest way to write a multiline function in GHCi</a>.</p>
<p>From within GHCi, enclose your function between <code>:{</code> and <code>:}</code> strings.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="fu">:</span>{
<span class="ot">  printAfter ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
  printAfter delay <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="fu">$</span> (\d <span class="ot">-&gt;</span> <span class="st">&quot;waiting for &quot;</span> <span class="fu">++</span> d <span class="fu">++</span> <span class="st">&quot; microseconds&quot;</span>) <span class="fu">$</span> show delay
    Control.Concurrent.threadDelay delay
    putStrLn <span class="st">&quot;done&quot;</span>
<span class="fu">:</span>}</code></pre></div>
<p>If you can’t be bothered to add the opening and closing braces or you don’t need nice formatting, you can smash the whole function on one line by replacing every newline with a <code>;</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">printAfter ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (); printAfter delay <span class="fu">=</span> <span class="kw">do</span>; putStrLn <span class="fu">$</span> (\d <span class="ot">-&gt;</span> <span class="st">&quot;waiting for &quot;</span> <span class="fu">++</span> d <span class="fu">++</span> <span class="st">&quot; microseconds&quot;</span>) <span class="fu">$</span> show delay; Control.Concurrent.threadDelay delay;putStrLn <span class="st">&quot;done&quot;</span></code></pre></div>
<p>And that’s it!</p>]]></description>
    <pubDate>Wed, 20 May 2020 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2020-05-20-an-even-easier-way-to-define-a-multiline-function-in-haskell-using-ghci.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Following a Paginated API with Haskell and UnfoldrM</title>
    <link>http://blog.ssanj.net/posts/2020-01-07-following-a-paginated-api-with-haskell-and-unfoldrm.html</link>
    <description><![CDATA[<p>I’ve been using the <a href="https://developer.twitter.com/en.html">Twitter API</a> for <a href="https://github.com/ssanj/milo">Milo</a> - a little command line application that limits my interaction with Twitter, to a select few specific accounts and searches. As with most APIs that have a large number of results, the Twitter API is paginated and you need to keep supplying it with some manner of cursor when going from one page of results to the next.</p>
<p>For the purposes of Milo, I wanted to access the latest direct messages for my user. Unfortunately the call to get your direct messages may return multiple pages of “empty” results and a cursor to the next page of results. I wanted to navigate these empty results and grab the first page with any results that were not empty - essentially just the latest direct message(s).</p>
<p>An example of an empty result:</p>
<div class="sourceCode"><pre class="sourceCode json scrollx"><code class="sourceCode json"><span class="fu">{</span>
  <span class="dt">&quot;next_cursor&quot;</span><span class="fu">:</span> <span class="st">&quot;some_hash&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;events&quot;</span><span class="fu">:</span> <span class="ot">[]</span>
<span class="fu">}</span></code></pre></div>
<p>An example of a non-empty result:</p>
<div class="sourceCode"><pre class="sourceCode json scrollx"><code class="sourceCode json"><span class="fu">{</span>
  <span class="dt">&quot;next_cursor&quot;</span><span class="fu">:</span> <span class="st">&quot;some_hash&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;events&quot;</span><span class="fu">:</span> <span class="ot">[</span>
    <span class="fu">{</span> <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;110&quot;</span><span class="fu">,</span> <span class="dt">&quot;created_timestamp&quot;</span><span class="fu">:</span> <span class="st">&quot;5300&quot;</span><span class="fu">,</span> <span class="er">...</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="fu">{</span> <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;109&quot;</span><span class="fu">,</span> <span class="dt">&quot;created_timestamp&quot;</span><span class="fu">:</span> <span class="st">&quot;5200&quot;</span><span class="fu">,</span> <span class="er">...</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="fu">{</span> <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;108&quot;</span><span class="fu">,</span> <span class="dt">&quot;created_timestamp&quot;</span><span class="fu">:</span> <span class="st">&quot;5200&quot;</span><span class="fu">,</span> <span class="er">...</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="fu">{</span> <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;107&quot;</span><span class="fu">,</span> <span class="dt">&quot;created_timestamp&quot;</span><span class="fu">:</span> <span class="st">&quot;5200&quot;</span><span class="fu">,</span> <span class="er">...</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="fu">{</span> <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;106&quot;</span><span class="fu">,</span> <span class="dt">&quot;created_timestamp&quot;</span><span class="fu">:</span> <span class="st">&quot;5100&quot;</span><span class="fu">,</span> <span class="er">...</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="fu">{</span> <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;105&quot;</span><span class="fu">,</span> <span class="dt">&quot;created_timestamp&quot;</span><span class="fu">:</span> <span class="st">&quot;5100&quot;</span><span class="fu">,</span> <span class="er">...</span> <span class="fu">}</span><span class="ot">,</span>
    <span class="er">...</span>
  <span class="ot">]</span>
<span class="fu">}</span></code></pre></div>
<p>As we can see, the resulting Json payload has both the result (contents of the <code>events</code> field) and the cursor (<code>next_cursor</code>).</p>
<p><em>Please note that I use <a href="https://www.stackage.org/lts-14.20/package/aeson-1.4.6.0">Aeson</a> to convert the Json payload into the <code>DirectMessages</code> data type used in the example, but I have omitted the bindings for clarity. The full Milo source can be found on Github.</em></p>
<p>I initially came up with this solution:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="co">-- Wrapper around the hash return by the Twitter API</span>
<span class="kw">newtype</span> <span class="dt">Cursor</span> <span class="fu">=</span> <span class="dt">Cursor</span> {<span class="ot"> unCursor ::</span> <span class="dt">T.Text</span> } <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- Data type to hold the list of direct messages and the cursor (if any)</span>
<span class="co">-- Each DirectMessage maps to a single element in the `events` array</span>
<span class="kw">data</span> <span class="dt">DirectMessages</span> <span class="fu">=</span> <span class="dt">DirectMessages</span> {<span class="ot"> messages ::</span> [<span class="dt">DirectMessage</span>],<span class="ot"> cursorPosition ::</span> <span class="dt">Maybe</span> <span class="dt">T.Text</span> } <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- Function that returns the direct messages or an error</span>
<span class="ot">getDirectMessages ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DirectMessages</span>)
getDirectMessages <span class="fu">=</span> getMoreDirectMessages <span class="dt">Nothing</span>

<span class="co">-- Function that loops through the result pages using a cursor</span>
<span class="ot">getMoreDirectMessages ::</span> <span class="dt">Maybe</span> <span class="dt">Cursor</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DirectMessages</span>)
getMoreDirectMessages nextCursor <span class="fu">=</span> <span class="kw">do</span>
  dmsE <span class="ot">&lt;-</span> callTwitterApi nextCursor
  <span class="kw">case</span> dmsE <span class="kw">of</span>
    <span class="dt">Right</span> dms<span class="fu">@</span>(<span class="dt">DirectMessages</span> messageList (<span class="dt">Just</span> nextCursor&#39;)) <span class="ot">-&gt;</span> 
      <span class="kw">if</span> (null messageList) <span class="kw">then</span> <span class="co">-- if the messages are empty try to get more</span>
        <span class="kw">do</span>
          (fmap (combineDms dms)) <span class="fu">&lt;$&gt;</span> (getMoreDirectMessages (<span class="dt">Just</span> <span class="fu">.</span> <span class="dt">Cursor</span> <span class="fu">$</span> nextCursor&#39;))
      <span class="kw">else</span> pure <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> dms

    <span class="dt">Right</span> dms<span class="fu">@</span>(<span class="dt">DirectMessages</span> _ <span class="dt">Nothing</span>) <span class="ot">-&gt;</span> pure (<span class="dt">Right</span> dms) <span class="co">-- No more cursors so just stop</span>
    <span class="dt">Left</span> dmError <span class="ot">-&gt;</span> pure <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">$</span> dmError


<span class="co">-- Function that collates direct messages</span>
<span class="ot">combineDms ::</span> <span class="dt">DirectMessages</span> <span class="ot">-&gt;</span> <span class="dt">DirectMessages</span> <span class="ot">-&gt;</span> <span class="dt">DirectMessages</span>

<span class="co">-- Function that calls the Twitter API with the cursor (if any)</span>
<span class="ot">callTwitterApi ::</span> <span class="dt">Maybe</span> <span class="dt">Cursor</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DirectMessages</span>)</code></pre></div>
<p>Now while this works it has a few problems:</p>
<ol style="list-style-type: decimal">
<li>It does not look very reusable, which it should be because pagination is a common problem</li>
<li>There are dangling error cases where we just lift the error into some outer context</li>
</ol>
<p>At this point I recalled seeing a function called <code>unfold</code> somewhere that produced values until some exit condition was reached. I decided to track it down. I found <a href="http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#g:9">unfoldr</a> which sort of fitted what I needed.</p>
<h2 id="unfoldr">unfoldr</h2>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldr ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (b, a)) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b]</code></pre></div>
<p>From the docs:</p>
<blockquote>
<p>The unfoldr function is a `dual’ to foldr: while foldr reduces a list to a summary value, unfoldr builds a list from a seed value. The function takes the element and returns Nothing if it is done producing the list or returns Just (b,a), in which case, b is a prepended to the list and a is used as the next element in a recursive call.</p>
</blockquote>
<p>This sounded promising. I needed to keep “producing” direct message results and stop as soon as I got some results that were not empty. Unfortunately I needed to work within an effect (<code>IO</code>) which this function did not support.</p>
<p>In any event let’s try and understand how this function works. This is the implementation of the the <code>unfoldr</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldr      ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (b, a)) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b]
unfoldr f a  <span class="fu">=</span>
  <span class="kw">case</span> f a <span class="kw">of</span>
   <span class="dt">Just</span> (b,new_a) <span class="ot">-&gt;</span> b <span class="fu">:</span> unfoldr f new_a
   <span class="dt">Nothing</span>        <span class="ot">-&gt;</span> []</code></pre></div>
<p>Given some generator function <code>f</code> that takes a value of type <code>a</code>, call <code>f</code> with <code>a</code> which returns a <code>Maybe</code> with a pair of values consisting of a result <code>b</code> and the next value of <code>a</code> to feed into the same function. The <code>Maybe</code> is either a <code>Just</code> value with a new result <code>b</code> and the next value of <code>a</code>: <code>new_a</code>. In this case the result <code>b</code> is prepended to a list of results which will be generated by recursively calling the <code>unfoldr</code> function with <code>f</code> and <code>new_a</code>. In the <code>Nothing</code> case return an empty List.</p>
<p>Here’s a simple example that produces numbers from 1 to 10 and then stops:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span> (unfoldr)

unfoldr (\a <span class="ot">-&gt;</span> <span class="kw">if</span> a <span class="fu">&lt;</span> <span class="dv">11</span> <span class="kw">then</span> <span class="dt">Just</span> (a, a <span class="fu">+</span> <span class="dv">1</span>) <span class="kw">else</span> <span class="dt">Nothing</span>) <span class="dv">1</span>
<span class="fu">&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</code></pre></div>
<p>Pretty neat but not what I exactly needed.</p>
<p>After some more digging around I stumbled across a library called <a href="http://hackage.haskell.org/package/monad-loops">monad-loops</a> which had what I was after.</p>
<h2 id="unfoldrm">unfoldrM</h2>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldrM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> (b, a))) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m [b]</code></pre></div>
<p>We can see from its function definition that it’s exactly the same as <code>unfoldr</code> except the intermediate and final results are within some <code>Monad m</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldrM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> (b, a))) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m [b]
<span class="ot">unfoldr  ::</span>            (a <span class="ot">-&gt;</span>    <span class="dt">Maybe</span> (b, a))  <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span>   [b]</code></pre></div>
<p>This is the implementation of the <code>unfoldrM</code> function (which is an alias to <code>unfoldrM'</code>):</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldrM&#39; ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadPlus</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> (b,a))) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m (f b)
unfoldrM&#39; f <span class="fu">=</span> go
    <span class="kw">where</span> go a <span class="fu">=</span> <span class="kw">do</span>
            x <span class="ot">&lt;-</span> f a
            <span class="kw">case</span> x <span class="kw">of</span>
                <span class="dt">Nothing</span>         <span class="ot">-&gt;</span> return mzero
                <span class="dt">Just</span> (b, new_a)    <span class="ot">-&gt;</span> <span class="kw">do</span>
                        rest <span class="ot">&lt;-</span> go new_a
                        return (return b <span class="ot">`mplus`</span> rest)</code></pre></div>
<p>The implementation is very similar to <code>unfoldr</code> with differences due to the selected effect type <code>m</code> and result type <code>f</code>.</p>
<p>Given some generator function <code>f</code> that takes a value of type <code>a</code>, it calls <code>f</code> with <code>a</code> within a <code>do</code> block. It returns a <code>Maybe</code> with a pair of values; the result <code>b</code> and the next value of type <code>a</code>: <code>new_a</code>, within a context <code>m</code>. It extracts and pattern matches on the contextual result. If it’s a <code>Nothing</code> it returns the default value for the <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:MonadPlus">MonadPlus</a> type <code>f</code> (<code>mzero</code>). If the result is a <code>Just</code>, it creates a nested <code>do</code> block and recurses with the <code>new_a</code> value to extract the final result <code>rest</code>. It then combines the <code>rest</code> with the previous result <code>b</code> according to the <code>mplus</code> implementation for the <code>MonadPlus</code> type <code>f</code> and returns the results in the context <code>m</code>. <code>unfoldrM</code> is a specialized version of <code>unfoldrM'</code> where <code>f</code> is a <code>[]</code>.</p>
<h2 id="the-solution">The solution</h2>
<p>Now while this seemed to be what I needed it took a little while for me to understand how to use it in my use case. One thing that stumped me was why the initial value <code>a</code> was not a <code>Maybe</code>. Surely the first time I called the Twitter API, I would not have a cursor, so how could I represent it as an <code>a</code>? Even if I did make <code>a</code> a <code>Maybe a</code>, how would I distinguish between the initial call where I had no cursor and the final call where I would also have no cursor?!</p>
<p>My friend <a href="http://twitter.com/ajfitzpatrick">Adam</a> stated the obvious so I could understand it:</p>
<blockquote>
<p>Maybe does not satisfy your requirements because you need more than two states</p>
</blockquote>
<p>Oh dear! Was I supposed to create some ADT with three states? I thought this was supposed to be some plug-and-play solution and it was turning out not to be.</p>
<p>I started off by creating the ADT for the states:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- | An ADT to capture the three states of a cursor:</span>
<span class="kw">data</span> <span class="dt">CursorState</span> a 
    <span class="fu">=</span> <span class="dt">NewCursor</span>           <span class="co">-- NewCursor - Initial cursor state</span>
    <span class="fu">|</span> <span class="dt">GoCursor</span> (<span class="dt">Cursor</span> a) <span class="co">-- GoCursor - A state of having a cursor, typically used for iteration</span>
    <span class="fu">|</span> <span class="dt">StopCursor</span>          <span class="co">-- StopCursor - The final cursor state</span></code></pre></div>
<p>Now if I plug in my types into the <code>unfoldrM</code> function I get the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">unfoldrM (a <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> (b, a))) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m [b]
<span class="co">-- &#39;a&#39; is CursorState c</span>
<span class="co">-- &#39;c&#39; is the type of cursor data</span>
<span class="ot">unfoldrM ::</span> (<span class="dt">CursorState</span> c <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c))) <span class="ot">-&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span> m [b]
<span class="co">-- &#39;m&#39; is IO</span>
<span class="ot">unfoldrM ::</span> (<span class="dt">CursorState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c ))) <span class="ot">-&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> [b]
<span class="co">-- &#39;b&#39; is DirectMessages</span>
<span class="ot">unfoldrM ::</span> (<span class="dt">CursorState</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> (<span class="dt">DirectMessages</span>, <span class="dt">CursorState</span> c))) <span class="ot">-&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">DirectMessages</span>]</code></pre></div>
<p>Now this seems to make sense.</p>
<p>Given that I already had a function of type:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">callTwitterApi ::</span> <span class="dt">Maybe</span> <span class="dt">Cursor</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DirectMessages</span>)</code></pre></div>
<p>How could I convert it to work with the above function definition?</p>
<p>I could define a function <code>unfoldWith</code> as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldWith ::</span> forall m b c<span class="fu">.</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span>  m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c))
unfoldWith <span class="dt">NewCursor</span> <span class="fu">=</span> undefined
unfoldWith (<span class="dt">GoCursor</span> (<span class="dt">Cursor</span> nextCursor)) <span class="fu">=</span> undefined
unfoldWith <span class="dt">StopCursor</span> <span class="fu">=</span> undefined</code></pre></div>
<p>The simplest one to define is the <code>StopCursor</code> variant:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldWith ::</span> forall m b c<span class="fu">.</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span>  m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c))
unfoldWith <span class="dt">NewCursor</span> <span class="fu">=</span> undefined
unfoldWith (<span class="dt">GoCursor</span> (<span class="dt">Cursor</span> nextCursor)) <span class="fu">=</span> undefined
unfoldWith <span class="dt">StopCursor</span> <span class="fu">=</span> pure <span class="dt">Nothing</span></code></pre></div>
<p>and that compiles!</p>
<p>Next I can tried to implement the <code>NewCursor</code> variant:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldWith ::</span> forall m b c<span class="fu">.</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span>  m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c))
unfoldWith <span class="dt">NewCursor</span> <span class="fu">=</span> undefined <span class="co">-- I need to be able to use callTwitterApi here</span>
unfoldWith (<span class="dt">GoCursor</span> (<span class="dt">Cursor</span> nextCursor)) <span class="fu">=</span> undefined
unfoldWith <span class="dt">StopCursor</span> <span class="fu">=</span> pure <span class="dt">Nothing</span></code></pre></div>
<p>generalising the <code>callTwitterApi</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">callTwitterApi ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DirectMessages</span>)
<span class="co">-- Since we need to reduce our Monad to an m, wrap the IO (Either String) in ExceptT</span>
<span class="co">-- ExceptT String IO is &#39;m&#39; (Essentially a wrapped (IO Either String))</span>
<span class="co">-- DirectMessages is &#39;a&#39;</span>
<span class="ot">callTwitterApi ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">String</span> <span class="dt">IO</span> <span class="dt">DirectMessages</span>
<span class="co">-- which simplifies to:</span>
<span class="ot">callTwitterApi ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> m <span class="dt">DirectMessages</span>

<span class="co">-- Now we should be able to define any API that gets some `a` as:</span>
<span class="ot">someApi ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> m a

<span class="co">-- passing in someApi to unfoldWith</span>
<span class="ot">unfoldWith ::</span> forall m a b c<span class="fu">.</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span>  m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c))
unfoldWith f <span class="dt">NewCursor</span> <span class="fu">=</span> f <span class="dt">Nothing</span> <span class="co">-- call it with Nothing because we don&#39;t have a Cursor</span>
unfoldWith f (<span class="dt">GoCursor</span> (<span class="dt">Cursor</span> nextCursor)) <span class="fu">=</span> undefined
unfoldWith _ <span class="dt">StopCursor</span> <span class="fu">=</span> pure <span class="dt">Nothing</span></code></pre></div>
<p>So far so good. But now we need to extract the result and the next cursor from response of the api call. When we call <code>someApi</code> we get a <code>m a</code> in return:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">someApi ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> m a</code></pre></div>
<p><em>Note: To add type annotation to let expressions you need to enable the <code>ScopedTypeVariables</code> language extension</em>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></code></pre></div>
<p>We need a function that transforms that <code>a</code> into a pair of <code>(b, CursorState c)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">extractPayload ::</span> a <span class="ot">-&gt;</span> (b, <span class="dt">CusorState</span> c)</code></pre></div>
<p>passing that into our <code>unfoldWith</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldWith ::</span> forall m a b c<span class="fu">.</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> (b, <span class="dt">CursorState</span> c)) <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> <span class="dt">CursorState</span> c <span class="ot">-&gt;</span>  m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span> c))
unfoldWith extractPayload callApiWith <span class="dt">NewCursor</span> <span class="fu">=</span> 
  <span class="kw">let</span><span class="ot"> resultM ::</span> m a <span class="fu">=</span> callApiWith <span class="dt">Nothing</span>
  <span class="kw">in</span>  <span class="dt">Just</span> <span class="fu">.</span> extractPayload <span class="fu">&lt;$&gt;</span> resultM
unfoldWith extract callApiWith (<span class="dt">GoCursor</span> (<span class="dt">Cursor</span> nextCursor)) <span class="fu">=</span> undefined
unfoldWith _ _ <span class="dt">StopCursor</span> <span class="fu">=</span> pure <span class="dt">Nothing</span></code></pre></div>
<p>Seems to compile. Now we do the same of the <code>GoCursor</code> case:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">unfoldWith ::</span> forall m a b c<span class="fu">.</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> (b, <span class="dt">CursorState</span> c)) <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Cursor</span> c) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> <span class="dt">CursorState</span> <span class="ot">-&gt;</span>  m (<span class="dt">Maybe</span> (b, <span class="dt">CursorState</span>))
unfoldWith extractPayload callApiWith <span class="dt">NewCursor</span> <span class="fu">=</span> 
  <span class="kw">let</span><span class="ot"> resultM ::</span> m a <span class="fu">=</span> callApiWith <span class="dt">Nothing</span>
  <span class="kw">in</span>  <span class="dt">Just</span> <span class="fu">.</span> extractPayload <span class="fu">&lt;$&gt;</span> resultM
unfoldWith extract callApiWith (<span class="dt">GoCursor</span> (<span class="dt">Cursor</span> nextCursor)) <span class="fu">=</span> 
  <span class="kw">let</span><span class="ot"> resultM ::</span> m a <span class="fu">=</span> callApiWith (<span class="dt">Just</span> nextCursor)
  <span class="kw">in</span>  <span class="dt">Just</span> <span class="fu">.</span> extractPayload <span class="fu">&lt;$&gt;</span> resultM
unfoldWith _ _ <span class="dt">StopCursor</span> <span class="fu">=</span> pure <span class="dt">Nothing</span></code></pre></div>
<p>A <code>DirectMessages</code> is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DirectMessages</span> <span class="fu">=</span> <span class="dt">DirectMessages</span> {<span class="ot"> messages ::</span> [<span class="dt">DirectMessage</span>],<span class="ot"> cursorPosition ::</span> <span class="dt">Maybe</span> <span class="dt">T.Text</span> } <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>And now I just define a function that takes in a <code>DirectMessages</code> type and returns a pair of <code>([DirectMessage], CursorState T.Text)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="ot">extractState ::</span> <span class="dt">DirectMessages</span> <span class="ot">-&gt;</span> ([<span class="dt">DirectMessage</span>], <span class="dt">CursorState</span> <span class="dt">T.Text</span>)
extractState (<span class="dt">DirectMessages</span> [] (<span class="dt">Just</span> c)) <span class="fu">=</span> ([], <span class="dt">GoCursor</span> (<span class="dt">Cursor</span> c)) <span class="co">-- No messages, but we have a cursor, then try to get more</span>
extractState (<span class="dt">DirectMessages</span> [] <span class="dt">Nothing</span>)  <span class="fu">=</span> ([], <span class="dt">StopCursor</span>)          <span class="co">-- No messages and no cursor, then stop</span>
extractState (<span class="dt">DirectMessages</span> msgs _)  <span class="fu">=</span> (msgs, <span class="dt">StopCursor</span>)            <span class="co">-- Messages so we can stop irrespective of the cursor</span></code></pre></div>
<p>Now I can call <code>unfoldrM</code> with:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Control.Monad.Except</span> <span class="kw">as</span> <span class="dt">Ex</span>

<span class="ot">callTwitterApi ::</span> <span class="dt">Ex.ExceptT</span> <span class="dt">String</span> <span class="dt">IO</span> <span class="dt">DirectMessages</span>

<span class="ot">getDirectMessages ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DirectMessages</span>)
getDirectMessages <span class="fu">=</span> Ex.runExceptT <span class="fu">$</span> unfoldrM (unfoldWith extractState callTwitterApi) <span class="dt">NewCursor</span></code></pre></div>
<p>and we have pagination!</p>
<p><em>Note how we had to unwrap the <a href="https://www.stackage.org/haddock/lts-14.20/mtl-2.2.2/Control-Monad-Except.html#t:ExceptT">ExceptT</a> with <code>Ex.runExceptT</code> to retrieve the wrapped <code>IO (Either String DirectMessages)</code></em>.</p>
<p>The interesting point is that we now have a reusable function <code>unfoldWith</code> which we can use with any paginated API that returns us a payload with a result and a cursor.</p>
<h2 id="a-simpler-example">A Simpler Example</h2>
<p>If you got a little lost in the details of the above example, don’t worry. Here’s a simpler example to give you some intuition.</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="co">-- Payload type</span>
<span class="kw">data</span> <span class="dt">Packet</span> <span class="fu">=</span> <span class="dt">Packet</span> {<span class="ot"> value ::</span> <span class="dt">String</span>,<span class="ot"> cursor ::</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> <span class="dt">Int</span>) }

<span class="co">-- Function that mimicks a server response</span>
<span class="ot">serviceCall ::</span> forall m <span class="fu">.</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Cursor</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> m <span class="dt">Packet</span>
serviceCall <span class="dt">Nothing</span> <span class="fu">=</span> pure <span class="fu">$</span> <span class="dt">Packet</span> <span class="st">&quot;packet one&quot;</span> (<span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Cursor</span> <span class="dv">1</span>)
serviceCall (<span class="dt">Just</span> (<span class="dt">Cursor</span> cur))
  <span class="fu">|</span> cur <span class="fu">==</span> <span class="dv">1</span>  <span class="fu">=</span> pure <span class="fu">$</span> <span class="dt">Packet</span> <span class="st">&quot;packet two&quot;</span>   (<span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Cursor</span> <span class="dv">2</span>)
  <span class="fu">|</span> cur <span class="fu">==</span> <span class="dv">2</span>  <span class="fu">=</span> pure <span class="fu">$</span> <span class="dt">Packet</span> <span class="st">&quot;packet three&quot;</span> (<span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Cursor</span> <span class="dv">3</span>)
  <span class="fu">|</span> cur <span class="fu">==</span> <span class="dv">3</span>  <span class="fu">=</span> pure <span class="fu">$</span> <span class="dt">Packet</span> <span class="st">&quot;packet four&quot;</span>  (<span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Cursor</span> <span class="dv">4</span>)
  <span class="fu">|</span> otherwise <span class="fu">=</span> pure <span class="fu">$</span> <span class="dt">Packet</span> <span class="st">&quot;packet five&quot;</span>  <span class="dt">Nothing</span>

<span class="co">-- Function that splits the payload into a result and the next CursorState</span>
<span class="ot">extractState ::</span> <span class="dt">Packet</span> <span class="ot">-&gt;</span> (<span class="dt">String</span>, <span class="dt">CursorState</span> <span class="dt">Int</span>)
extractState (<span class="dt">Packet</span> v (<span class="dt">Just</span> c)) <span class="fu">=</span> (v, <span class="dt">GoCursor</span> c)
extractState (<span class="dt">Packet</span> v <span class="dt">Nothing</span>)  <span class="fu">=</span> (v, <span class="dt">StopCursor</span>)</code></pre></div>
<p>As before we can use it with:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">unfoldrM (unfoldWith extractState serviceCall) <span class="dt">NewCursor</span></code></pre></div>
<p>Using the above to log out the first three page responses:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Loops</span> (unfoldrM)
<span class="kw">import </span><span class="dt">Data.List</span> (intercalate)

<span class="ot">run ::</span> <span class="dt">IO</span> ()
run <span class="fu">=</span> 
  <span class="kw">let</span><span class="ot"> resultsIO ::</span> <span class="dt">IO</span> [<span class="dt">String</span>] <span class="fu">=</span> unfoldrM (unfoldWith extractState serviceCall) <span class="dt">NewCursor</span>
<span class="ot">      stringyfied ::</span> <span class="dt">IO</span> <span class="dt">String</span> <span class="fu">=</span> (intercalate <span class="st">&quot;,&quot;</span> <span class="fu">.</span> take <span class="dv">3</span>) <span class="fu">&lt;$&gt;</span> resultsIO
  <span class="kw">in</span> stringyfied <span class="fu">&gt;&gt;=</span> putStrLn</code></pre></div>
<p>which prints out:</p>
<div class="sourceCode"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell">packet one,packet two,packet three</code></pre></div>
<p>I’m not sure if this is a “pattern” that people generally use but I can see myself using this for other paginated APIs.</p>
<p>The code for the <a href="https://github.com/ssanj/unfoldExample">Simpler Example</a>.</p>]]></description>
    <pubDate>Tue, 07 Jan 2020 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2020-01-07-following-a-paginated-api-with-haskell-and-unfoldrm.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Running Hoogle Locally for Haskell Dev</title>
    <link>http://blog.ssanj.net/posts/2019-10-19-running-hoogle-locally-for-haskell-dev.html</link>
    <description><![CDATA[<p><a href="https://www.stackage.org/">Stackage</a> is a neat tool to use when developing Software in Haskell. It’s integrated with the <a href="http://www.haskell.org/hoogle/">Hoogle</a> search engine that can search on type signatures (and function names) which lets you find almost any function easily.</p>
<p>One of the downsides of Hoogle is that it can be slow (at least for me from Australia) and so looking up any kind of documentation becomes a really frustrating experience.</p>
<p>The other issue with using Hoogle is that when you look up documentation for a function of a library that you use in a project, you need to make sure you are looking at the documentation for the exact version of that library that you are using in your <code>package.yml</code> or <code>.cabal</code> file; otherwise you maybe looking at an entirely different api and end up wasting a lot of time.</p>
<p>Stackage solves this by letting you search against a particular snapshot where all the versions of your libraries will be pinned against that snapshot (see the <em>resolver</em> field in <code>stackage.yaml</code>). But I find Stackage searches slow as well. :(</p>
<p>Wouldn’t it be nice if we could run Hoogle locally for our project with all the documentation we need available at our fingertips? What would be even better is that Hoogle was seeded with only the versions of dependencies in our project that we care about.</p>
<p>Well thanks to the fantastic <a href="https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/">An opinionated guide to Haskell in 2018</a> by <a href="https://lexi-lambda.github.io/resume.html">Alexis King</a> we now know how!</p>
<p>The basic steps are:</p>
<ol style="list-style-type: decimal">
<li>Generate Haddock documentation when you compile your project</li>
</ol>
<pre class="terminal scrollx"><code>stack test --fast --haddock-deps</code></pre>
<p>The first time you run this it can take a while.</p>
<ol start="2" style="list-style-type: decimal">
<li>Generate a local Hoogle database</li>
</ol>
<pre class="terminal scrollx"><code>stack hoogle -- generate --local</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>Run your local Hoogle server</li>
</ol>
<pre class="terminal scrollx"><code>stack hoogle -- server --local --port=8080</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>Profit</li>
</ol>
<p>You can get full access to your local Hoogle with:</p>
<pre class="terminal scrollx"><code>open localhost:8080</code></pre>
<p>or open the documentation of a specific library only:</p>
<pre class="terminal scrollx"><code>stack haddock --open lens</code></pre>
<p>Something to be aware of is that when you add new dependencies or change existing ones in your project you need to generate your local Hoogle database again:</p>
<blockquote>
<p>Unfortunately, you will have to manually regenerate the Hoogle database when you install new packages and their documentation, which you can do by re-running stack hoogle – generate –local. Fortunately, regenerating the database doesn’t take very long, as long as you’ve been properly rebuilding the documentation with –haddock-deps.</p>
</blockquote>
<p>This shouldn’t take too long though if you’ve been generating your Haddock as per step 1.</p>
<p>Thanks Alexis! You rock! :)</p>]]></description>
    <pubDate>Sat, 19 Oct 2019 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2019-10-19-running-hoogle-locally-for-haskell-dev.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Pretty Printing Json in Haskell</title>
    <link>http://blog.ssanj.net/posts/2019-09-24-pretty-printing-json-in-haskell.html</link>
    <description><![CDATA[<p>While working on <a href="https://github.com/ssanj/milo">Milo</a> - a small twitter client, I came across an issue where I wanted to dump the full response Json I received from the Twitter API to the console. While I could write this response out as a <code>String</code>, it was very hard to read as it was not nicely indented. I had to resort to copying this text into Sublime Text and pretty printing the Json there using a plugin. Certainly not ideal.</p>
<p>What would be nice is to be able to pretty print the Json content of the response directly to the console without the need for external tools. I got some hints on how to do it from <a href="https://onoffswitch.net/2015/08/15/adventures-pretty-printing-json-haskell/">Adventures in pretty printing JSON in haskell</a>.</p>
<p>To do this I first had to convert the response text into a Json value. I was using <a href="https://www.stackage.org/lts-14.3/package/aeson-1.4.4.0">Aeson</a> Json library in Haskell and all Json is presented by the <a href="https://www.stackage.org/haddock/lts-14.3/aeson-1.4.4.0/Data-Aeson.html#t:Value">Value</a> data type:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">Object</span> <span class="fu">!</span><span class="dt">Object</span>
           <span class="fu">|</span> <span class="dt">Array</span> <span class="fu">!</span><span class="dt">Array</span>
           <span class="fu">|</span> <span class="dt">String</span> <span class="fu">!</span><span class="dt">Text</span>
           <span class="fu">|</span> <span class="dt">Number</span> <span class="fu">!</span><span class="dt">Scientific</span>
           <span class="fu">|</span> <span class="dt">Bool</span> <span class="fu">!</span><span class="dt">Bool</span>
           <span class="fu">|</span> <span class="dt">Null</span></code></pre></div>
<p>The primary way to convert some type <code>a</code> to a <code>Value</code> is by the use of the <code>ToJSON</code> typeclass:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ToJSON</span> a <span class="kw">where</span>
    <span class="co">-- | Convert a Haskell value to a Json-friendly intermediate type.</span>
<span class="ot">    toJSON     ::</span> a <span class="ot">-&gt;</span> <span class="dt">Value</span>
    <span class="co">-- The rest of the class has been omitted for brevity</span></code></pre></div>
<p>While I had written conversions from some concrete types to a Json value, I did not have a way to convert from a <code>ByteString</code> (which was what was returned to me from the <a href="https://www.stackage.org/lts-14.3/package/http-client-0.6.4">http-client</a> library) to a Json <code>Value</code>. It seemed obvious that there should be an instance of <code>ToJSON</code> for <code>ByteString</code> - but there wasn’t. There were instances for <code>String</code> via <code>[Char]</code> and <code>Text</code> though and it seemed like the obvious way to make this conversion happen was by converting the <code>ByteString</code> to one of these two types.</p>
<p>I also came across the <a href="https://www.stackage.org/lts-14.3/package/aeson-pretty-0.8.7">aeson-pretty</a> library which pretty prints Json values. The <code>encodePretty</code> and <code>encodePretty'</code> functions looked of particular interest:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="ot">encodePretty ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span>

<span class="ot">encodePretty&#39; ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span></code></pre></div>
<p>In order to use one of the <code>encodePretty</code> functions I would have to find some way of converting the lazy <code>ByteString</code> (<code>LBS.ByteString</code>) into a <code>ToJSON</code> instance and then have it converted back into a <code>LBS.ByteString</code> by one of the <code>encodePretty</code> functions. A little weird to say the least.</p>
<p>So how do we convert a <code>LBS.ByteString</code> into a <code>ToJSON</code> value? Not surprisingly there is an instance of <code>TOJSON</code> for <code>Value</code> which just returns the supplied Json <code>Value</code>. This seems obvious in hindsight but had me stumped for a while. Given a Json <code>Value</code> we should be able to get a pretty-printed <code>LBS.ByteString</code> representation of that Json <code>Value</code> using one of the <code>encodePretty</code> functions:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="ot">jsonToText ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">LBS.ByteString</span>
jsonToText <span class="fu">=</span> encodePretty</code></pre></div>
<p>Now that we have a <code>LBS.ByteString</code> with our pretty Json content, we need to convert it to a format that can be printed out to the console.</p>
<p>But first a quick primer on a few different ways of representing Strings in Haskell:</p>
<ul>
<li>ByteStrings</li>
</ul>
<blockquote>
<p>A time and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. This has both lazy and strict variants.</p>
</blockquote>
<ul>
<li>Text</li>
</ul>
<blockquote>
<p>A time and space-efficient implementation of Unicode text. Suitable for performance critical use, both in terms of large data quantities and high speed. This also has lazy and strict variants.</p>
</blockquote>
<p>Given that Tweets use a lot of unicode characters for emojis, internationalisation and the like, using <code>Text</code> (Data.Text) seemed to be the best option for this conversion.</p>
<p>The <code>decodeUtf8</code> function in <code>Data.Text.Encoding</code> which is defined as:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="ot">decodeUtf8 ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></code></pre></div>
<p>seems useful and is in the general direction we want to go. Unfortunately it requires a strict <code>ByteString</code> and we need a way to convert from our <code>LBS.ByteString</code> into a strict one.</p>
<p>The <code>toStrict</code> function in <code>Data.ByteString.Lazy</code> which is defined as:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="ot">toStrict ::</span> <span class="dt">LSB.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span></code></pre></div>
<p>can handle the coversion for us.</p>
<p>Now that we have all the pieces we can convert from our lazy <code>ByteString</code> to <code>Text</code>:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Encoding</span> <span class="kw">as</span> <span class="dt">E</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">LBS</span>
<span class="kw">import </span><span class="dt">Data.Aeson.Encode.Pretty</span> (encodePretty)

<span class="ot">lsbToText ::</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
lsbToText <span class="fu">=</span> E.decodeUtf8 <span class="fu">.</span> LBS.toStrict

<span class="ot">jsonToText ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
jsonToText <span class="fu">=</span> lsbToText <span class="fu">.</span> encodePretty</code></pre></div>
<p><code>Data.Text.IO</code> has the <code>Text</code> equivalent of <code>putStrLn</code> and <code>putStr</code> for <code>String</code>:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell">putStr<span class="ot">   ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
putStrLn<span class="ot"> ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>We can use these functions so that we don’t need to convert between <code>String</code> and <code>Text</code> to print out our Json content.</p>
<p>Here’s the final code to write out pretty Json:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Encoding</span> <span class="kw">as</span> <span class="dt">E</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">LBS</span>
<span class="kw">import </span><span class="dt">Data.Aeson.Encode.Pretty</span> (encodePretty)
<span class="kw">import qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">TIO</span>

<span class="ot">lsbToText ::</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
lsbToText <span class="fu">=</span> E.decodeUtf8 <span class="fu">.</span> LBS.toStrict

<span class="ot">jsonToText ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
jsonToText <span class="fu">=</span> lsbToText <span class="fu">.</span> encodePretty

<span class="ot">prettyPrint ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
prettyPrint <span class="fu">=</span> TIO.putStrLn <span class="fu">.</span> jsonToText</code></pre></div>
<p>With the sample Json of:</p>
<div class="sourceCode"><pre class="sourceCode scrollx haskell"><code class="sourceCode haskell"><span class="ot">tweetJson ::</span> <span class="dt">Value</span>
tweetJson <span class="fu">=</span> 
  object [
           <span class="st">&quot;created_at&quot;</span> <span class="fu">.=</span> <span class="dt">A.String</span> <span class="st">&quot;Wed Sep 18 01:28:16 +0000 2019&quot;</span>, 
           <span class="st">&quot;user&quot;</span> <span class="fu">.=</span> object [
                              <span class="st">&quot;screen_name&quot;</span> <span class="fu">.=</span> <span class="dt">A.String</span> <span class="st">&quot;tweetbot&quot;</span>, 
                              <span class="st">&quot;name&quot;</span> <span class="fu">.=</span> <span class="dt">A.String</span> <span class="st">&quot;The Twittebot&quot;</span> 
                           ],
           <span class="st">&quot;full_text&quot;</span> <span class="fu">.=</span> <span class="dt">A.String</span> <span class="st">&quot;this is a strange tweet&quot;</span>,
           <span class="st">&quot;lang&quot;</span> <span class="fu">.=</span> <span class="dt">A.String</span> <span class="st">&quot;en&quot;</span>
        ]</code></pre></div>
<p>The following output is printed:</p>
<div class="sourceCode"><pre class="sourceCode scrollx json"><code class="sourceCode json"><span class="fu">{</span>
    <span class="dt">&quot;user&quot;</span><span class="fu">:</span> <span class="fu">{</span>
        <span class="dt">&quot;screen_name&quot;</span><span class="fu">:</span> <span class="st">&quot;tweetbot&quot;</span><span class="fu">,</span>
        <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;The Twittebot&quot;</span>
    <span class="fu">},</span>
    <span class="dt">&quot;lang&quot;</span><span class="fu">:</span> <span class="st">&quot;en&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;created_at&quot;</span><span class="fu">:</span> <span class="st">&quot;Wed Sep 18 01:28:16 +0000 2019&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;full_text&quot;</span><span class="fu">:</span> <span class="st">&quot;this is a strange tweet&quot;</span>
<span class="fu">}</span></code></pre></div>]]></description>
    <pubDate>Tue, 24 Sep 2019 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2019-09-24-pretty-printing-json-in-haskell.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Using Validated for Error Accumulation in Scala with Cats</title>
    <link>http://blog.ssanj.net/posts/2019-08-18-using-validated-for-error-accumulation-in-scala-with-cats.html</link>
    <description><![CDATA[<p>The <code>Either</code> data type allows us to represent a computation that may fail. A simplified definition of an <code>Either</code> is given below:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Either[+A, +B]
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Left[+A, +B](value: A) <span class="kw">extends</span> Either[A, B]
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Right[+A, +B](value: B) <span class="kw">extends</span> Either[A, B]</code></pre></div>
<p>We use the two data constructors of Either to represent an error or a success. We wrap an error in the <code>Left</code> constructor or a successful value in the <code>Right</code> constructor. Let’s look at a simple example to make that clearer.</p>
<p>Say we want to validate a person’s name, age and email address. We could use the following ADT (algebraic data type) to do that:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">sealed</span> <span class="kw">trait</span> PersonErrorType
  <span class="kw">case</span> <span class="kw">object</span> NameInvalid <span class="kw">extends</span> PersonErrorType
  <span class="kw">case</span> <span class="kw">object</span> AgeInvalid <span class="kw">extends</span> PersonErrorType
  <span class="kw">case</span> <span class="kw">object</span> EmailInvalid <span class="kw">extends</span> PersonErrorType

  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> <span class="fu">PersonError</span>(value: String, errorType: PersonErrorType)

  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Name(value: String)
  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Age</span>(value: Int)
  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Email</span>(value: String)

  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Person</span>(name: Name, age: Age, email: Email)</code></pre></div>
<p>The <code>PersonErrorType</code> models the various errors we may encounter during the creation of a <code>Person</code>and <code>PersonError</code> captures that error with some extra information as to why it failed. We also have wrapper classes around name, age and email to differentiate them from regular <code>String</code>s.</p>
<p>Now we could use an <code>Either</code> type, which has a <code>PersonError</code> on the <code>Left</code> and some valid type <code>A</code> on the <code>Right</code> to represent our validations. We define the type alias <code>ErrorOr</code> to represent this:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">type</span> ErrorOr[A] = Either[PersonError, A]</code></pre></div>
<p>Notice that in <code>ErrorOr</code>, the error type or the left-side of the <code>Either</code> is fixed to <code>PersonError</code> and we can only vary the success type or the right-side of the Either. This is represented by the type variable <code>A</code>. <code>A</code> could be any type.</p>
<p>We can imagine having three functions that represent validating our name, age and email address:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateName</span>(name: String): ErrorOr[Name] = ???
  
  <span class="kw">def</span> <span class="fu">validateAge</span>(age: String): ErrorOr[Age] = ???

  <span class="kw">def</span> <span class="fu">validateEmail</span>(email: String): ErrorOr[Email] = ???</code></pre></div>
<p>We will leave their definitions for a little later.</p>
<p>Notice that all the functions above return an <code>ErrorOr</code> with different types for the success value.</p>
<p>In addition we would need some kind of validation function that combines the above functions together to return a valid <code>Person</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validatePerson</span>(name: String, age: String, email: String): ErrorOr[Person] = ???</code></pre></div>
<p>Now let’s go ahead and implement the validation functions according to the following rules:</p>
<ol style="list-style-type: decimal">
<li>The supplied name must not be empty and has to start with an uppercase character.</li>
<li>The supplied age must be a number and must be between one and a hundred and twenty.</li>
<li>The supplied email address must not be empty and must have at least a single <code>@</code> character.</li>
</ol>
<p>Following is a sample implementation of the above rules:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateName</span>(name: String): ErrorOr[Name] = {
    <span class="kw">if</span> (name.<span class="fu">headOption</span>.<span class="fu">exists</span>(_.<span class="fu">isUpper</span>)) <span class="fu">Right</span>(Name(name))
    <span class="kw">else</span> <span class="fu">Left</span>(<span class="fu">PersonError</span>(s<span class="st">&quot;Name is empty or does not start with an uppercase character: $name&quot;</span>, NameInvalid))
  }
  
  <span class="kw">def</span> <span class="fu">validateAge</span>(age: String): ErrorOr[Age] = <span class="kw">for</span> {
    numericAge &lt;- <span class="fu">Try</span>(age.<span class="fu">toInt</span>).<span class="fu">toEither</span>.<span class="fu">left</span>.<span class="fu">map</span>(ex =&gt; <span class="fu">PersonError</span>(ex.<span class="fu">getMessage</span>, AgeInvalid))
    validAge &lt;- { 
      <span class="kw">if</span> (numericAge &lt;= <span class="dv">0</span> || numericAge &gt; <span class="dv">120</span>) <span class="fu">Left</span>(<span class="fu">PersonError</span>(s<span class="st">&quot;Age must be a number between 1-120: ${numericAge}&quot;</span>, AgeInvalid))
      <span class="kw">else</span> <span class="fu">Right</span>(numericAge)
    }
  } <span class="kw">yield</span> <span class="fu">Age</span>(validAge)

  
  <span class="kw">def</span> <span class="fu">validateEmail</span>(email: String): ErrorOr[Email] = {
    <span class="kw">if</span> (email.<span class="fu">isEmpty</span> || !email.<span class="fu">contains</span>(<span class="st">&quot;@&quot;</span>)) <span class="fu">Left</span>(<span class="fu">PersonError</span>(s<span class="st">&quot;Email address is empty or does not contain an `@` symbol: $email&quot;</span>, EmailInvalid))
    <span class="kw">else</span> <span class="fu">Right</span>(<span class="fu">Email</span>(email))
  }</code></pre></div>
<p>Don’t worry too much about the implementation.</p>
<p>Notice that we wrap the errors in a <code>PersonError</code> and put it in the <code>Left</code> constructor. Similarly we put the success values in the <code>Right</code> constructor. We also lift all success values into their wrapper types: <code>Name</code>, <code>Age</code> and <code>Email</code>.</p>
<p>Given the above validation implementations, how do we go about combining them to give us either a valid <code>Person</code> instance or an error of type <code>PersonError</code>?</p>
<p>Fortunately for us, the <code>Either</code> datatype implements both the <code>flatMap</code> and <code>map</code> methods which allows us to use a for-comprehension to sequence the validations we have:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validatePerson</span>(name: String, age: String, email: String): ErrorOr[Person] = <span class="kw">for</span> {
    validName   &lt;- <span class="fu">validateName</span>(name)
    validAge    &lt;- <span class="fu">validateAge</span>(age)
    validEmail  &lt;- <span class="fu">validateEmail</span>(email)
  } <span class="kw">yield</span> <span class="fu">Person</span>(validName, validAge, validEmail)</code></pre></div>
<p>Now given a valid name, age and email, the <code>validatePerson</code> function returns a <code>Right</code> with a <code>Person</code> instance:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">validatePerson</span>(<span class="st">&quot;Benjamin Sisko&quot;</span>, <span class="st">&quot;50&quot;</span>, <span class="st">&quot;b.sisko@dsn.st&quot;</span>)
<span class="co">//Right(Person(Name(Benjamin Sisko),Age(50),Email(b.sisko@dsn.st)))</span></code></pre></div>
<p>And it returns a <code>Left</code> with the first error of type <code>PersonError</code> for an invalid person:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">validatePerson</span>(<span class="st">&quot;odo&quot;</span>, <span class="st">&quot;200&quot;</span>, <span class="st">&quot;odo.founder.net&quot;</span>)
<span class="co">//Left(PersonError(Name is empty or does not start with an uppercase character: odo,NameInvalid))</span></code></pre></div>
<p>Now in the above invalid example, we can see that Odo’s age is not between one and a hundred and twenty and his email address does not have a single <code>@</code> character in it and would be invalid. Unfortunately <code>Either</code> bails on the first error and we don’t get to see what any of the other errors are. This could get annoying if we keep getting new errors each time we run this code.</p>
<p>What we want is to get all the errors returned to us at once. How do we do that?</p>
<h2 id="validated">Validated</h2>
<p>This is where we need to lean on the <a href="https://typelevel.org/cats/datatypes/validated.html">Validated</a> datatype. The <code>Validated</code> datatype also lets us represent a computation that may fail - but with one crucial difference. It accumulates any errors that may occur.</p>
<p>The <code>Validated</code> datatype is not defined in the Scala standard library and has to be sourced from the <a href="https://typelevel.org/cats/">Cats</a> functional programming library.</p>
<p>A simplified definition of the <code>Validated</code> type is given below:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Validated[+E, +A]
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Invalid[+E](e: E) <span class="kw">extends</span> Validated[E, Nothing]
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Valid[+A](a: A) <span class="kw">extends</span> Validated[Nothing, A]</code></pre></div>
<p>We can see that the similarity to <code>Either</code> is uncanny. The <code>Invalid</code> data constructor is used to wrap some type of error while the <code>Valid</code> data constructor wraps success types. So what is it about this datatype that makes it accumulate errors in the <code>Invalid</code> case?</p>
<p>Before we answer that question, let’s look at transforming our previous validation example to use <code>Validated</code> instead of <code>Either</code>.</p>
<p>Let’s start off by creating a type alias called <code>AllErrorsOr</code> to accumulate our errors or return our success value:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">type</span> AllErrorsOr[A] = Validated[PersonError, A]

<span class="kw">type</span> ErrorOr[A]     =    Either[PersonError, A]</code></pre></div>
<p>The code is almost identical to <code>ErrorOr</code>; we just swapped out <code>Either</code> for <code>Validated</code>. Let’s change the return type of all our validation function to use <code>AllErrorsOr</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateName</span>(name: String): AllErrorsOr[Name] = ???
  
  <span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = ???

  <span class="kw">def</span> <span class="fu">validateEmail</span>(email: String): AllErrorsOr[Email] = ???

  <span class="kw">def</span> <span class="fu">validatePerson</span>(name: String, age: String, email: String): AllErrorsOr[Person] = ???</code></pre></div>
<p>All we did is swap the <code>ErrorOr</code> type alias for <code>AllErrorsOr</code> and we have the definitions we need.</p>
<h3 id="construction">Construction</h3>
<p>Let’s go ahead and implement our validators. We can change our <code>validateName</code> function quite easily:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateName</span>(name: String): AllErrorsOr[Name] = {
    <span class="kw">if</span> (name.<span class="fu">headOption</span>.<span class="fu">exists</span>(_.<span class="fu">isUpper</span>)) <span class="fu">Valid</span>(Name(name))
    <span class="kw">else</span> Invalid(<span class="fu">PersonError</span>(s<span class="st">&quot;Name is empty or does not start with an uppercase character: $name&quot;</span>, NameInvalid))
  }</code></pre></div>
<p>We just simply swap <code>Left</code> for <code>Invalid</code> and <code>Right</code> for <code>Valid</code> data constructors and we are done. We could have also used the <code>invalid</code> and <code>valid</code> helper functions as well:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateName</span>(name: String): AllErrorsOr[Name] = {
    <span class="kw">if</span> (name.<span class="fu">headOption</span>.<span class="fu">exists</span>(_.<span class="fu">isUpper</span>)) Name(name).<span class="fu">valid</span>
    <span class="kw">else</span> <span class="fu">PersonError</span>(s<span class="st">&quot;Name is empty or does not start with an uppercase character: $name&quot;</span>, NameInvalid).<span class="fu">invalid</span>
  }</code></pre></div>
<p><code>validateAge</code> requires a little more work.</p>
<p>The <code>Either</code> implementation of <code>validateAge</code> was defined as:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = <span class="kw">for</span> {
    numericAge &lt;- <span class="fu">Try</span>(age.<span class="fu">toInt</span>).<span class="fu">toEither</span>.<span class="fu">left</span>.<span class="fu">map</span>(ex =&gt; <span class="fu">PersonError</span>(ex.<span class="fu">getMessage</span>, AgeInvalid))
    validAge &lt;- { 
      <span class="kw">if</span> (numericAge &lt;= <span class="dv">0</span> || numericAge &gt;= <span class="dv">120</span>) <span class="fu">Left</span>(<span class="fu">PersonError</span>(s<span class="st">&quot;Age must be a number between 1-120: ${numericAge}&quot;</span>, AgeInvalid))
      <span class="kw">else</span> <span class="fu">Valid</span>(numericAge)
    }
  } <span class="kw">yield</span> <span class="fu">Age</span>(validAge)</code></pre></div>
<p>So we have a couple of hurdles we need to jump over:</p>
<ol style="list-style-type: decimal">
<li>How do we convert a <code>Try</code> instance to a <code>Validated</code>?</li>
<li><code>Validated</code> does not implement <code>flatMap</code>; only <code>map</code>. This means we can’t use a for-comprehension to sequence <code>Validated</code> instances.</li>
</ol>
<p>We can solve the first problem by using the function <code>fromEither</code> on <code>Validated</code> that converts an <code>Either[A, B]</code> to a <code>Validated[A, B]</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> fromEither[A, B](e: Either[A, B]): Validated[A, B]</code></pre></div>
<p>Updating <code>validatedAge</code> we get:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = {

    <span class="kw">val</span> ageEither: Either[PersonError, Int] = 
      <span class="fu">Try</span>(age.<span class="fu">toInt</span>).
        toEither.
        left.<span class="fu">map</span>(ex =&gt; <span class="fu">PersonError</span>(ex.<span class="fu">getMessage</span>, AgeInvalid))

    <span class="kw">val</span> validatedIntAge: Validated[PersonError, Int] = Validated.<span class="fu">fromEither</span>(ageEither)

    ...
  }</code></pre></div>
<p>We can also use the <code>toValidated</code> to achieve the same result and IMO it’s a little nicer:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = {

    <span class="kw">val</span> validatedIntAge: Validated[PersonError, Int] Either[PersonError, Int] = 
      <span class="fu">Try</span>(age.<span class="fu">toInt</span>).
       toEither.
       left.<span class="fu">map</span>(ex =&gt; <span class="fu">PersonError</span>(ex.<span class="fu">getMessage</span>, AgeInvalid)).
       toValidated

    <span class="kw">val</span> numericAge = ??? <span class="co">//we need some way to get the Int age out of validatedIntAge</span>

    <span class="kw">val</span> validateAge: Validated[PersonError, Age] =
      <span class="kw">if</span> (numericAge &lt;= <span class="dv">0</span> || numericAge &gt; <span class="dv">120</span>) Invalid(<span class="fu">PersonError</span>(s<span class="st">&quot;Age must be a number between 1-120: ${numericAge}&quot;</span>, AgeInvalid))
      <span class="kw">else</span> <span class="fu">Valid</span>(numericAge)
    }

    validatedAge
  }</code></pre></div>
<p>We are almost there but we still need a way of sequencing two <code>Validated</code> instances together; where one <code>Validated</code> instance depends on the value returned from the previous <code>Validated</code> instance.</p>
<h3 id="combining">Combining</h3>
<p>Let’s see how we can answer our previous question:</p>
<blockquote>
<p>So what is it about this datatype that makes it accumulate errors in the <code>Invalid</code> case?</p>
</blockquote>
<p>In order to combine errors in a <code>Validated</code> we need the <u>types used as errors</u> to have some behaviours such as <a href="https://typelevel.org/cats/typeclasses/functor.html">Functor</a> (think something that can be mapped over) and <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Semigroupal.scala">Semigroupal</a> (think combining two effectful values into a pair of effectful values) or we need to <u>put the errors in a type</u> that has the above behaviours. One type that has those behaviours already defined is <a href="https://typelevel.org/cats/datatypes/nel.html">NonEmptyList</a>. A <code>NonEmptyList</code> is as the name suggests, a <code>List</code> that is guaranteed not to be empty (it has at least one element); which means you can safely call <code>head</code> on it among other things.</p>
<p>Cats already has a pre-build <code>Validated</code> type that uses <code>NonEmptyList</code> as its error type called <code>ValidatedNel</code>. The type definition of <code>ValidatedNel</code> reveals its form to us:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">type</span> ValidatedNel[+E, +A] = Validated[NonEmptyList[E], A]</code></pre></div>
<p>We can see that <code>ValidatedNel</code> is a simple type alias for a <code>Validated</code> with a <code>NonEmptyList</code> of some error type <code>E</code> or a success type of <code>A</code>.</p>
<p>The <code>Nel</code> part in <code>ValidatedNel</code> refers to the <code>N</code>on<code>E</code>mpty<code>L</code>ist of the error type. There are also <code>NonEmptyVector</code> and <code>NonEmptyChain</code> variations but they encapsulate the same thing - some data structure that is not empty that is used to accumulate any errors.</p>
<p>Let’s start off by updating our <code>AllErrorsOr</code> type alias to work with <code>ValidatedNel</code> instead of <code>Validated</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="co">//old</span>
<span class="co">//type AllErrorsOr[A] = Validated[PersonError, A]</span>

<span class="co">//new</span>
<span class="kw">type</span> AllErrorsOr[A]   = ValidatedNel[PersonError, A]</code></pre></div>
<p>To lift our invalid and valid values into a <code>ValidateNel</code> we can use the helper functions: <code>invalidNel</code> and <code>validNel</code> respectively. Here’s how we’d change the <code>validateName</code> function to use <code>ValidatedNel</code> instead of <code>Validated</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateName</span>(name: String): AllErrorsOr[Name] = {
  <span class="kw">if</span> (name.<span class="fu">headOption</span>.<span class="fu">exists</span>(_.<span class="fu">isUpper</span>)) Name(name).<span class="fu">validNel</span>
  <span class="kw">else</span> <span class="fu">PersonError</span>(s<span class="st">&quot;Name is empty or does not start with an uppercase character: $name&quot;</span>, NameInvalid).<span class="fu">invalidNel</span>
  }</code></pre></div>
<p>We can also use the usual <code>Valid</code> and <code>Invalid</code> data constructors but it’s a little cumbersome to wrap the <code>Invalid</code> case within a <code>NonEmptyList</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">data</span>.<span class="fu">Validated</span>.<span class="fu">_</span>
<span class="kw">import</span> cats.<span class="fu">data</span>.<span class="fu">NonEmptyList</span>

<span class="kw">def</span> <span class="fu">validateName</span>(name: String): AllErrorsOr[Name] = {
  <span class="kw">if</span> (name.<span class="fu">headOption</span>.<span class="fu">exists</span>(_.<span class="fu">isUpper</span>)) <span class="fu">Valid</span>(Name(name))
  <span class="kw">else</span> Invalid(NonEmptyList.<span class="fu">of</span>(<span class="fu">PersonError</span>(s<span class="st">&quot;Name is empty or does not start with an uppercase character: $name&quot;</span>, NameInvalid)))
}</code></pre></div>
<p>So far so good. Let’s try and update the <code>validateAge</code> function:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = {
    <span class="kw">val</span> numericAgeV: AllErrorsOr[Int] = <span class="fu">Try</span>(age.<span class="fu">toInt</span>).<span class="fu">toEither</span>.<span class="fu">left</span>.<span class="fu">map</span>(ex =&gt; <span class="fu">PersonError</span>(ex.<span class="fu">getMessage</span>, AgeInvalid)).<span class="fu">toValidatedNel</span>
    
    ...
  }</code></pre></div>
<p>We can quite easily convert an <code>Either</code> to a <code>ValidateNel</code> by calling <code>toValidatedNel</code> on it. Next let’s try and update the <code>validateAge</code> function:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = {

    <span class="kw">val</span> numericAgeV: AllErrorsOr[Int] = <span class="co">//from before</span>
    
    <span class="kw">def</span> <span class="fu">validAgeV</span>(numericAge: Int): AllErrorsOr[Int] = {
      <span class="kw">if</span> (numericAge &lt;= <span class="dv">0</span> || numericAge &gt; <span class="dv">120</span>) <span class="fu">PersonError</span>(s<span class="st">&quot;Age must be a number between 1-120: ${numericAge}&quot;</span>, AgeInvalid).<span class="fu">invalidNel</span>
      <span class="kw">else</span> numericAge.<span class="fu">validNel</span>
    }
  }</code></pre></div>
<p>Also quite easy. The next question is how do we combine these two validations to give us an <code>Age</code>?</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  numericAgeV ??? validAgeV =&gt; Age</code></pre></div>
<h4 id="andthen">andThen</h4>
<p>Here’s where the <code>andThen</code> method on <code>Validated</code> comes into play. It is defined as:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Validated[+E, +A] {
  ...
  <span class="kw">def</span> andThen[EE &gt;: E, B](f: (A) ⇒ Validated[EE, B]): Validated[EE, B]
}</code></pre></div>
<p>We can see that this method definition is similar to <code>Either</code>’s <code>flatMap</code> definition, in that it sequences together two computations that may fail, returning the latter as the result:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Either[+E, +A] {
  ...
  flatMap[EE &gt;: E, B](f: (A) =&gt; Either[EE, B]): Either[EE, B]
}</code></pre></div>
<p>We can also see that the first computation has to complete, to supply the <code>A</code> before the next computation can proceed. So let’s use it:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">val</span> combineAgeV: AllErrorsOr[Int] = numericAgeV.<span class="fu">andThen</span>(validAgeV)</code></pre></div>
<p>We can see that when we run <code>numericAgeV</code> validator we get a <code>AllErrorsOr[Int]</code>. This <code>Int</code> is then needed by the <code>validAgeV</code> function, which will then produce another <code>AllErrorsOr[Int]</code> if all goes well.</p>
<p>We still don’t have an <code>Age</code> instance, only an <code>Int</code>. To lift the validated <code>Int</code> value into the <code>Age</code> constructor we can use the <code>map</code> function. <code>map</code> is defined on <code>Validated</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Validated[+E, +A] {
  ...
  <span class="kw">def</span> map[B](f: (A) ⇒ B): Validated[E, B]
}</code></pre></div>
<p>Using <code>map</code> on <code>combineAgeV</code> with the <code>Age</code> constructor gives us the final result:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">val</span> result: AllErrorsOr[Age] = combineAgeV.<span class="fu">map</span>(n =&gt; <span class="fu">Age</span>(n))</code></pre></div>
<p>The complete <code>validateAge</code> function is as follows:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateAge</span>(age: String): AllErrorsOr[Age] = {
    <span class="kw">val</span> numericAgeV: AllErrorsOr[Int] = <span class="fu">Try</span>(age.<span class="fu">toInt</span>).<span class="fu">toEither</span>.<span class="fu">left</span>.<span class="fu">map</span>(ex =&gt; <span class="fu">PersonError</span>(ex.<span class="fu">getMessage</span>, AgeInvalid)).<span class="fu">toValidatedNel</span>
    
    <span class="kw">def</span> <span class="fu">validAgeV</span>(numericAge: Int): AllErrorsOr[Int] = {
      <span class="kw">if</span> (numericAge &lt;= <span class="dv">0</span> || numericAge &gt;= <span class="dv">120</span>) <span class="fu">PersonError</span>(s<span class="st">&quot;Age must be a number between 1-120: ${numericAge}&quot;</span>, AgeInvalid).<span class="fu">invalidNel</span>
      <span class="kw">else</span> numericAge.<span class="fu">validNel</span>
    }

    numericAgeV.<span class="fu">andThen</span>(validAgeV).<span class="fu">map</span>(Age)
  }</code></pre></div>
<p>Next lets convert our <code>validateEmail</code> function to use <code>ValidatedNel</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateEmail</span>(email: String): AllErrorsOr[Email] = {
  <span class="kw">if</span> (email.<span class="fu">isEmpty</span> || !email.<span class="fu">contains</span>(<span class="st">&quot;@&quot;</span>)) <span class="fu">PersonError</span>(s<span class="st">&quot;Email address is empty or does not contain an `@` symbol: $email&quot;</span>, EmailInvalid).<span class="fu">invalidNel</span>
  <span class="kw">else</span> <span class="fu">Email</span>(email).<span class="fu">validNel</span>
  }</code></pre></div>
<p>That’s very similar to how we modified the <code>validateName</code> function.</p>
<p>Now let’s try and implement the <code>validatePerson</code> function. As mentioned previously, <code>Validated</code> does not implement the <code>flatMap</code> function and hence it <a href="https://stackoverflow.com/questions/35761043/how-to-make-your-own-for-comprehension-compliant-scala-monad">can’t be used in a for-comprehension</a>. So how can we combine these three <code>Validated</code> instances? We can use the <code>andThen</code> method again but it gets quite messy:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">validateName</span>(name).<span class="fu">andThen</span>(validName =&gt; 
  <span class="fu">validateAge</span>(age).<span class="fu">andThen</span>(validAge =&gt; 
    <span class="fu">validateEmail</span>(email).<span class="fu">map</span>(validEmail =&gt; 
      <span class="fu">Person</span>(validName, validAge, validEmail)))) <span class="co">//ValidatedNel[PersonError, Person]</span></code></pre></div>
<p>If only there were a neater way of combining these validations. What we need is a function that is given each of the validated values if successful:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validatePerson</span>(name: String, age: String, email: String): AllErrorsOr[Person] = {
    <span class="fu">validateName</span>(name) ??? <span class="fu">validateAge</span>(age) ??? <span class="fu">validateEmail</span>(email) ??? (validName, validAge, validEmail) =&gt; <span class="fu">Person</span>(validName, validAge, validEmail)
  }</code></pre></div>
<h4 id="mapn">mapN</h4>
<p>To combine two or more <code>ValidatedNel</code> instances that don’t depend on each others’ values we can use the <code>mapN</code> method. A simplified definition of <code>mapN</code> is given below:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="co">//A: 1st successful value</span>
<span class="co">//B: 2nd successful value</span>
<span class="co">//Z: Result of applying function `f`</span>
<span class="co">//E: The failure type</span>
<span class="kw">def</span> mapN[Z](f: (A, B) =&gt; Z)(<span class="kw">implicit</span> functor: Functor[ValidatedNel[E, ?]],<span class="kw">implicit</span> semigroupal: Semigroupal[ValidatedNel[E,?]]): ValidatedNel[E,Z]</code></pre></div>
<p>Luckily we already know that <code>ValidatedNel</code> has <code>Functor</code> and <code>Semigroupal</code> instances so we can just use <code>mapN</code>. <code>mapN</code> is specialised for combining <code>Validated</code> instances from two to twenty two parameters. Using the product capabilities which we get from <code>Semigroupal</code>, we can write a function that uses the three validated values from our validators in the <code>validatePerson</code> function to create an <code>AllErrorsOr[Person]</code> instance.</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validatePerson</span>(name: String, age: String, email: String): AllErrorsOr[Person] = {
    (<span class="fu">validateName</span>(name), <span class="fu">validateAge</span>(age), <span class="fu">validateEmail</span>(email)).<span class="fu">mapN</span>((validName, validAge, validEmail) =&gt; <span class="fu">Person</span>(validName, validAge, validateEmail))
  }</code></pre></div>
<p>Now let’s see what happens when all of the validations fail:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">validatePerson</span>(<span class="st">&quot;odo&quot;</span>, <span class="st">&quot;200&quot;</span>, <span class="st">&quot;odo.founder.net&quot;</span>)
<span class="co">//Invalid(NonEmptyList(PersonError(Name is empty or does not start with an uppercase character: odo,NameInvalid), PersonError(Age must be a number between 1-120: 200,AgeInvalid), PersonError(Email address is empty or does not contain an `@` symbol: odo.founder.net,EmailInvalid)))</span></code></pre></div>
<p>We can see that all the errors have been accumulated for us!</p>
<p>Let’s see what happens when there are no errors:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">validatePerson</span>(<span class="st">&quot;Benjamin Sisko&quot;</span>, <span class="st">&quot;50&quot;</span>, <span class="st">&quot;b.sisko@dsn.st&quot;</span>)
<span class="co">//Valid(Person(Name(Benjamin Sisko),Age(50),Email(b.sisko@dsn.st)))</span></code></pre></div>
<p>We can see the output is as expected.</p>
<h4 id="productl-and-productr">productL and productR</h4>
<p>Now let’s assume that we rewrote <code>validateName</code> such that it depended on two separate validators; one for validating a non empty name (<code>validateNonEmptyName</code>) and one for validating whether the name starts with an uppercase character (<code>validateStartsWithUpper</code>):</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateNonEmptyName</span>(nameString: String): AllErrorsOr[String] = 
  <span class="kw">if</span> (nameString.<span class="fu">nonEmpty</span>) nameString.<span class="fu">validNel</span> <span class="kw">else</span> <span class="fu">PersonError</span>(s<span class="st">&quot;Name is empty&quot;</span>, NameInvalid).<span class="fu">invalidNel</span>

<span class="kw">def</span> <span class="fu">validateStartsWithUpper</span>(nameString: String): AllErrorsOr[String] = 
  <span class="kw">if</span> (nameString.<span class="fu">headOption</span>.<span class="fu">exists</span>(_.<span class="fu">isUpper</span>)) nameString.<span class="fu">validNel</span> <span class="kw">else</span> <span class="fu">PersonError</span>(s<span class="st">&quot;$nameString does not start with an uppercase character&quot;</span>, NameInvalid).<span class="fu">invalidNel</span></code></pre></div>
<p>We might compose them as follows within the <code>validateName</code> function:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateName</span>(name: String): AllErrorsOr[Name] = {
  <span class="fu">validateNonEmptyName</span>(name).<span class="fu">andThen</span>(_ =&gt; <span class="fu">validateStartsWithUpper</span>(name)).<span class="fu">map</span>(Name)
}</code></pre></div>
<p>Notice that we are discarding the success value returned from <code>validateNonEmptyName</code> when using the <code>andThen</code> function. We can directly use the value of the argument <code>name</code> in the <code>validateStartsWithUpper</code> function.</p>
<p>A more succinct way of writing this function composition is by using the <code>productR</code> function to ignore the result of the validator on the left and use the result of the validator on the right (hence the <code>R</code> in <code>productR</code>):</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">validateNameWithProduct</span>(name: String): AllErrorsOr[Name] = {
  (<span class="fu">validateNonEmptyName</span>(name) productR <span class="fu">validateStartsWithUpper</span>(name)).<span class="fu">map</span>(Name)
}</code></pre></div>
<p>There is an inverse method to <code>productR</code> called <code>productL</code> which uses the result of the validator on the left and ignores the result of the validator on the right. The important thing to realise is that both validators still get run, but only one of the success results is returned. This is a nice shorthand when you need to ignore one of the results from a validator. The <code>productL</code> and <code>productR</code> functions are available to any <a href="https://typelevel.org/cats/typeclasses/applicative.html">Applicative</a> <a href="https://typelevel.org/cats/typeclasses.html">typeclass</a> (via <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Apply.scala#L40">Apply</a>) and since <code>Validated</code> has an <code>Applicative</code> instance we get these methods for free.</p>
<h4 id="combine">combine</h4>
<p>Using <code>productL</code> and <code>productR</code> is similar to using the <code>combine</code> function available to any instance of the <a href="https://typelevel.org/cats/typeclasses/semigroup.html">Semigroup</a> typeclass (think something that can combine values similar to addition or multiplication of numbers) - with one important difference: The successes are accumulated in the event of all the validators succeeding - if your success type has an instance for <code>Semigroup</code>. Some common <code>Semigroup</code>s are <code>String</code>, <code>List</code> and <code>NoneEmptyList</code>.</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="co">//captures all errors if there are any errors</span>
<span class="fu">validateNonEmptyName</span>(<span class="st">&quot;&quot;</span>) combine <span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;joe&quot;</span>)
res11: Validated[NonEmptyList[PersonError],String] = Invalid(<span class="fu">NonEmptyList</span>(<span class="fu">PersonError</span>(Name is empty,NameInvalid), <span class="fu">PersonError</span>(joe does not start <span class="kw">with</span> an uppercase character,NameInvalid)))

<span class="co">//accumulates successes when the success value is a Semigroup</span>
<span class="fu">validateNonEmptyName</span>(<span class="st">&quot;joe1&quot;</span>) combine <span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;Joe2&quot;</span>)
res12: Validated[NonEmptyList[PersonError],String] = <span class="fu">Valid</span>(joe1Joe2)</code></pre></div>
<p>This is just something to be aware of so you won’t get tripped up when your successes are also accumulated.</p>
<p>I’m not really sure when this accumulation of successes would be useful. Send me a comment if you have a problem that this solves.</p>
<h4 id="combinek">combineK</h4>
<p>What if you want to choose between two or more validators, where you only want the one that passed? Think something similar to short-circuiting <code>Boolean</code> operators such as <code>&amp;&amp;</code> or <code>||</code>. In this scenario you could use <code>combineK</code> which comes from the <a href="https://typelevel.org/cats/typeclasses/semigroupk.html">SemigroupK</a> typeclass:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">def</span> combineK[A](x: F[A], y: F[A]): F[A] <span class="co">//can choose between `x` and `y` for some types of `F`</span></code></pre></div>
<p>Here’s how we could use it with our validators:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="co">//returns the first validator that succeeds</span>
<span class="fu">validateNonEmptyName</span>(<span class="st">&quot;joe&quot;</span>) combineK  <span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;Joe2&quot;</span>)
res16: net.<span class="fu">ssanj</span>.<span class="fu">validated</span>.<span class="fu">ValidatedValidations</span>.<span class="fu">AllErrorsOr</span>[String] = <span class="fu">Valid</span>(joe)

<span class="co">//tries the second validator if the first fails</span>
<span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;joe1&quot;</span>) combineK  <span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;Joe2&quot;</span>)
res17: net.<span class="fu">ssanj</span>.<span class="fu">validated</span>.<span class="fu">ValidatedValidations</span>.<span class="fu">AllErrorsOr</span>[String] = <span class="fu">Valid</span>(Joe2)

<span class="co">//accumulates errors if all validators fail</span>
<span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;joe1&quot;</span>) combineK  <span class="fu">validateStartsWithUpper</span>(<span class="st">&quot;joe2&quot;</span>)
res18: net.<span class="fu">ssanj</span>.<span class="fu">validated</span>.<span class="fu">ValidatedNelValidations</span>.<span class="fu">AllErrorsOr</span>[String] = Invalid(<span class="fu">NonEmptyList</span>(<span class="fu">PersonError</span>(joe1 does not start <span class="kw">with</span> an uppercase character,NameInvalid), <span class="fu">PersonError</span>(joe2 does not start <span class="kw">with</span> an uppercase character,NameInvalid)))</code></pre></div>
<h3 id="extracting">Extracting</h3>
<p>And finally you can run a <code>fold</code> on a <code>Validated</code> instance (just like you for <code>Option</code> or <code>Either</code>) to extract the value of failure or success:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Validated[+E, +A] {
  ...
  <span class="kw">def</span> fold[B](fe: (E) ⇒ B, fa: (A) ⇒ B): B
}</code></pre></div>
<p>An example usage of <code>fold</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="fu">validateNonEmptyName</span>(<span class="st">&quot;joe&quot;</span>).
  <span class="fu">fold</span>(failure =&gt; s<span class="st">&quot;you failed: $failure&quot;</span>, success =&gt; s<span class="st">&quot;you succeeded with $success&quot;</span>)
res19: String = you succeeded <span class="kw">with</span> joe</code></pre></div>
<p>You can also use pattern matching instead to achieve the same result:</p>
<div class="sourceCode"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">data</span>.<span class="fu">Validated</span>.<span class="fu">_</span>

<span class="fu">validateNonEmptyName</span>(<span class="st">&quot;joe&quot;</span>) <span class="kw">match</span>  {
  <span class="kw">case</span> Invalid(failure) =&gt; s<span class="st">&quot;you failed: $failure&quot;</span>
  <span class="kw">case</span> <span class="fu">Valid</span>(success) =&gt; s<span class="st">&quot;you succeeded with $success&quot;</span>
}
res22: String = you succeeded <span class="kw">with</span> joe</code></pre></div>
<p>While it can seem like <code>Validated</code> is complex to use, in practise it is quite straight forward once you know a few rules. Hopefully this article has given you some confidence in using <code>Validated</code> the next time you need to accumulate some errors. Also be sure to read the <a href="https://typelevel.org/cats/datatypes/validated.html">Cats documentation on Validated</a> to give you more insight into their usage. Sample code for this article can be found <a href="https://github.com/ssanj/validated-examples">here</a></p>]]></description>
    <pubDate>Sun, 18 Aug 2019 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2019-08-18-using-validated-for-error-accumulation-in-scala-with-cats.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>How to set Fatal Warnings in Scala 2.13?</title>
    <link>http://blog.ssanj.net/posts/2019-07-15-how-to-set-fatal-warnings-in-scala-2.13.html</link>
    <description><![CDATA[<p>With the introduction of Scala 2.13, a bunch of commonly used compiler options have been moved.</p>
<p><code>-Xfatal-warnings</code> has been replaced with <code>-Werror</code>. In fact a lot of <em>warning</em> options which were previously <code>-Ywarn</code> have been moved to <code>-W</code> such as <code>-Ywarn-dead-code</code> which is now <code>-Wdead-code</code>.</p>
<p>Here’s a full list of <code>-W</code> options:</p>
<ul>
<li><strong>-Wdead-code</strong> Warn when dead code is identified.</li>
<li><strong>-Wextra-implicit</strong> Warn when more than one implicit parameter section is defined.</li>
<li><strong>-Wmacros:</strong>&lt;mode&gt; Enable lint warnings on macro expansions. Default: <code>before</code>, <code>help</code> to list choices.</li>
<li><strong>-Wnumeric-widen</strong> Warn when numerics are widened.</li>
<li><strong>-Woctal-literal</strong> Warn on obsolete octal syntax.</li>
<li><strong>-Wself-implicit</strong> Warn when an implicit resolves to an enclosing self-definition.</li>
<li><strong>-Wunused:imports</strong> Warn if an import selector is not referenced.</li>
<li><strong>-Wunused:patvars</strong> Warn if a variable bound in a pattern is unused.</li>
<li><strong>-Wunused:privates</strong> Warn if a private member is unused.</li>
<li><strong>-Wunused:locals</strong> Warn if a local definition is unused.</li>
<li><strong>-Wunused:explicits</strong> Warn if an explicit parameter is unused.</li>
<li><strong>-Wunused:implicits</strong> Warn if an implicit parameter is unused.</li>
<li><strong>-Wunused:params</strong> Enable -Wunused:explicits,implicits.</li>
<li><strong>-Wunused:linted</strong> -Xlint:unused.</li>
<li><strong>-Wvalue-discard</strong> Warn when non-Unit expression results are unused.</li>
</ul>
<p>A lot of <code>-Ywarn</code> options have also now become <code>-Xlint</code>options such as <code>-Ywarn-infer-any</code> which is now <code>-Xlint:infer-any</code>. Here’s a full list of the <code>-Xlint</code> options:</p>
<ul>
<li><strong>-Xlint:adapted-args</strong> Warn if an argument list is modified to match the receiver.</li>
<li><strong>-Xlint:nullary-unit</strong> Warn when nullary methods return Unit.</li>
<li><strong>-Xlint:inaccessible</strong> Warn about inaccessible types in method signatures.</li>
<li><strong>-Xlint:nullary-override</strong> Warn when non-nullary <code>def f()' overrides nullary</code>def f’.</li>
<li><strong>-Xlint:infer-any</strong> Warn when a type argument is inferred to be <code>Any</code>.</li>
<li><strong>-Xlint:missing-interpolator</strong> A string literal appears to be missing an interpolator id.</li>
<li><strong>-Xlint:doc-detached</strong> A Scaladoc comment appears to be detached from its element.</li>
<li><strong>-Xlint:private-shadow</strong> A private field (or class parameter) shadows a superclass field.</li>
<li><strong>-Xlint:type-parameter-shadow</strong> A local type parameter shadows a type already in scope.</li>
<li><strong>-Xlint:poly-implicit-overload</strong> Parameterized overloaded implicit methods are not visible as view bounds.</li>
<li><strong>-Xlint:option-implicit</strong> Option.apply used implicit view.</li>
<li><strong>-Xlint:delayedinit-select</strong> Selecting member of DelayedInit.</li>
<li><strong>-Xlint:package-object-classes</strong> Class or object defined in package object.</li>
<li><strong>-Xlint:stars-align</strong> Pattern sequence wildcard must align with sequence component.</li>
<li><strong>-Xlint:constant</strong> Evaluation of a constant arithmetic expression results in an error.</li>
<li><strong>-Xlint:unused</strong> Enable -Ywarn-unused:imports,privates,locals,implicits.</li>
<li><strong>-Xlint:nonlocal-return</strong> A return statement used an exception for flow control.</li>
<li><strong>-Xlint:implicit-not-found</strong> Check <span class="citation">@implicitNotFound</span> and <span class="citation">@implicitAmbiguous</span> messages.</li>
<li><strong>-Xlint:serial</strong> <span class="citation">@SerialVersionUID</span> on traits and non-serializable classes.</li>
<li><strong>-Xlint:valpattern</strong> Enable pattern checks in val definitions.</li>
<li><strong>-Xlint:eta-zero</strong> Warn on eta-expansion (rather than auto-application) of zero-ary method.</li>
<li><strong>-Xlint:eta-sam</strong> Warn on eta-expansion to meet a Java-defined functional interface that is not explicitly annotated with <span class="citation">@FunctionalInterface</span>.</li>
<li><strong>-Xlint:deprecation</strong> Enable linted deprecations.</li>
</ul>
<p>For a full list of options checkout <a href="https://sanj.ink/posts/2019-06-14-scalac-2.13-options-and-flags.html">scalac 2.13 options and flags</a></p>]]></description>
    <pubDate>Mon, 15 Jul 2019 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2019-07-15-how-to-set-fatal-warnings-in-scala-2.13.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>
<item>
    <title>Scalac 2.13 Options and Flags</title>
    <link>http://blog.ssanj.net/posts/2019-06-14-scalac-2.13-options-and-flags.html</link>
    <description><![CDATA[<p>Given that Scala <a href="https://www.scala-lang.org/news/2.13.0">2.13</a> has just landed, there are a bunch of new flags and options available to the compiler. Below is a full list of options to choose from.</p>
<h1 id="standard-options">Standard Options</h1>
<ul>
<li><strong>-Dproperty=value</strong> Pass -Dproperty=value directly to the runtime system.</li>
<li><strong>-J</strong>&lt;flag&gt; Pass &lt;flag&gt; directly to the runtime system.</li>
<li><strong>-P</strong>:&lt;plugin&gt;:&lt;opt&gt; Pass an option to a plugin</li>
<li><strong>-V</strong> Print a synopsis of verbose options.</li>
<li><strong>-W</strong> Print a synopsis of warning options.</li>
<li><strong>-Werror</strong> Fail the compilation if there are any warnings.</li>
<li><strong>-X</strong> Print a synopsis of advanced options.</li>
<li><strong>-Y</strong> Print a synopsis of private options.</li>
<li><strong>-bootclasspath</strong> &lt;path&gt; Override location of bootstrap class files.</li>
<li><strong>-classpath</strong> &lt;path&gt; Specify where to find user class files.</li>
<li><strong>-d</strong> &lt;directory|jar&gt; destination for generated classfiles.</li>
<li><strong>-dependencyfile</strong> &lt;file&gt; Set dependency tracking file.</li>
<li><strong>-deprecation</strong> Emit warning and location for usages of deprecated APIs.</li>
<li><strong>-encoding</strong> &lt;encoding&gt; Specify character encoding used by source files.</li>
<li><strong>-explaintypes</strong> Explain type errors in more detail.</li>
<li><strong>-extdirs</strong> &lt;path&gt; Override location of installed extensions.</li>
<li><strong>-feature</strong> Emit warning and location for usages of features that should be imported explicitly.</li>
<li><strong>-g</strong>:&lt;level&gt; Set level of generated debugging info. (none,source,line,[vars],notailcalls)</li>
<li><strong>-help</strong> Print a synopsis of standard options</li>
<li><strong>-javabootclasspath</strong> &lt;path&gt; Override java boot classpath.</li>
<li><strong>-javaextdirs</strong> &lt;path&gt; Override java extdirs classpath.</li>
<li><strong>-language</strong>:&lt;features&gt; Enable or disable language features</li>
<li><strong>-no-specialization</strong> Ignore <span class="citation">@specialize</span> annotations.</li>
<li><strong>-nobootcp</strong> Do not use the boot classpath for the scala jars.</li>
<li><strong>-nowarn</strong> Generate no warnings.</li>
<li><strong>-opt</strong>:&lt;optimizations&gt; Enable optimizations</li>
<li><strong>-opt-inline-from</strong>:&lt;patterns&gt; Patterns for classfile names from which to allow inlining, <code>help</code> for details.</li>
<li><strong>-opt-warnings</strong>:&lt;warnings&gt; Enable optimizer warnings</li>
<li><strong>-print</strong> Print program with Scala-specific features removed.</li>
<li><strong>-release</strong> &lt;release&gt; Compile for a specific version of the Java platform. Supported targets: 6, 7, 8, 9</li>
<li><strong>-sourcepath</strong> &lt;path&gt; Specify location(s) of source files.</li>
<li><strong>-target</strong>:&lt;target&gt; Target platform for object files. All JVM 1.5 - 1.7 targets are deprecated. (jvm-1.5,jvm-1.6,jvm-1.7,[jvm-1.8])</li>
<li><strong>-toolcp</strong> &lt;path&gt; Add to the runner classpath.</li>
<li><strong>-unchecked</strong> Enable additional warnings where generated code depends on assumptions.</li>
<li><strong>-uniqid</strong> Uniquely tag all identifiers in debugging output.</li>
<li><strong>-usejavacp</strong> Utilize the java.class.path in classpath resolution.</li>
<li><strong>-usemanifestcp</strong> Utilize the manifest in classpath resolution.</li>
<li><strong>-verbose</strong> Output messages about what the compiler is doing.</li>
<li><strong>-version</strong> Print product version and exit.</li>
<li><strong>@</strong>&lt;file&gt; A text file containing compiler arguments (options and source files)</li>
</ul>
<h2 id="deprecated-settings">Deprecated settings:</h2>
<ul>
<li>-optimize Enables optimizations. deprecated: Since 2.12, enables -opt:l:inline -opt-inline-from:**. See -opt:help.</li>
</ul>
<h1 id="verbose-options--v">Verbose Options (-V)</h1>
<ul>
<li><strong>-Vbrowse</strong>:&lt;phases&gt; Browse the abstract syntax tree after &lt;phases&gt;</li>
<li><strong>-Vclasspath</strong> Output information about what classpath is being applied.</li>
<li><strong>-Vdebug</strong> Increase the quantity of debugging output.</li>
<li><strong>-Vdoc</strong> Trace scaladoc activity.</li>
<li><strong>-Vfree-terms</strong> Print a message when reification creates a free term.</li>
<li><strong>-Vfree-types</strong> Print a message when reification resorts to generating a free type.</li>
<li><strong>-Vhot-statistics</strong> Enable <strong>-Vstatistics</strong> to also print hot statistics.</li>
<li><strong>-Vide</strong> Generate, validate and output trees using the interactive compiler.</li>
<li><strong>-Vimplicit-conversions</strong> Print a message whenever an implicit conversion is inserted.</li>
<li><strong>-Vimplicits</strong> Show more detail on why some implicits are not applicable.</li>
<li><strong>-Vinline</strong> &lt;package/Class.method&gt; Print a summary of inliner activity; <code>_</code> to print all, prefix match to select.</li>
<li><strong>-Vissue</strong> Print stack traces when a context issues an error.</li>
<li><strong>-Vlog</strong>:&lt;phases&gt; Log operations during &lt;phases&gt;</li>
<li><strong>-Vmacro</strong> Trace macro activities: compilation, generation of synthetics, classloading, expansion, exceptions.</li>
<li><strong>-Vmacro-lite</strong> Trace macro activities with less output.</li>
<li><strong>-Vopt</strong> &lt;package/Class.method&gt; Trace the optimizer progress for methods; <code>_</code> to print all, prefix match to select.</li>
<li><strong>-Vpatmat</strong> Trace pattern matching translation.</li>
<li><strong>-Vphases</strong> Print a synopsis of compiler phases.</li>
<li><strong>-Vpos</strong> Trace position validation.</li>
<li><strong>-Vprint</strong>:&lt;phases&gt; Print out program after &lt;phases&gt;</li>
<li><strong>-Vprint-args</strong> &lt;file&gt; Print all compiler arguments to the specified location. Use - to echo to the reporter.</li>
<li><strong>-Vprint-pos</strong> Print tree positions, as offsets.</li>
<li><strong>-Vprint-types</strong> Print tree types (debugging option).</li>
<li><strong>-Vquasiquote</strong> Trace quasiquotations.</li>
<li><strong>-Vreflective-calls</strong> Print a message when a reflective method call is generated</li>
<li><strong>-Vreify</strong> Trace reification.</li>
<li><strong>-Vshow</strong>:&lt;phases&gt; (Requires -Xshow-class or -Xshow-object) Show after &lt;phases&gt;</li>
<li><strong>-Vshow-class</strong> &lt;class&gt; Show internal representation of class.</li>
<li><strong>-Vshow-member-pos</strong> &lt;output style&gt; Show start and end positions of members (implies -Yrangepos)</li>
<li><strong>-Vshow-object</strong> &lt;object&gt; Show internal representation of object.</li>
<li><strong>-Vshow-symkinds</strong> Print abbreviated symbol kinds next to symbol names.</li>
<li><strong>-Vshow-symowners</strong> Print owner identifiers next to symbol names.</li>
<li><strong>-Vstatistics</strong>[:phases] Print compiler statistics for specific phases &lt;phases&gt; (default: parser,typer,patmat,erasure,cleanup,jvm)</li>
<li><strong>-Vsymbols</strong> Print the AST symbol hierarchy after each phase.</li>
<li><strong>-Vtyper</strong> Trace type assignments.</li>
<li><strong>Note</strong>:
<ul>
<li>Boolean settings are false unless set: -Xdev -Xcheck-init:true -Xprompt:false</li>
<li>Multi-valued settings are comma-separated: -Xlint:infer-any,unused,-missing-interpolator</li>
<li>Phases are a list of names, ids, or ranges of ids: -Xprint:parser,typer,5-10 -Ylog:-4_</li>
<li>Use _ to enable all: -language:_ -Xprint:_</li>
</ul></li>
</ul>
<h1 id="warning-options--w">Warning Options (-W)</h1>
<ul>
<li><strong>-Wdead-code</strong> Warn when dead code is identified.</li>
<li><strong>-Wextra-implicit</strong> Warn when more than one implicit parameter section is defined.</li>
<li><strong>-Wmacros:</strong>&lt;mode&gt; Enable lint warnings on macro expansions. Default: <code>before</code>, <code>help</code> to list choices.</li>
<li><strong>-Wnumeric-widen</strong> Warn when numerics are widened.</li>
<li><strong>-Woctal-literal</strong> Warn on obsolete octal syntax.</li>
<li><strong>-Wself-implicit</strong> Warn when an implicit resolves to an enclosing self-definition.</li>
<li><strong>-Wunused:imports</strong> Warn if an import selector is not referenced.</li>
<li><strong>-Wunused:patvars</strong> Warn if a variable bound in a pattern is unused.</li>
<li><strong>-Wunused:privates</strong> Warn if a private member is unused.</li>
<li><strong>-Wunused:locals</strong> Warn if a local definition is unused.</li>
<li><strong>-Wunused:explicits</strong> Warn if an explicit parameter is unused.</li>
<li><strong>-Wunused:implicits</strong> Warn if an implicit parameter is unused.</li>
<li><strong>-Wunused:params</strong> Enable -Wunused:explicits,implicits.</li>
<li><strong>-Wunused:linted</strong> -Xlint:unused.</li>
<li><strong>-Wvalue-discard</strong> Warn when non-Unit expression results are unused.</li>
<li><strong>-Xlint:adapted-args</strong> Warn if an argument list is modified to match the receiver.</li>
<li><strong>-Xlint:nullary-unit</strong> Warn when nullary methods return Unit.</li>
<li><strong>-Xlint:inaccessible</strong> Warn about inaccessible types in method signatures.</li>
<li><strong>-Xlint:nullary-override</strong> Warn when non-nullary <code>def f()' overrides nullary</code>def f’.</li>
<li><strong>-Xlint:infer-any</strong> Warn when a type argument is inferred to be <code>Any</code>.</li>
<li><strong>-Xlint:missing-interpolator</strong> A string literal appears to be missing an interpolator id.</li>
<li><strong>-Xlint:doc-detached</strong> A Scaladoc comment appears to be detached from its element.</li>
<li><strong>-Xlint:private-shadow</strong> A private field (or class parameter) shadows a superclass field.</li>
<li><strong>-Xlint:type-parameter-shadow</strong> A local type parameter shadows a type already in scope.</li>
<li><strong>-Xlint:poly-implicit-overload</strong> Parameterized overloaded implicit methods are not visible as view bounds.</li>
<li><strong>-Xlint:option-implicit</strong> Option.apply used implicit view.</li>
<li><strong>-Xlint:delayedinit-select</strong> Selecting member of DelayedInit.</li>
<li><strong>-Xlint:package-object-classes</strong> Class or object defined in package object.</li>
<li><strong>-Xlint:stars-align</strong> Pattern sequence wildcard must align with sequence component.</li>
<li><strong>-Xlint:constant</strong> Evaluation of a constant arithmetic expression results in an error.</li>
<li><strong>-Xlint:unused</strong> Enable -Ywarn-unused:imports,privates,locals,implicits.</li>
<li><strong>-Xlint:nonlocal-return</strong> A return statement used an exception for flow control.</li>
<li><strong>-Xlint:implicit-not-found</strong> Check <span class="citation">@implicitNotFound</span> and <span class="citation">@implicitAmbiguous</span> messages.</li>
<li><strong>-Xlint:serial</strong> <span class="citation">@SerialVersionUID</span> on traits and non-serializable classes.</li>
<li><strong>-Xlint:valpattern</strong> Enable pattern checks in val definitions.</li>
<li><strong>-Xlint:eta-zero</strong> Warn on eta-expansion (rather than auto-application) of zero-ary method.</li>
<li><strong>-Xlint:eta-sam</strong> Warn on eta-expansion to meet a Java-defined functional interface that is not explicitly annotated with <span class="citation">@FunctionalInterface</span>.</li>
<li><strong>-Xlint:deprecation</strong> Enable linted deprecations.</li>
</ul>
<h1 id="advanced-options--x">Advanced Options (-X)</h1>
<ul>
<li><strong>-Xcheckinit</strong> Wrap field accessors to throw an exception on uninitialized access.</li>
<li><strong>-Xdev</strong> Indicates user is a developer - issue warnings about anything which seems amiss</li>
<li><strong>-Xdisable-assertions</strong> Generate no assertions or assumptions.</li>
<li><strong>-Xelide-below</strong> &lt;n&gt; Calls to <span class="citation">@elidable</span> methods are omitted if method priority is lower than argument</li>
<li><strong>-Xgenerate-phase-graph</strong> &lt;file&gt; Generate the phase graphs (outputs .dot files) to fileX.dot.</li>
<li><strong>-Xlint</strong>:&lt;warnings&gt; Enable recommended warnings</li>
<li><strong>-Xmacro-settings</strong>:&lt;option&gt; Custom settings for macros.</li>
<li><strong>-Xmain-class</strong> &lt;path&gt; Class for manifest’s Main-Class entry (only useful with -d &lt;jar&gt;)</li>
<li><strong>-Xmaxerrs</strong> &lt;n&gt; Maximum errors to print</li>
<li><strong>-Xmaxwarns</strong> &lt;n&gt; Maximum warnings to print</li>
<li><strong>-Xmigration</strong>:&lt;version&gt; Warn about constructs whose behavior may have changed since version.</li>
<li><strong>-Xmixin-force-forwarders</strong>:&lt;mode&gt; Generate forwarder methods in classes inhering concrete methods from traits. Default: <code>true</code>, <code>help</code> to list choices.</li>
<li><strong>-Xno-forwarders</strong> Do not generate static forwarders in mirror classes.</li>
<li><strong>-Xno-patmat-analysis</strong> Don’t perform exhaustivity/unreachability analysis. Also, ignore <span class="citation">@switch</span> annotation.</li>
<li><strong>-Xno-uescape</strong> Disable handling of nicode escapes.</li>
<li><strong>-Xnojline</strong> Do not use JLine for editing.</li>
<li><strong>-Xplugin</strong>:&lt;paths&gt; Load a plugin from each classpath.</li>
<li><strong>-Xplugin-disable</strong>:&lt;plugin&gt; Disable plugins by name.</li>
<li><strong>-Xplugin-list</strong> Print a synopsis of loaded plugins.</li>
<li><strong>-Xplugin-require</strong>:&lt;plugin&gt; Abort if a named plugin is not loaded.</li>
<li><strong>-Xpluginsdir</strong> &lt;path&gt; Path to search for plugin archives.</li>
<li><strong>-Xprompt</strong> Display a prompt after each error (debugging option).</li>
<li><strong>-Xreporter</strong> &lt;classname&gt; Specify a custom reporter for compiler messages.</li>
<li><strong>-Xresident</strong> Compiler stays resident: read source filenames from standard input.</li>
<li><strong>-Xscript</strong> &lt;object&gt; Treat the source file as a script and wrap it in a main method.</li>
<li><strong>-Xsource</strong>:&lt;version&gt; Treat compiler input as Scala source for the specified version, see <a href="https://github.com/scala/bug/issues/8126">scala/bug#8126</a>.</li>
<li><strong>-Xsource-reader</strong> &lt;classname&gt; Specify a custom method for reading source files.</li>
<li><strong>-Xverify</strong> Verify generic signatures in generated bytecode.</li>
<li><strong>-Xxml</strong>:&lt;propertys&gt; Configure XML parsing.</li>
</ul>
<h1 id="private-options--y">Private Options (-Y)</h1>
<ul>
<li><strong>-Ybackend-parallelism</strong> &lt;n&gt; maximum worker threads for backend</li>
<li><strong>-Ybackend-worker-queue</strong> &lt;n&gt; backend threads worker queue size</li>
<li><strong>-Ybreak-cycles</strong> Attempt to break cycles encountered during typing</li>
<li><strong>-Ycache-macro-class-loader</strong>:&lt;policy&gt; Policy for caching class loaders for macros that are dynamically loaded. Default: <code>none</code>, <code>help</code> to list choices.</li>
<li><strong>-Ycache-plugin-class-loader</strong>:&lt;policy&gt; Policy for caching class loaders for compiler plugins that are dynamically loaded. Default: <code>none</code>, <code>help</code> to list choices.</li>
<li><strong>-Ycheck</strong>:&lt;phases&gt; Check the tree at the end of &lt;phases&gt;</li>
<li><strong>-Ycompact-trees</strong> Use compact tree printer when displaying trees.</li>
<li><strong>-Ydelambdafy</strong>:&lt;strategy&gt; Strategy used for translating lambdas into JVM code. (inline,[method])</li>
<li><strong>-Ydump-classes</strong> &lt;dir&gt; Dump the generated bytecode to .class files (useful for reflective compilation that utilizes in-memory classloaders).</li>
<li><strong>-Ygen-asmp</strong> &lt;dir&gt; Generate a parallel output directory of .asmp files (ie ASM Textifier output).</li>
<li><strong>-Yimports</strong>:&lt;import&gt; Custom root imports, default is <code>java.lang,scala,scala.Predef</code>.</li>
<li><strong>-Yjar-compression-level</strong> &lt;n&gt; compression level to use when writing jar files</li>
<li><strong>-Ymacro-annotations</strong> Enable support for macro annotations, formerly in macro paradise.</li>
<li><strong>-Ymacro-classpath</strong> &lt;path&gt; The classpath used to reflectively load macro implementations, default is the compilation classpath.</li>
<li><strong>-Ymacro-expand</strong>:&lt;policy&gt; Control expansion of macros, useful for scaladoc and presentation compiler. ([normal],none,discard)</li>
<li><strong>-Ymacro-global-fresh-names</strong> Should fresh names in macros be unique across all compilation units</li>
<li><strong>-Yno-completion</strong> Disable tab-completion in the REPL.</li>
<li><strong>-Yno-flat-classpath-cache</strong> Do not cache flat classpath representation of classpath elements from jars across compiler instances.</li>
<li><strong>-Yno-generic-signatures</strong> Suppress generation of generic signatures for Java.</li>
<li><strong>-Yno-imports</strong> Compile without importing scala.<em>, java.lang.</em>, or Predef.</li>
<li><strong>-Yno-predef</strong> Compile without importing Predef.</li>
<li><strong>-Yopt-inline-heuristics</strong>:&lt;strategy&gt; Set the heuristics for inlining decisions. (at-inline-annotated,everything,[default])</li>
<li><strong>-Ypatmat-exhaust-depth</strong> &lt;n&gt; off</li>
<li><strong>-Ypresentation-any-thread</strong> Allow use of the presentation compiler from any thread</li>
<li><strong>-Ypresentation-debug</strong> Enable debugging output for the presentation compiler.</li>
<li><strong>-Ypresentation-delay</strong> &lt;n&gt; Wait number of ms after typing before starting typechecking</li>
<li><strong>-Ypresentation-log</strong> &lt;file&gt; Log presentation compiler events into file</li>
<li><strong>-Ypresentation-replay</strong> &lt;file&gt; Replay presentation compiler events from file</li>
<li><strong>-Ypresentation-strict</strong> Do not report type errors in sources with syntax errors.</li>
<li><strong>-Ypresentation-verbose</strong> Print information about presentation compiler tasks.</li>
<li><strong>-Yprint-trees</strong>:&lt;style&gt; How to print trees when -Xprint is enabled. ([text],compact,format,text+format)</li>
<li><strong>-Yprofile-destination</strong> &lt;file&gt; Profiling output - specify a file or <code>-</code> for console.</li>
<li><strong>-Yprofile-enabled</strong> Enable profiling.</li>
<li><strong>-Yprofile-external-tool</strong>[:phases] Enable profiling for a phase using an external tool hook. Generally only useful for a single phase &lt;phases&gt; (default: typer)</li>
<li><strong>-Yprofile-run-gc</strong>[:phases] Run a GC between phases - this allows heap size to be accurate at the expense of more time. Specify a list of phases, or all &lt;phases&gt; (default: _)</li>
<li><strong>-Yprofile-trace</strong> &lt;file&gt; Capture trace of compilation in Chrome Trace format</li>
<li><strong>-Yrangepos</strong> Use range positions for syntax trees.</li>
<li><strong>-Yrecursion</strong> &lt;n&gt; Set recursion depth used when locking symbols.</li>
<li><strong>-Yreify-copypaste</strong> Dump the reified trees in copypasteable representation.</li>
<li><strong>-Yrepl-class-based</strong> Use classes to wrap REPL snippets instead of objects</li>
<li><strong>-Yrepl-outdir</strong> &lt;path&gt; Write repl-generated classfiles to given output directory (use “” to generate a temporary dir)</li>
<li><strong>-Yresolve-term-conflict</strong>:&lt;strategy&gt; Resolve term conflicts. (package,object,[error])</li>
<li><strong>-Yscriptrunner</strong> &lt;classname&gt; Specify a scala.tools.nsc.ScriptRunner (default, resident, shutdown, or a class name).</li>
<li><strong>-Yskip</strong>:&lt;phases&gt; Skip &lt;phases&gt;</li>
<li><strong>-Ystop-after</strong>:&lt;phases&gt; Stop after &lt;phases&gt;</li>
<li><strong>-Ystop-before</strong>:&lt;phases&gt; Stop before &lt;phases&gt;</li>
<li><strong>-Yvalidate-pos</strong>:&lt;phases&gt; Validate positions after the given phases (implies -Yrangepos) &lt;phases&gt;</li>
<li><strong>Note</strong>:
<ul>
<li>Boolean settings are false unless set: -Xdev -Xcheck-init:true -Xprompt:false</li>
<li>Multi-valued settings are comma-separated: -Xlint:infer-any,unused,-missing-interpolator</li>
<li>Phases are a list of names, ids, or ranges of ids: -Xprint:parser,typer,5-10 -Ylog:-4</li>
<li>Use _ to enable all: -language:_ -Xprint:_</li>
</ul></li>
</ul>]]></description>
    <pubDate>Fri, 14 Jun 2019 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2019-06-14-scalac-2.13-options-and-flags.html</guid>
    <dc:creator>sanjiv sahayam</dc:creator>
</item>

    </channel>
</rss>
