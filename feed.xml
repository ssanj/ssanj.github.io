<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>BabylonCandle</title>
        <link>http://blog.ssanj.net</link>
        <description><![CDATA[The blog of Sanjiv Sahayam]]></description>
        <atom:link href="http://blog.ssanj.net/feed.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sun, 19 Apr 2015 00:00:00 UT</lastBuildDate>
        <item>
    <title>Why Your Company should have a Creed</title>
    <link>http://blog.ssanj.net/posts/2015-04-19-why-your-company-should-have-a-creed.html</link>
    <description><![CDATA[<p><a href="http://automattic.com">Automattic</a> is a company founded by Matt Mullenweg. He also developed <a href="https://en-au.wordpress.org">Wordpress</a> ten years ago. He talks of the notion of a “company creed” which codifies the culture and values of a company. Here’s the Autommatic creed (as of September 19th, 2011):</p>
<div class="quote">
I will never stop learning. I won’t just work on things that are assigned to me. I know there’s no such thing as a status quo. I will build our business sustainably through passionate and loyal customers. I will never pass up an opportunity to help out a colleague, and I’ll remember the days before I knew everything. I am more motivated by impact than money, and I know that Open Source is one of the most powerful ideas of our generation. I will communicate as much as possible, because it’s the oxygen of a distributed company. I am in a marathon, not a sprint, and no matter how far away the goal is, the only way to get there is by putting one foot in front of another every day. Given time, there is no problem that’s insurmountable.
</div>
<p>Matt further says that:</p>
<div class="quote">
If you’re building a startup or any sort of organisation, take a few moments to reflect on the qualities that the people you most enjoy working with embody and the user experience of new people joining your organisation, from the offer letter to their first day.
</div>
<p>Finally Matt has an innovative way of introducing the company’s creed to new hires:</p>
<div class="quote">
Finally, as a hack to introduce new folks to our culture, we put a beta “Automattic Creed”, basically a statement of things important to us, written in the first person. We put it after the legal gobbledygook and before the signature area; if you chose to accept the offer, you’d sign your name next to the values before starting work. This seemed like a powerful statement and might affect people’s perceptions in the same way that putting signatures at the top of forms increases honesty.
</div>
<p><a href="http://ma.tt/2011/09/automattic-creed">Read the full article on Matt’s blog</a>.</p>]]></description>
    <pubDate>Sun, 19 Apr 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-04-19-why-your-company-should-have-a-creed.html</guid>
</item>
<item>
    <title>How to run a Company with (almost) no Rules</title>
    <link>http://blog.ssanj.net/posts/2015-04-12-how-to-run-a-company-with-almost-no-rules.html</link>
    <description><![CDATA[<p>Some interesting ideas from Ricardo Semler’s Ted Talk: <a href="http://www.ted.com/talks/ricardo_semler_radical_wisdom_for_a_company_a_school_a_life">How to run a company with (almost) no rules</a>:</p>
<div class="quote">
What if your job didn’t control your life?
</div>
<ol style="list-style-type: decimal">
<li>Start working through your bucket list now. Don’t wait until you are in dire straights to do so.</li>
</ol>
<div class="quote">
Instead of going mountain climbing when you’re 82, why don’t you do it next week?
</div>
<ol start="2" style="list-style-type: decimal">
<li>Employees are given freedom over what they ware, when they work and how they behave.</li>
<li>Employees can buy back one day of the week for 10% of their salary.</li>
<li>Employees are contracted for a piece of work and given autonomy.</li>
<li>All leaders in the company must be interviewed and approved by their future subordinates. Every 6 months everyone gets anonymously reviewed as a leader. If existing leaders are graded poorly they are replaced.</li>
<li>People are allowed to set their own salaries given three pieces of information:</li>
</ol>
<ul>
<li>How much money people make inside the company.</li>
<li>The market rate for a similar position in a similar company.</li>
<li>Whether the company can afford to give them the salary they want.</li>
</ul>
<div class="quote">
How do we design, how do we organise, for more wisdom?
</div>
<ol start="7" style="list-style-type: decimal">
<li>If an employee finishes all their work early they get to take the rest of the week off.</li>
</ol>
<div class="quote">
We said things like, we don’t want to see your expense report, we don’t want to know how many holidays you’re taking, we don’t want to know where you work.
</div>
<ol start="8" style="list-style-type: decimal">
<li>Information is open and democratic. The board has two vacant seats with the equal voting rights. Any two employees from the company can show up and vote on company issues. This keeps the board honest. Eg. Cleaners voting on the direction of the company.</li>
<li>We know nothing about the important things in life:</li>
</ol>
<ul>
<li>Love</li>
<li>Death</li>
<li>Our purpose</li>
</ul>
<div class="quote">
If you say “I have to give back”, then you took too much.
</div>
<ol start="10" style="list-style-type: decimal">
<li>Free yourself from past achievements. Give yourself the freedom to start something new.</li>
</ol>
<div class="quote">
We’ve all learned how to work from home on Sunday night, but very few of us have learned how to go to the movies on Monday afternoon.
</div>
<ol start="11" style="list-style-type: decimal">
<li>Ask yourself: “Why am I doing this?”.</li>
</ol>]]></description>
    <pubDate>Sun, 12 Apr 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-04-12-how-to-run-a-company-with-almost-no-rules.html</guid>
</item>
<item>
    <title>Laying the Groundwork for an Effective Routine</title>
    <link>http://blog.ssanj.net/posts/2015-04-11-laying-the-groundwork.html</link>
    <description><![CDATA[<p>Ideas from the chapter “Laying the Groundwork for an Effective Routine” from the book <a href="http://99u.com/book/manage-your-day-to-day-2">Manage Your Day-To-Day</a> by Mark McGuinness.</p>
<ol style="list-style-type: decimal">
<li>To create something truly worthwhile, you need to make room for the work you consider important. This means delaying or not doing the work you consider unimportant.</li>
<li>To create something great you need:
<ul>
<li>Time</li>
<li>Thought</li>
<li>Craft</li>
<li>Persistence</li>
</ul></li>
<li>Do creative work first. Do reactive work second.</li>
<li>Do your creative work when you have the most energy during the day.</li>
<li>Use triggers like using the same tools, listening to the same music or working in the same environment each day to enter your creative zone.</li>
<li>Have a very small daily TODO list. Most things can wait until tomorrow.</li>
</ol>]]></description>
    <pubDate>Sat, 11 Apr 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-04-11-laying-the-groundwork.html</guid>
</item>
<item>
    <title>Hire for the Future</title>
    <link>http://blog.ssanj.net/posts/2015-04-09-hire-for-the-future.html</link>
    <description><![CDATA[<p>First of all, hire only the best people for your company. If you can’t find good people, then use your money elsewhere.</p>
<p>Second, hire people who can take your company to where you want it to be in the future not just to sustain it where it is now.</p>]]></description>
    <pubDate>Thu, 09 Apr 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-04-09-hire-for-the-future.html</guid>
</item>
<item>
    <title>Calculated Risks have a Critical Mass</title>
    <link>http://blog.ssanj.net/posts/2015-04-09-calculated-risks-have-a-critical-mass.html</link>
    <description><![CDATA[<p>We all need to work very fast these days. Bugs in production are costing us money on an hourly basis. We may have a gaping security hole. We don’t have the capacity to service all our current clients. We have to solve these problems ASAP. Or do we?</p>
<p>Technical debt is the main way these unplanned, extremely “urgent” features, changes or fixes get into production. We over estimate our capabilities constantly. We think we are taking “calculated” risks. In reality we are not doing any calculations. Our understanding of the current workings of the system is usually off. Way off. We have forgotten about the fix Joe did last week. Or the new configuration that is in place for special customers. We need to be <a href="http://www.isixsigma.com/tools-templates/cause-effect/determine-root-cause-5-whys">five whysing</a> ourselves about “Why does this happen?”.</p>
<p>You can only continue to incur technical debt for so long. If you keep incurring technical debt on a regular basis, there will come a tipping point where your system will become massively unstable. It will become exponentially harder to fix bugs and add new features. Developers will “give up” on the code base because they don’t want to work on a foundation of hacks. Quality will slip. Your product will fail. Your company will go out of business.</p>
<p>All that sounds a bit dramatic. If you keep accumulating technical debt, your system will be foreclosed. It’s not “if” but “when”.</p>
<p>So how can you work with technical debt and still have a stable system? How can you fix critical issues and not piss off all your developers and operations people? Here are some ideas:</p>
<h1 id="investigate-your-risks">Investigate your risks</h1>
<p>Actually spend a good chunk of time thinking about how the system works. Work in a pair if possible and look through the source code, configuration and architecture. Run your risk assessment past members of the team from different technical and non-technical areas. No one person should be making the risk call - specially not a non-technical person. If the risk is too great, think of alternative ways of solving your problem. Could you get an extension from the client? Can we bare with the issues we have now? Can we do nothing? What will it cost us?</p>
<h1 id="have-a-repayment-plan">Have a repayment plan</h1>
<p>Make a plan to pay off the technical debt after a certain release, feature/fix or by a certain date. Have an upper limit on the amount of debt you can accrue. Do not incur more debt after this limit has been reached. Sacrifice new features for stability through repayments.</p>
<h1 id="make-the-smallest-change-possible">Make the smallest change possible</h1>
<p>If you do decide to take on some technical debt, try to make it as small as possible. This is not the time to change the core architecture or make other sweeping changes. Make the change as small as possible. Make sure all your unit and integration tests pass. If they don’t, make the smallest change possible to get them to pass or take them out of the build.</p>
<blockquote>
<p>It’s more important to have a suit of working tests that you can rely on over just ignoring failing tests. If you start ignoring test failures you will never have full confidence in your test suite as some of them are known to fail.</p>
</blockquote>
<h1 id="document-your-debts">Document your debts</h1>
<p>Document the reasons for incurring the debt directly in the code that is affected by it. This can be done using comments or TODOs that you can come back to later. After you incur technical debt, add it to a debt register of some kind. This could be a wiki page, card wall or even a bunch of red postits on a wall or whiteboard. This will be a constant reminder of the debt you have already incurred. It also will help you to pay back this debt ASAP and prevent you from taking unnecessary new debt. As the wiki page or the wall grows, you know you are in trouble.</p>
<h1 id="pay-off-your-debts">Pay off your debts</h1>
<p>Completely rewrite any code hacks documented in your debt registry. Reintroduce all excluded tests. Make them pass. Add more tests. Refactor. Win. :)</p>]]></description>
    <pubDate>Thu, 09 Apr 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-04-09-calculated-risks-have-a-critical-mass.html</guid>
</item>
<item>
    <title>A Man that can't Whisper</title>
    <link>http://blog.ssanj.net/posts/2015-04-09-a-man-that-cant-whisper.html</link>
    <description><![CDATA[<p><a href="http://www.dannybhoy.com">Danny Bhoy</a> is a very funny Scottish-Indian comedian. He has toured Australia many times and I’ve had the pleasure of attending some of his gigs.</p>
<p>More recently I watched him on a Netflix special, where he said something quite profound:</p>
<p class="quote">
I’ll tell you one thing, I’m not gonna go on a Safari with a man that can’t whisper.
</p>

<p>True for Safaris and life.</p>]]></description>
    <pubDate>Thu, 09 Apr 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-04-09-a-man-that-cant-whisper.html</guid>
</item>
<item>
    <title>Workplaces are a Snapshot in Time</title>
    <link>http://blog.ssanj.net/posts/2015-03-29-workplaces-are-a-snapshot-in-time.html</link>
    <description><![CDATA[<p>Work places are like a snapshot in time. The people, the culture, the technology etc are in a constant state of flux. Some people leave. Others join. Technology is replaced frequently. Methodologies change. Fortunes are made and lost.</p>
<p>I had the recent good fortune to go back to one of my previous work places. I had worked there six years prior and had left swearing never to return. I had since heard good things and had returned. The place had almost completely changed. Sure, there were pockets of “old” behaviour lying around but for the most part it was a completely different organisation. Different people, technologies, methodologies, philosophies - you name it.</p>
<p>Whenever you work somewhere try and soak it all in. Chances are that the exact combination of things around you will never be the same. Enjoy the uniqueness of the present.</p>]]></description>
    <pubDate>Sun, 29 Mar 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-03-29-workplaces-are-a-snapshot-in-time.html</guid>
</item>
<item>
    <title>Don't be Complacent</title>
    <link>http://blog.ssanj.net/posts/2015-03-29-dont-be-complacent.html</link>
    <description><![CDATA[<p>Focus on learning something hard to remind yourself that there are many things you do not know.</p>
<p>Keep learning. Be humble.</p>]]></description>
    <pubDate>Sun, 29 Mar 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-03-29-dont-be-complacent.html</guid>
</item>
<item>
    <title>Future Execution Order</title>
    <link>http://blog.ssanj.net/posts/2015-03-22-future-execution-order.html</link>
    <description><![CDATA[<p>Futures had me confused. For some reason I had assumed that the execution of Futures were somehow linked to for-comprehensions. I had somehow assumed that you compose your Futures first and then run them when you were good and ready. Something similar to the Reader Monad in Haskell. I couldn’t have been more wrong.</p>
<h2 id="defining-futures-outside-a-for-comprehension">Defining Futures outside a for-comprehension</h2>
<p>Let’s take a simple example. First I define an <strong>iterate</strong> method that takes in a name and a number. The name is used to track the Future that is iterating. The method basically loops form 1 to the number passed in while printing out its current iteration. It then sleeps for 250 ms. It prints out when it is done at the end. All very simple.</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">
  <span class="kw">final</span> <span class="kw">def</span> <span class="fu">iterate</span>(name:String, n:Int): Int = {
    <span class="fu">println</span>(s<span class="st">&quot;defining $name&quot;</span>)
    (<span class="dv">1</span> to n).<span class="fu">foreach</span> { n =&gt;
      <span class="fu">println</span>(s<span class="st">&quot;$name sleeping for item: $n&quot;</span>)
      Thread.<span class="fu">sleep</span>(<span class="dv">250</span>)
    }

    <span class="fu">println</span>(s<span class="st">&quot;$name done&quot;</span>)
    n
  }</code></pre>
<p>Let’s take Scenario 1. This scenario creates two Futures: <strong>f1</strong> and <strong>f2</strong> with ten and two iterations respectively. It then sleeps for ten seconds after which it processes the results of the Futures and sums them up to give another Future: <strong>f3</strong>. We then wait for a maximum of one minute for <strong>f3</strong> to complete and print out “done”.</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">    <span class="kw">val</span> f1: Future[Int] = Future {
      <span class="fu">iterate</span>(<span class="st">&quot;f1&quot;</span>, <span class="dv">10</span>)
    }
    <span class="kw">val</span> f2: Future[Int] = Future {
      <span class="fu">iterate</span>(<span class="st">&quot;f2&quot;</span>, <span class="dv">2</span>)
    }

    Thread.<span class="fu">sleep</span>(<span class="dv">10000</span>) <span class="co">//sleep for 10 seconds</span>

    <span class="fu">println</span>(<span class="st">&quot;before comprehension&quot;</span>)

    <span class="kw">val</span> f3:Future[Int] = <span class="kw">for</span> {
      x &lt;- {<span class="fu">println</span>(<span class="st">&quot;f1 -&gt;&quot;</span>); f1}
      y &lt;- {<span class="fu">println</span>(<span class="st">&quot;f2 -&gt;&quot;</span>); f2}
    } <span class="kw">yield</span> x + y

    f3.<span class="fu">onComplete</span>(_ =&gt; <span class="fu">println</span>(<span class="st">&quot;f3 done&quot;</span>))

    <span class="fu">println</span>(<span class="st">&quot;after comprehension&quot;</span>)

    <span class="kw">val</span> result = Await.<span class="fu">result</span>(f3, Duration(<span class="dv">1</span>, TimeUnit.<span class="fu">MINUTES</span>))

    <span class="fu">println</span>(s<span class="st">&quot;done with $result&quot;</span>)</code></pre>
<p>What is the output of the above program?</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">defining</span> f1
<span class="kw">defining</span> f2
<span class="kw">f2</span> sleeping for item: 1
<span class="kw">f1</span> sleeping for item: 1
<span class="kw">f2</span> sleeping for item: 2
<span class="kw">f1</span> sleeping for item: 2
<span class="kw">f1</span> sleeping for item: 3
<span class="kw">f2</span> done
<span class="kw">f1</span> sleeping for item: 4
<span class="kw">f1</span> sleeping for item: 5
<span class="kw">f1</span> sleeping for item: 6
<span class="kw">f1</span> sleeping for item: 7
<span class="kw">f1</span> sleeping for item: 8
<span class="kw">f1</span> sleeping for item: 9
<span class="kw">f1</span> sleeping for item: 10
<span class="kw">f1</span> done
<span class="kw">before</span> comprehension
<span class="kw">f1</span> -<span class="kw">&gt;</span>
<span class="kw">f2</span> -<span class="kw">&gt;</span>
<span class="kw">after</span> comprehension
<span class="kw">f3</span> done
<span class="kw">done</span> <span class="kw">with</span> 12</code></pre>
<p>What does this tell us? This tells us that the Futures: <strong>f1 </strong> and <strong>f2 </strong> start executing almost immediately after they are defined and they run concurrently. <strong>f2 </strong> finishes before <strong>f1 </strong>. <strong>f1 </strong> finishes before the for-comprehension is reached. The for-comprehension executes and creates a Future <strong>f3 </strong> which starts executing in the background. The values of <strong>f1 </strong> and <strong>f2 </strong> are extracted in that order and we are done when <strong>f3 </strong> finishes.</p>
<p>The point in time when a Future starts executing has nothing to do with for-comprehensions - as long as the Futures are defined outside the for-comprehension (more on this below.) The main thread of execution continues along its merry way without blocking at the for-comprehension and waiting for a result. The for-comprehension also creates a new Future which then immediately begins running the computation asynchronously. All very curious.</p>
<h2 id="defining-futures-inside-a-for-comprehension">Defining Futures inside a for-comprehension</h2>
<p>Let’s look at Scenario 2. This scenario basically creates two Futures within the for-comprehension: <strong>f1</strong> and <strong>f2</strong> with ten and two iterations respectively, as in Scenario 1. It then processes the results of the Futures within the for-comprehension and sums them up to give another Future: <strong>f3</strong>. We then wait for a maximum of one minute for <strong>f3</strong> to complete and print out “done”.</p>
<p>but this time define the Futures f1 and f2 within the for-comprehension.</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">    <span class="fu">println</span>(<span class="st">&quot;before comprehension&quot;</span>)

    <span class="kw">val</span> f3:Future[Int] = <span class="kw">for</span> {
      x &lt;- Future { <span class="fu">println</span>(<span class="st">&quot;f1 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f1&quot;</span>, <span class="dv">10</span>) }
      y &lt;- Future { <span class="fu">println</span>(<span class="st">&quot;f2 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f2&quot;</span>, <span class="dv">2</span>) }
    } <span class="kw">yield</span> x + y

    f3.<span class="fu">onComplete</span>(_ =&gt; <span class="fu">println</span>(<span class="st">&quot;f3 done&quot;</span>))

    <span class="fu">println</span>(<span class="st">&quot;after comprehension&quot;</span>)

    <span class="kw">val</span> result = Await.<span class="fu">result</span>(f3, Duration(<span class="dv">1</span>, TimeUnit.<span class="fu">MINUTES</span>))

    <span class="fu">println</span>(s<span class="st">&quot;done with $result&quot;</span>)</code></pre>
<p>What is the output of the above program?</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">before</span> comprehension
<span class="kw">f1</span> -<span class="kw">&gt;</span>
<span class="kw">after</span> comprehension
<span class="kw">defining</span> f1
<span class="kw">f1</span> sleeping for item: 1
<span class="kw">f1</span> sleeping for item: 2
<span class="kw">f1</span> sleeping for item: 3
<span class="kw">f1</span> sleeping for item: 4
<span class="kw">f1</span> sleeping for item: 5
<span class="kw">f1</span> sleeping for item: 6
<span class="kw">f1</span> sleeping for item: 7
<span class="kw">f1</span> sleeping for item: 8
<span class="kw">f1</span> sleeping for item: 9
<span class="kw">f1</span> sleeping for item: 10
<span class="kw">f1</span> done
<span class="kw">f2</span> -<span class="kw">&gt;</span>
<span class="kw">defining</span> f2
<span class="kw">f2</span> sleeping for item: 1
<span class="kw">f2</span> sleeping for item: 2
<span class="kw">f2</span> done
<span class="kw">f3</span> done
<span class="kw">done</span> <span class="kw">with</span> 12</code></pre>
<p>We can see that Future: <strong>f1</strong>, starts executing only after the for-comprehension defined. We can see that the main thread of execution does not block on the for-comprehension and continues executing. <strong>f2</strong> has not started executing at all. It is only once <strong>f1</strong> completes that <strong>f2</strong> starts executing. We now have synchronous execution as opposed to asynchronous execution of <strong>f1</strong> and <strong>f2</strong>. No concurrency here. Once <strong>f2</strong> completes, <strong>f3</strong> finishes straight after and we are done.</p>
<p>So it looks like these are the general rules of Future execution:</p>
<ol style="list-style-type: decimal">
<li>Define Futures you want to run concurrently outside a for-comprehension.</li>
<li>Define Futures you want to run sequentially inside a for-comprehension.</li>
</ol>
<h2 id="what-about-zip">What about zip?</h2>
<p>Just when we had everything nice and tidy I came across the <strong>zip</strong> method on <a href="http://www.scala-lang.org/files/archive/nightly/docs/library/index.html#scala.concurrent.Future">scala.concurrent.Future</a>. Let’s run Scenario 2 with the zip method and call it Scenario 3.</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">    <span class="fu">println</span>(<span class="st">&quot;before comprehension&quot;</span>)

    <span class="kw">val</span> f3:Future[Int] = <span class="kw">for</span> {
      (x, y) &lt;- Future { <span class="fu">println</span>(<span class="st">&quot;f1 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f1&quot;</span>, <span class="dv">10</span>) } zip Future {
        <span class="fu">println</span>(<span class="st">&quot;f2 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f2&quot;</span>, <span class="dv">2</span>) }
    } <span class="kw">yield</span> x + y

    f3.<span class="fu">onComplete</span>(_ =&gt; <span class="fu">println</span>(<span class="st">&quot;f3 done&quot;</span>))

    <span class="fu">println</span>(<span class="st">&quot;after comprehension&quot;</span>)

    <span class="kw">val</span> result = Await.<span class="fu">result</span>(f3, Duration(<span class="dv">1</span>, TimeUnit.<span class="fu">MINUTES</span>))

    <span class="fu">println</span>(s<span class="st">&quot;done with $result&quot;</span>)</code></pre>
<p>What is the output of the above program?</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">before</span> comprehension
<span class="kw">f1</span> -<span class="kw">&gt;</span>
<span class="kw">f2</span> -<span class="kw">&gt;</span>
<span class="kw">defining</span> f2
<span class="kw">defining</span> f1
<span class="kw">f1</span> sleeping for item: 1
<span class="kw">f2</span> sleeping for item: 1
<span class="kw">after</span> comprehension
<span class="kw">f2</span> sleeping for item: 2
<span class="kw">f1</span> sleeping for item: 2
<span class="kw">f2</span> done
<span class="kw">f1</span> sleeping for item: 3
<span class="kw">f1</span> sleeping for item: 4
<span class="kw">f1</span> sleeping for item: 5
<span class="kw">f1</span> sleeping for item: 6
<span class="kw">f1</span> sleeping for item: 7
<span class="kw">f1</span> sleeping for item: 8
<span class="kw">f1</span> sleeping for item: 9
<span class="kw">f1</span> sleeping for item: 10
<span class="kw">f1</span> done
<span class="kw">f3</span> done
<span class="kw">done</span> <span class="kw">with</span> 12</code></pre>
<p>It looks very much like Scenario 2, where we had <strong>f1</strong> and <strong>f2</strong> running concurrently. So how does this work? The <strong>zip</strong> function is defined on Future as:</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> zip[U](that: Future[U]): Future[(T, U)] = {
    <span class="kw">implicit</span> <span class="kw">val</span> ec = internalExecutor
    <span class="kw">val</span> p = Promise[(T, U)]()
    onComplete {
      <span class="kw">case</span> f: Failure[_] =&gt; p complete f.<span class="fu">asInstanceOf</span>[Failure[(T, U)]]
      <span class="kw">case</span> <span class="fu">Success</span>(s) =&gt; that onComplete { c =&gt; p.<span class="fu">complete</span>(c map { s2 =&gt; (s, s2) }) }
    }
    p.<span class="fu">future</span>
  }</code></pre>
<p>So how do <strong>f1</strong> and <strong>f2</strong> run concurrently? The answer lies in the how the second Future is passed to the <strong>zip</strong> method. <strong>f1</strong> starts executing immediately before its <strong>zip</strong> method is called. Since <strong>zip</strong> takes in a <code>(that: Future[U])</code> instead of a <code>(that: =&gt; Future[U])</code>, <strong>that</strong> starts executing immediately as a side-effect when passed to the <strong>zip</strong> method. Talk about yucky.</p>
<p>So if I wrote function: <strong>zip2</strong> that took <strong>that</strong> as a function we should see the same results as Scenario two. Let’s call this Scenario 4.</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">private</span> <span class="kw">def</span> zip2[T,U](one: Future[T])(two: =&gt; Future[U])(<span class="kw">implicit</span> ec:ExecutionContext): Future[(T, U)] = {
    <span class="kw">val</span> p = Promise[(T, U)]()
    one.<span class="fu">onComplete</span> {
      <span class="kw">case</span> f: Failure[_] =&gt; p complete f.<span class="fu">asInstanceOf</span>[Failure[(T, U)]]
      <span class="kw">case</span> <span class="fu">Success</span>(s) =&gt; two onComplete { c =&gt; p.<span class="fu">complete</span>(c map { s2 =&gt; (s, s2) }) }
    }
    p.<span class="fu">future</span>
  }


    <span class="fu">println</span>(<span class="st">&quot;before comprehension&quot;</span>)

    <span class="kw">val</span> f3:Future[Int] = <span class="kw">for</span> {
      (x, y) &lt;- <span class="fu">zip2</span>(Future { <span class="fu">println</span>(<span class="st">&quot;f1 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f1&quot;</span>, <span class="dv">10</span>) })(Future {<span class="fu">println</span>(<span class="st">&quot;f2 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f2&quot;</span>, <span class="dv">2</span>) })
    } <span class="kw">yield</span> x + y

    f3.<span class="fu">onComplete</span>(_ =&gt; <span class="fu">println</span>(<span class="st">&quot;f3 done&quot;</span>))

    <span class="fu">println</span>(<span class="st">&quot;after comprehension&quot;</span>)

    <span class="kw">val</span> result = Await.<span class="fu">result</span>(f3, Duration(<span class="dv">1</span>, TimeUnit.<span class="fu">MINUTES</span>))

    <span class="fu">println</span>(s<span class="st">&quot;done with $result&quot;</span>)</code></pre>
<p>We can see that <strong>f1</strong> has to complete before <strong>f2</strong>:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">before</span> comprehension
<span class="kw">f1</span> -<span class="kw">&gt;</span>
<span class="kw">defining</span> f1
<span class="kw">after</span> comprehension
<span class="kw">f1</span> sleeping for item: 1
<span class="kw">f1</span> sleeping for item: 2
<span class="kw">f1</span> sleeping for item: 3
<span class="kw">f1</span> sleeping for item: 4
<span class="kw">f1</span> sleeping for item: 5
<span class="kw">f1</span> sleeping for item: 6
<span class="kw">f1</span> sleeping for item: 7
<span class="kw">f1</span> sleeping for item: 8
<span class="kw">f1</span> sleeping for item: 9
<span class="kw">f1</span> sleeping for item: 10
<span class="kw">f1</span> done
<span class="kw">f2</span> -<span class="kw">&gt;</span>
<span class="kw">defining</span> f2
<span class="kw">f2</span> sleeping for item: 1
<span class="kw">f2</span> sleeping for item: 2
<span class="kw">f2</span> done
<span class="kw">f3</span> done
<span class="kw">done</span> <span class="kw">with</span> 12</code></pre>
<p>If we <strong>zip</strong> within a for-comprehension, then Futures run concurrently right? That depends. We still need to define the <strong>zip</strong> call in the first step of the for-comprehension. Take Scenario 5 as an example.</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">    <span class="fu">println</span>(<span class="st">&quot;before comprehension&quot;</span>)

    <span class="kw">val</span> f4:Future[Int] = <span class="kw">for</span> {
      a &lt;- Future {<span class="fu">println</span>(<span class="st">&quot;f1 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f1&quot;</span>, <span class="dv">5</span>) }
      (x, y) &lt;- Future { <span class="fu">println</span>(<span class="st">&quot;f2 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f2&quot;</span>, <span class="dv">10</span>) } zip Future {
        <span class="fu">println</span>(<span class="st">&quot;f3 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f3&quot;</span>, <span class="dv">2</span>) }
    } <span class="kw">yield</span> a + x + y

    f4.<span class="fu">onComplete</span>(_ =&gt; <span class="fu">println</span>(<span class="st">&quot;f4 done&quot;</span>))

    <span class="fu">println</span>(<span class="st">&quot;after comprehension&quot;</span>)

    <span class="kw">val</span> result = Await.<span class="fu">result</span>(f4, Duration(<span class="dv">1</span>, TimeUnit.<span class="fu">MINUTES</span>))

    <span class="fu">println</span>(s<span class="st">&quot;done with $result&quot;</span>)</code></pre>
<p>If we look at the output, we see that <strong>f1</strong> has to complete before <strong>f2</strong> and <strong>f3</strong> start executing concurrently.</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">before</span> comprehension
<span class="kw">f1</span> -<span class="kw">&gt;</span>
<span class="kw">after</span> comprehension
<span class="kw">defining</span> f1
<span class="kw">f1</span> sleeping for item: 1
<span class="kw">f1</span> sleeping for item: 2
<span class="kw">f1</span> sleeping for item: 3
<span class="kw">f1</span> sleeping for item: 4
<span class="kw">f1</span> sleeping for item: 5
<span class="kw">f1</span> done
<span class="kw">f2</span> -<span class="kw">&gt;</span>
<span class="kw">defining</span> f2
<span class="kw">f2</span> sleeping for item: 1
<span class="kw">f3</span> -<span class="kw">&gt;</span>
<span class="kw">defining</span> f3
<span class="kw">f3</span> sleeping for item: 1
<span class="kw">f3</span> sleeping for item: 2
<span class="kw">f2</span> sleeping for item: 2
<span class="kw">f3</span> done
<span class="kw">f2</span> sleeping for item: 3
<span class="kw">f2</span> sleeping for item: 4
<span class="kw">f2</span> sleeping for item: 5
<span class="kw">f2</span> sleeping for item: 6
<span class="kw">f2</span> sleeping for item: 7
<span class="kw">f2</span> sleeping for item: 8
<span class="kw">f2</span> sleeping for item: 9
<span class="kw">f2</span> sleeping for item: 10
<span class="kw">f2</span> done
<span class="kw">f4</span> done
<span class="kw">done</span> <span class="kw">with</span> 17</code></pre>
<h2 id="where-should-we-define-futures">Where should we Define Futures?</h2>
<p>Yikes. What a minefield. So the rules seem to be:</p>
<ol style="list-style-type: decimal">
<li>If you defined Futures outside a for-comprehension they will run immediately and concurrently.</li>
<li>If you define Futures inside a for-comprehension they will run sequentially (if not zipped).</li>
<li>If you zip Futures in the first step of the for-comprehension they will run immediately and concurrently.</li>
<li>If you zip Futures in secondary steps of the for-comprehension, they will not run until all preceding steps have completed successfully. They will then run concurrently.</li>
</ol>
<p>The source code for the above scenarios can be found on <a href="https://github.com/ssanj/future-execution-order-blogpost-example">github</a></p>]]></description>
    <pubDate>Sun, 22 Mar 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-03-22-future-execution-order.html</guid>
</item>
<item>
    <title>Sanity in Numbers</title>
    <link>http://blog.ssanj.net/posts/2015-03-18-sanity-in-numbers.html</link>
    <description><![CDATA[<p>We’ve all had times where we were personally tasked to do something really stressful at work that was of “critical” importance. Mostly likely the work needed to be completed yesterday. Other times we could be losing a client if we don’t implement feature X which was promised to them. For some, this is a daily occurrence. When this inevitably happens, ask to be part of team. This improves your chances of success even with one additional person. Here’s why:</p>
<ol style="list-style-type: decimal">
<li>It shares the stress amongst the team. No one person carries the full burden.</li>
<li>Pushing back on unreasonable requests is much easier when you have more voices of “reason”.</li>
<li>You get second/third/fourth opinions about what needs to be done, when it needs to be done by and how it should be done.</li>
<li>Your team becomes the sanity check in insane situations.</li>
</ol>
<p>Some scenarios where having a team is useful:</p>
<ol style="list-style-type: decimal">
<li>Unreasonable deadlines.</li>
<li>Massive architectural changes.</li>
<li>“Quick” fixes that could destabilise your production system.</li>
<li>“Must have” features then need to be completed ASAP.</li>
<li>Migration or deletion of production data.</li>
</ol>
<p>You might be refused even one additional person to share this “critical” piece of work. You then have to ask yourself: “how critical is this piece of work if the company doesn’t want to put more than one person on it?” Quite likely you’ll see that it’s not critical at all.</p>]]></description>
    <pubDate>Wed, 18 Mar 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-03-18-sanity-in-numbers.html</guid>
</item>

    </channel> 
</rss>
