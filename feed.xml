<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>BabylonCandle</title>
        <link>http://blog.ssanj.net</link>
        <description><![CDATA[The blog of Sanjiv Sahayam]]></description>
        <atom:link href="http://blog.ssanj.net/feed.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Thu, 09 Apr 2015 00:00:00 UT</lastBuildDate>
        <item>
    <title>Hire for the Future</title>
    <link>http://blog.ssanj.net/posts/2015-04-09-hire-for-the-future.html</link>
    <description><![CDATA[<p>First of all, hire only the best people for your company. If you can’t find good people, then use your money elsewhere.</p>
<p>Second, hire people who can take your company to where you want it to be in the future not just to sustain it where it is now.</p>]]></description>
    <pubDate>Thu, 09 Apr 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-04-09-hire-for-the-future.html</guid>
</item>
<item>
    <title>Calculated Risks have a Critical Mass</title>
    <link>http://blog.ssanj.net/posts/2015-04-09-calculated-risks-have-a-critical-mass.html</link>
    <description><![CDATA[<p>We all need to work very fast these days. Bugs in production are costing us money on an hourly basis. We may have a gaping security hole. We don’t have the capacity to service all our current clients. We have to solve these problems ASAP. Or do we?</p>
<p>Technical debt is the main way these unplanned, extremely “urgent” features, changes or fixes get into production. We over estimate our capabilities constantly. We think we are taking “calculated” risks. In reality we are not doing any calculations. Our understanding of the current workings of the system is usually off. Way off. We have forgotten about the fix Joe did last week. Or the new configuration that is in place for special customers. We need to be <a href="http://www.isixsigma.com/tools-templates/cause-effect/determine-root-cause-5-whys">five whysing</a> ourselves about “Why does this happen?”.</p>
<p>You can only continue to incur technical debt for so long. If you keep incurring technical debt on a regular basis, there will come a tipping point where your system will become massively unstable. It will become exponentially harder to fix bugs and add new features. Developers will “give up” on the code base because they don’t want to work on a foundation of hacks. Quality will slip. Your product will fail. Your company will go out of business.</p>
<p>All that sounds a bit dramatic. If you keep accumulating technical debt, your system will be foreclosed. It’s not “if” but “when”.</p>
<p>So how can you work with technical debt and still have a stable system? How can you fix critical issues and not piss off all your developers and operations people? Here are some ideas:</p>
<h1 id="investigate-your-risks">Investigate your risks</h1>
<p>Actually spend a good chunk of time thinking about how the system works. Work in a pair if possible and look through the source code, configuration and architecture. Run your risk assessment past members of the team from different technical and non-technical areas. No one person should be making the risk call - specially not a non-technical person. If the risk is too great, think of alternative ways of solving your problem. Could you get an extension from the client? Can we bare with the issues we have now? Can we do nothing? What will it cost us?</p>
<h1 id="have-a-repayment-plan">Have a repayment plan</h1>
<p>Make a plan to pay off the technical debt after a certain release, feature/fix or by a certain date. Have an upper limit on the amount of debt you can accrue. Do not incur more debt after this limit has been reached. Sacrifice new features for stability through repayments.</p>
<h1 id="make-the-smallest-change-possible">Make the smallest change possible</h1>
<p>If you do decide to take on some technical debt, try to make it as small as possible. This is not the time to change the core architecture or make other sweeping changes. Make the change as small as possible. Make sure all your unit and integration tests pass. If they don’t, make the smallest change possible to get them to pass or take them out of the build.</p>
<blockquote>
<p>It’s more important to have a suit of working tests that you can rely on over just ignoring failing tests. If you start ignoring test failures you will never have full confidence in your test suite as some of them are known to fail.</p>
</blockquote>
<h1 id="document-your-debts">Document your debts</h1>
<p>Document the reasons for incurring the debt directly in the code that is affected by it. This can be done using comments or TODOs that you can come back to later. After you incur technical debt, add it to a debt register of some kind. This could be a wiki page, card wall or even a bunch of red postits on a wall or whiteboard. This will be a constant reminder of the debt you have already incurred. It also will help you to pay back this debt ASAP and prevent you from taking unnecessary new debt. As the wiki page or the wall grows, you know you are in trouble.</p>
<h1 id="pay-off-your-debts">Pay off your debts</h1>
<p>Completely rewrite any code hacks documented in your debt registry. Reintroduce all excluded tests. Make them pass. Add more tests. Refactor. Win. :)</p>]]></description>
    <pubDate>Thu, 09 Apr 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-04-09-calculated-risks-have-a-critical-mass.html</guid>
</item>
<item>
    <title>A Man that can't Whisper</title>
    <link>http://blog.ssanj.net/posts/2015-04-09-a-man-that-cant-whisper.html</link>
    <description><![CDATA[<p><a href="http://www.dannybhoy.com">Danny Bhoy</a> is a very funny Scottish-Indian comedian. He has toured Australia many times and I’ve had the pleasure of attending some of his gigs.</p>
<p>More recently I watched him on a Netflix special, where he said something quite profound:</p>
<p class="quote">
I’ll tell you one thing, I’m not gonna go on a Safari with a man that can’t whisper.
</p>

<p>True for Safaris and life.</p>]]></description>
    <pubDate>Thu, 09 Apr 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-04-09-a-man-that-cant-whisper.html</guid>
</item>
<item>
    <title>Workplaces are a Snapshot in Time</title>
    <link>http://blog.ssanj.net/posts/2015-03-29-workplaces-are-a-snapshot-in-time.html</link>
    <description><![CDATA[<p>Work places are like a snapshot in time. The people, the culture, the technology etc are in a constant state of flux. Some people leave. Others join. Technology is replaced frequently. Methodologies change. Fortunes are made and lost.</p>
<p>I had the recent good fortune to go back to one of my previous work places. I had worked there six years prior and had left swearing never to return. I had since heard good things and had returned. The place had almost completely changed. Sure, there were pockets of “old” behaviour lying around but for the most part it was a completely different organisation. Different people, technologies, methodologies, philosophies - you name it.</p>
<p>Whenever you work somewhere try and soak it all in. Chances are that the exact combination of things around you will never be the same. Enjoy the uniqueness of the present.</p>]]></description>
    <pubDate>Sun, 29 Mar 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-03-29-workplaces-are-a-snapshot-in-time.html</guid>
</item>
<item>
    <title>Don't be Complacent</title>
    <link>http://blog.ssanj.net/posts/2015-03-29-dont-be-complacent.html</link>
    <description><![CDATA[<p>Focus on learning something hard to remind yourself that there are many things you do not know.</p>
<p>Keep learning. Be humble.</p>]]></description>
    <pubDate>Sun, 29 Mar 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-03-29-dont-be-complacent.html</guid>
</item>
<item>
    <title>Future Execution Order</title>
    <link>http://blog.ssanj.net/posts/2015-03-22-future-execution-order.html</link>
    <description><![CDATA[<p>Futures had me confused. For some reason I had assumed that the execution of Futures were somehow linked to for-comprehensions. I had somehow assumed that you compose your Futures first and then run them when you were good and ready. Something similar to the Reader Monad in Haskell. I couldn’t have been more wrong.</p>
<h2 id="defining-futures-outside-a-for-comprehension">Defining Futures outside a for-comprehension</h2>
<p>Let’s take a simple example. First I define an <strong>iterate</strong> method that takes in a name and a number. The name is used to track the Future that is iterating. The method basically loops form 1 to the number passed in while printing out its current iteration. It then sleeps for 250 ms. It prints out when it is done at the end. All very simple.</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">
  <span class="kw">final</span> <span class="kw">def</span> <span class="fu">iterate</span>(name:String, n:Int): Int = {
    <span class="fu">println</span>(s<span class="st">&quot;defining $name&quot;</span>)
    (<span class="dv">1</span> to n).<span class="fu">foreach</span> { n =&gt;
      <span class="fu">println</span>(s<span class="st">&quot;$name sleeping for item: $n&quot;</span>)
      Thread.<span class="fu">sleep</span>(<span class="dv">250</span>)
    }

    <span class="fu">println</span>(s<span class="st">&quot;$name done&quot;</span>)
    n
  }</code></pre>
<p>Let’s take Scenario 1. This scenario creates two Futures: <strong>f1</strong> and <strong>f2</strong> with ten and two iterations respectively. It then sleeps for ten seconds after which it processes the results of the Futures and sums them up to give another Future: <strong>f3</strong>. We then wait for a maximum of one minute for <strong>f3</strong> to complete and print out “done”.</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">    <span class="kw">val</span> f1: Future[Int] = Future {
      <span class="fu">iterate</span>(<span class="st">&quot;f1&quot;</span>, <span class="dv">10</span>)
    }
    <span class="kw">val</span> f2: Future[Int] = Future {
      <span class="fu">iterate</span>(<span class="st">&quot;f2&quot;</span>, <span class="dv">2</span>)
    }

    Thread.<span class="fu">sleep</span>(<span class="dv">10000</span>) <span class="co">//sleep for 10 seconds</span>

    <span class="fu">println</span>(<span class="st">&quot;before comprehension&quot;</span>)

    <span class="kw">val</span> f3:Future[Int] = <span class="kw">for</span> {
      x &lt;- {<span class="fu">println</span>(<span class="st">&quot;f1 -&gt;&quot;</span>); f1}
      y &lt;- {<span class="fu">println</span>(<span class="st">&quot;f2 -&gt;&quot;</span>); f2}
    } <span class="kw">yield</span> x + y

    f3.<span class="fu">onComplete</span>(_ =&gt; <span class="fu">println</span>(<span class="st">&quot;f3 done&quot;</span>))

    <span class="fu">println</span>(<span class="st">&quot;after comprehension&quot;</span>)

    <span class="kw">val</span> result = Await.<span class="fu">result</span>(f3, Duration(<span class="dv">1</span>, TimeUnit.<span class="fu">MINUTES</span>))

    <span class="fu">println</span>(s<span class="st">&quot;done with $result&quot;</span>)</code></pre>
<p>What is the output of the above program?</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">defining</span> f1
<span class="kw">defining</span> f2
<span class="kw">f2</span> sleeping for item: 1
<span class="kw">f1</span> sleeping for item: 1
<span class="kw">f2</span> sleeping for item: 2
<span class="kw">f1</span> sleeping for item: 2
<span class="kw">f1</span> sleeping for item: 3
<span class="kw">f2</span> done
<span class="kw">f1</span> sleeping for item: 4
<span class="kw">f1</span> sleeping for item: 5
<span class="kw">f1</span> sleeping for item: 6
<span class="kw">f1</span> sleeping for item: 7
<span class="kw">f1</span> sleeping for item: 8
<span class="kw">f1</span> sleeping for item: 9
<span class="kw">f1</span> sleeping for item: 10
<span class="kw">f1</span> done
<span class="kw">before</span> comprehension
<span class="kw">f1</span> -<span class="kw">&gt;</span>
<span class="kw">f2</span> -<span class="kw">&gt;</span>
<span class="kw">after</span> comprehension
<span class="kw">f3</span> done
<span class="kw">done</span> <span class="kw">with</span> 12</code></pre>
<p>What does this tell us? This tells us that the Futures: <strong>f1 </strong> and <strong>f2 </strong> start executing almost immediately after they are defined and they run concurrently. <strong>f2 </strong> finishes before <strong>f1 </strong>. <strong>f1 </strong> finishes before the for-comprehension is reached. The for-comprehension executes and creates a Future <strong>f3 </strong> which starts executing in the background. The values of <strong>f1 </strong> and <strong>f2 </strong> are extracted in that order and we are done when <strong>f3 </strong> finishes.</p>
<p>The point in time when a Future starts executing has nothing to do with for-comprehensions - as long as the Futures are defined outside the for-comprehension (more on this below.) The main thread of execution continues along its merry way without blocking at the for-comprehension and waiting for a result. The for-comprehension also creates a new Future which then immediately begins running the computation asynchronously. All very curious.</p>
<h2 id="defining-futures-inside-a-for-comprehension">Defining Futures inside a for-comprehension</h2>
<p>Let’s look at Scenario 2. This scenario basically creates two Futures within the for-comprehension: <strong>f1</strong> and <strong>f2</strong> with ten and two iterations respectively, as in Scenario 1. It then processes the results of the Futures within the for-comprehension and sums them up to give another Future: <strong>f3</strong>. We then wait for a maximum of one minute for <strong>f3</strong> to complete and print out “done”.</p>
<p>but this time define the Futures f1 and f2 within the for-comprehension.</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">    <span class="fu">println</span>(<span class="st">&quot;before comprehension&quot;</span>)

    <span class="kw">val</span> f3:Future[Int] = <span class="kw">for</span> {
      x &lt;- Future { <span class="fu">println</span>(<span class="st">&quot;f1 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f1&quot;</span>, <span class="dv">10</span>) }
      y &lt;- Future { <span class="fu">println</span>(<span class="st">&quot;f2 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f2&quot;</span>, <span class="dv">2</span>) }
    } <span class="kw">yield</span> x + y

    f3.<span class="fu">onComplete</span>(_ =&gt; <span class="fu">println</span>(<span class="st">&quot;f3 done&quot;</span>))

    <span class="fu">println</span>(<span class="st">&quot;after comprehension&quot;</span>)

    <span class="kw">val</span> result = Await.<span class="fu">result</span>(f3, Duration(<span class="dv">1</span>, TimeUnit.<span class="fu">MINUTES</span>))

    <span class="fu">println</span>(s<span class="st">&quot;done with $result&quot;</span>)</code></pre>
<p>What is the output of the above program?</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">before</span> comprehension
<span class="kw">f1</span> -<span class="kw">&gt;</span>
<span class="kw">after</span> comprehension
<span class="kw">defining</span> f1
<span class="kw">f1</span> sleeping for item: 1
<span class="kw">f1</span> sleeping for item: 2
<span class="kw">f1</span> sleeping for item: 3
<span class="kw">f1</span> sleeping for item: 4
<span class="kw">f1</span> sleeping for item: 5
<span class="kw">f1</span> sleeping for item: 6
<span class="kw">f1</span> sleeping for item: 7
<span class="kw">f1</span> sleeping for item: 8
<span class="kw">f1</span> sleeping for item: 9
<span class="kw">f1</span> sleeping for item: 10
<span class="kw">f1</span> done
<span class="kw">f2</span> -<span class="kw">&gt;</span>
<span class="kw">defining</span> f2
<span class="kw">f2</span> sleeping for item: 1
<span class="kw">f2</span> sleeping for item: 2
<span class="kw">f2</span> done
<span class="kw">f3</span> done
<span class="kw">done</span> <span class="kw">with</span> 12</code></pre>
<p>We can see that Future: <strong>f1</strong>, starts executing only after the for-comprehension defined. We can see that the main thread of execution does not block on the for-comprehension and continues executing. <strong>f2</strong> has not started executing at all. It is only once <strong>f1</strong> completes that <strong>f2</strong> starts executing. We now have synchronous execution as opposed to asynchronous execution of <strong>f1</strong> and <strong>f2</strong>. No concurrency here. Once <strong>f2</strong> completes, <strong>f3</strong> finishes straight after and we are done.</p>
<p>So it looks like these are the general rules of Future execution:</p>
<ol style="list-style-type: decimal">
<li>Define Futures you want to run concurrently outside a for-comprehension.</li>
<li>Define Futures you want to run sequentially inside a for-comprehension.</li>
</ol>
<h2 id="what-about-zip">What about zip?</h2>
<p>Just when we had everything nice and tidy I came across the <strong>zip</strong> method on <a href="http://www.scala-lang.org/files/archive/nightly/docs/library/index.html#scala.concurrent.Future">scala.concurrent.Future</a>. Let’s run Scenario 2 with the zip method and call it Scenario 3.</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">    <span class="fu">println</span>(<span class="st">&quot;before comprehension&quot;</span>)

    <span class="kw">val</span> f3:Future[Int] = <span class="kw">for</span> {
      (x, y) &lt;- Future { <span class="fu">println</span>(<span class="st">&quot;f1 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f1&quot;</span>, <span class="dv">10</span>) } zip Future {
        <span class="fu">println</span>(<span class="st">&quot;f2 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f2&quot;</span>, <span class="dv">2</span>) }
    } <span class="kw">yield</span> x + y

    f3.<span class="fu">onComplete</span>(_ =&gt; <span class="fu">println</span>(<span class="st">&quot;f3 done&quot;</span>))

    <span class="fu">println</span>(<span class="st">&quot;after comprehension&quot;</span>)

    <span class="kw">val</span> result = Await.<span class="fu">result</span>(f3, Duration(<span class="dv">1</span>, TimeUnit.<span class="fu">MINUTES</span>))

    <span class="fu">println</span>(s<span class="st">&quot;done with $result&quot;</span>)</code></pre>
<p>What is the output of the above program?</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">before</span> comprehension
<span class="kw">f1</span> -<span class="kw">&gt;</span>
<span class="kw">f2</span> -<span class="kw">&gt;</span>
<span class="kw">defining</span> f2
<span class="kw">defining</span> f1
<span class="kw">f1</span> sleeping for item: 1
<span class="kw">f2</span> sleeping for item: 1
<span class="kw">after</span> comprehension
<span class="kw">f2</span> sleeping for item: 2
<span class="kw">f1</span> sleeping for item: 2
<span class="kw">f2</span> done
<span class="kw">f1</span> sleeping for item: 3
<span class="kw">f1</span> sleeping for item: 4
<span class="kw">f1</span> sleeping for item: 5
<span class="kw">f1</span> sleeping for item: 6
<span class="kw">f1</span> sleeping for item: 7
<span class="kw">f1</span> sleeping for item: 8
<span class="kw">f1</span> sleeping for item: 9
<span class="kw">f1</span> sleeping for item: 10
<span class="kw">f1</span> done
<span class="kw">f3</span> done
<span class="kw">done</span> <span class="kw">with</span> 12</code></pre>
<p>It looks very much like Scenario 2, where we had <strong>f1</strong> and <strong>f2</strong> running concurrently. So how does this work? The <strong>zip</strong> function is defined on Future as:</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">def</span> zip[U](that: Future[U]): Future[(T, U)] = {
    <span class="kw">implicit</span> <span class="kw">val</span> ec = internalExecutor
    <span class="kw">val</span> p = Promise[(T, U)]()
    onComplete {
      <span class="kw">case</span> f: Failure[_] =&gt; p complete f.<span class="fu">asInstanceOf</span>[Failure[(T, U)]]
      <span class="kw">case</span> <span class="fu">Success</span>(s) =&gt; that onComplete { c =&gt; p.<span class="fu">complete</span>(c map { s2 =&gt; (s, s2) }) }
    }
    p.<span class="fu">future</span>
  }</code></pre>
<p>So how do <strong>f1</strong> and <strong>f2</strong> run concurrently? The answer lies in the how the second Future is passed to the <strong>zip</strong> method. <strong>f1</strong> starts executing immediately before its <strong>zip</strong> method is called. Since <strong>zip</strong> takes in a <code>(that: Future[U])</code> instead of a <code>(that: =&gt; Future[U])</code>, <strong>that</strong> starts executing immediately as a side-effect when passed to the <strong>zip</strong> method. Talk about yucky.</p>
<p>So if I wrote function: <strong>zip2</strong> that took <strong>that</strong> as a function we should see the same results as Scenario two. Let’s call this Scenario 4.</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">  <span class="kw">private</span> <span class="kw">def</span> zip2[T,U](one: Future[T])(two: =&gt; Future[U])(<span class="kw">implicit</span> ec:ExecutionContext): Future[(T, U)] = {
    <span class="kw">val</span> p = Promise[(T, U)]()
    one.<span class="fu">onComplete</span> {
      <span class="kw">case</span> f: Failure[_] =&gt; p complete f.<span class="fu">asInstanceOf</span>[Failure[(T, U)]]
      <span class="kw">case</span> <span class="fu">Success</span>(s) =&gt; two onComplete { c =&gt; p.<span class="fu">complete</span>(c map { s2 =&gt; (s, s2) }) }
    }
    p.<span class="fu">future</span>
  }


    <span class="fu">println</span>(<span class="st">&quot;before comprehension&quot;</span>)

    <span class="kw">val</span> f3:Future[Int] = <span class="kw">for</span> {
      (x, y) &lt;- <span class="fu">zip2</span>(Future { <span class="fu">println</span>(<span class="st">&quot;f1 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f1&quot;</span>, <span class="dv">10</span>) })(Future {<span class="fu">println</span>(<span class="st">&quot;f2 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f2&quot;</span>, <span class="dv">2</span>) })
    } <span class="kw">yield</span> x + y

    f3.<span class="fu">onComplete</span>(_ =&gt; <span class="fu">println</span>(<span class="st">&quot;f3 done&quot;</span>))

    <span class="fu">println</span>(<span class="st">&quot;after comprehension&quot;</span>)

    <span class="kw">val</span> result = Await.<span class="fu">result</span>(f3, Duration(<span class="dv">1</span>, TimeUnit.<span class="fu">MINUTES</span>))

    <span class="fu">println</span>(s<span class="st">&quot;done with $result&quot;</span>)</code></pre>
<p>We can see that <strong>f1</strong> has to complete before <strong>f2</strong>:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">before</span> comprehension
<span class="kw">f1</span> -<span class="kw">&gt;</span>
<span class="kw">defining</span> f1
<span class="kw">after</span> comprehension
<span class="kw">f1</span> sleeping for item: 1
<span class="kw">f1</span> sleeping for item: 2
<span class="kw">f1</span> sleeping for item: 3
<span class="kw">f1</span> sleeping for item: 4
<span class="kw">f1</span> sleeping for item: 5
<span class="kw">f1</span> sleeping for item: 6
<span class="kw">f1</span> sleeping for item: 7
<span class="kw">f1</span> sleeping for item: 8
<span class="kw">f1</span> sleeping for item: 9
<span class="kw">f1</span> sleeping for item: 10
<span class="kw">f1</span> done
<span class="kw">f2</span> -<span class="kw">&gt;</span>
<span class="kw">defining</span> f2
<span class="kw">f2</span> sleeping for item: 1
<span class="kw">f2</span> sleeping for item: 2
<span class="kw">f2</span> done
<span class="kw">f3</span> done
<span class="kw">done</span> <span class="kw">with</span> 12</code></pre>
<p>If we <strong>zip</strong> within a for-comprehension, then Futures run concurrently right? That depends. We still need to define the <strong>zip</strong> call in the first step of the for-comprehension. Take Scenario 5 as an example.</p>
<pre class="sourceCode scala scrollx"><code class="sourceCode scala">    <span class="fu">println</span>(<span class="st">&quot;before comprehension&quot;</span>)

    <span class="kw">val</span> f4:Future[Int] = <span class="kw">for</span> {
      a &lt;- Future {<span class="fu">println</span>(<span class="st">&quot;f1 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f1&quot;</span>, <span class="dv">5</span>) }
      (x, y) &lt;- Future { <span class="fu">println</span>(<span class="st">&quot;f2 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f2&quot;</span>, <span class="dv">10</span>) } zip Future {
        <span class="fu">println</span>(<span class="st">&quot;f3 -&gt;&quot;</span>); <span class="fu">iterate</span>(<span class="st">&quot;f3&quot;</span>, <span class="dv">2</span>) }
    } <span class="kw">yield</span> a + x + y

    f4.<span class="fu">onComplete</span>(_ =&gt; <span class="fu">println</span>(<span class="st">&quot;f4 done&quot;</span>))

    <span class="fu">println</span>(<span class="st">&quot;after comprehension&quot;</span>)

    <span class="kw">val</span> result = Await.<span class="fu">result</span>(f4, Duration(<span class="dv">1</span>, TimeUnit.<span class="fu">MINUTES</span>))

    <span class="fu">println</span>(s<span class="st">&quot;done with $result&quot;</span>)</code></pre>
<p>If we look at the output, we see that <strong>f1</strong> has to complete before <strong>f2</strong> and <strong>f3</strong> start executing concurrently.</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">before</span> comprehension
<span class="kw">f1</span> -<span class="kw">&gt;</span>
<span class="kw">after</span> comprehension
<span class="kw">defining</span> f1
<span class="kw">f1</span> sleeping for item: 1
<span class="kw">f1</span> sleeping for item: 2
<span class="kw">f1</span> sleeping for item: 3
<span class="kw">f1</span> sleeping for item: 4
<span class="kw">f1</span> sleeping for item: 5
<span class="kw">f1</span> done
<span class="kw">f2</span> -<span class="kw">&gt;</span>
<span class="kw">defining</span> f2
<span class="kw">f2</span> sleeping for item: 1
<span class="kw">f3</span> -<span class="kw">&gt;</span>
<span class="kw">defining</span> f3
<span class="kw">f3</span> sleeping for item: 1
<span class="kw">f3</span> sleeping for item: 2
<span class="kw">f2</span> sleeping for item: 2
<span class="kw">f3</span> done
<span class="kw">f2</span> sleeping for item: 3
<span class="kw">f2</span> sleeping for item: 4
<span class="kw">f2</span> sleeping for item: 5
<span class="kw">f2</span> sleeping for item: 6
<span class="kw">f2</span> sleeping for item: 7
<span class="kw">f2</span> sleeping for item: 8
<span class="kw">f2</span> sleeping for item: 9
<span class="kw">f2</span> sleeping for item: 10
<span class="kw">f2</span> done
<span class="kw">f4</span> done
<span class="kw">done</span> <span class="kw">with</span> 17</code></pre>
<h2 id="where-should-we-define-futures">Where should we Define Futures?</h2>
<p>Yikes. What a minefield. So the rules seem to be:</p>
<ol style="list-style-type: decimal">
<li>If you defined Futures outside a for-comprehension they will run immediately and concurrently.</li>
<li>If you define Futures inside a for-comprehension they will run sequentially (if not zipped).</li>
<li>If you zip Futures in the first step of the for-comprehension they will run immediately and concurrently.</li>
<li>If you zip Futures in secondary steps of the for-comprehension, they will not run until all preceding steps have completed successfully. They will then run concurrently.</li>
</ol>
<p>The source code for the above scenarios can be found on <a href="https://github.com/ssanj/future-execution-order-blogpost-example">github</a></p>]]></description>
    <pubDate>Sun, 22 Mar 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-03-22-future-execution-order.html</guid>
</item>
<item>
    <title>Sanity in Numbers</title>
    <link>http://blog.ssanj.net/posts/2015-03-18-sanity-in-numbers.html</link>
    <description><![CDATA[<p>We’ve all had times where we were personally tasked to do something really stressful at work that was of “critical” importance. Mostly likely the work needed to be completed yesterday. Other times we could be losing a client if we don’t implement feature X which was promised to them. For some, this is a daily occurrence. When this inevitably happens, ask to be part of team. This improves your chances of success even with one additional person. Here’s why:</p>
<ol style="list-style-type: decimal">
<li>It shares the stress amongst the team. No one person carries the full burden.</li>
<li>Pushing back on unreasonable requests is much easier when you have more voices of “reason”.</li>
<li>You get second/third/fourth opinions about what needs to be done, when it needs to be done by and how it should be done.</li>
<li>Your team becomes the sanity check in insane situations.</li>
</ol>
<p>Some scenarios where having a team is useful:</p>
<ol style="list-style-type: decimal">
<li>Unreasonable deadlines.</li>
<li>Massive architectural changes.</li>
<li>“Quick” fixes that could destabilise your production system.</li>
<li>“Must have” features then need to be completed ASAP.</li>
<li>Migration or deletion of production data.</li>
</ol>
<p>You might be refused even one additional person to share this “critical” piece of work. You then have to ask yourself: “how critical is this piece of work if the company doesn’t want to put more than one person on it?” Quite likely you’ll see that it’s not critical at all.</p>]]></description>
    <pubDate>Wed, 18 Mar 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-03-18-sanity-in-numbers.html</guid>
</item>
<item>
    <title>Slowing Down</title>
    <link>http://blog.ssanj.net/posts/2015-03-15-slowing-down.html</link>
    <description><![CDATA[<p>In her book <a href="http://www.amazon.com/Inner-Simplicity-Regain-Peace-Nourish/dp/078688097X">Inner Simplicity</a>, Elaine St. James, says that “Hurrying becomes a habit”. Hurrying seems to have its own momentum.</p>
<p>She also posits that being around busy people makes it that much harder for you to slow down. She advises that we should start to think about how we can slow down our routine. This might include things like waking up a little earlier so you can really enjoy your breakfast instead of rushing out the door, focusing on a single task when you have ten other tasks pending, or leisurely walking to work instead of speed-walking. She also recommends avoiding fast-paced restaurants for lunch and to instead head to a park or a quite place and spend time in nature.</p>
<p>One thing I’ve been trialling has been to stop constantly learning new technologies on the train ride to and from work. I’ve started just listening to some music or simply staring out the window for at least one of the daily commutes. This has really freed up my mind to ponder things more deeply. It has also stopped me rushing as much as I used to.</p>
<p>Elaine observes that:</p>
<blockquote>
<p>Over and over I found that rushing through a project meant getting it wrong and losing time in the end by having to do it over either partially or completely. Take your time to do it right in the first place and enjoy the process as you go along.</p>
</blockquote>
<p>This is something I’ve found to be true. Rushing a project never gives you any satisfaction. The results are always less than optimal. The best part about slowing down is the enjoyment you get by being more present in what you are doing. You notice more things around you. You do better work. You react less. You enjoy life more. :)</p>]]></description>
    <pubDate>Sun, 15 Mar 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-03-15-slowing-down.html</guid>
</item>
<item>
    <title>Don't Wait for Moods</title>
    <link>http://blog.ssanj.net/posts/2015-03-15-dont-wait-for-moods.html</link>
    <description><![CDATA[<div>
<div class="quote">
I don’t wait for moods. You accomplish nothing if you do that. Your mind must know it has to get down to work.
</div>
<div class="attribution">
Pearl S. Buck
</div>
</div>]]></description>
    <pubDate>Sun, 15 Mar 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-03-15-dont-wait-for-moods.html</guid>
</item>
<item>
    <title>Do your Best Work Everyday</title>
    <link>http://blog.ssanj.net/posts/2015-03-15-do-your-best-work-everyday.html</link>
    <description><![CDATA[<p>Do your best work every day. No excuses. No exceptions.</p>]]></description>
    <pubDate>Sun, 15 Mar 2015 00:00:00 UT</pubDate>
    <guid>http://blog.ssanj.net/posts/2015-03-15-do-your-best-work-everyday.html</guid>
</item>

    </channel> 
</rss>
