<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Contravariant functors are Weird</title>
    <meta name="viewport" content="width=device-width">
    
    <meta name="description" content="What are contravariant functors?">
    
    <link rel="canonical" href="https://blog.ssanj.net/posts/2020-06-13-contravariant-functors-are-weird.html">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../css/main-2024-05-08.css">
    <link rel="stylesheet" type="text/css" href="../css/example-2024-05-05.css">
    <link rel="stylesheet" href="../css/syntax-2024-05-05.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    
  </head>

    <body>
      
          <div class="page-content">
      <div class="wrap">
        <div class="post">
          <header class="post-header">
            <h1><a href="../">Contravariant functors are Weird</a></h1>
            <p class="meta">June 13, 2020&nbsp;<span class="post-tag"><a title="All pages tagged 'haskell'." href="../tags/haskell.html">haskell</a></span></p>
          </header>
          <article class="post-content">
            <p>Just a note about nomenclature before we start; I’ll use “functor” to represent the <a href="https://bartoszmilewski.com/2015/01/20/functors/">categorical meaning</a> of the concept:</p>
<blockquote>
<p>A functor is a mapping between categories</p>
</blockquote>
<p>and <code>Functor</code> and <code>Contravariant</code> to specify the typeclass encodings of functors.</p>
<hr />
<p>Let’s begin!</p>
<p>Contravariant functors are odd aren’t they? Covariant functors (which are modelled by the <code>Functor</code> typeclass) are quite straightforward but <strong>contra</strong>variant functors as their name implies seem to be the complete opposite.</p>
<p>Before we get into what a contravariant functor is, it’s useful to look at the <code>Functor</code> <a href="https://wiki.haskell.org/Typeclassopedia">typeclass</a> which we know and love.</p>
<h2 id="functor">Functor</h2>
<p>A <code>Functor</code> is defined as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>We often understand a <code>Functor</code> to be a “container” or a “producer” of some type, where the function supplied to <code>fmap</code> is applied to the elements that are “contained” or “produced” in some type constructor<a href="#type-constructor-1"><sup>1</sup></a> <code>f</code>.</p>
<p>A simple example would be the list (<code>[]</code>) type, that can represent zero or more values. Given a <code>[a]</code> we can turn it into a <code>[b]</code> when given a function <code>a -&gt; b</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> [] a <span class="ot">=</span> [] <span class="op">|</span> a <span class="op">:</span> [a]  <span class="co">-- an approximation of the [] data type</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> _ [] <span class="ot">=</span> []</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> <span class="fu">fmap</span> f xs</span></code></pre></div>
<p>In the example below we convert a <code>[Int]</code> into a <code>[String]</code> given a function <code>Int -&gt; String</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Semigroup</span> ((&lt;&gt;))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">myInts ::</span> [<span class="dt">Int</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>myInts <span class="ot">=</span> [<span class="dv">1</span> <span class="op">..</span> <span class="dv">5</span>]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">emptyInts ::</span> [<span class="dt">Int</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>emptyInts <span class="ot">=</span> []</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="ot">intToString ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>intToString n <span class="ot">=</span> (<span class="fu">show</span> n) <span class="op">&lt;&gt;</span> <span class="st">&quot;!&quot;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="ot">myStrings ::</span> [<span class="dt">String</span>]</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>myStrings <span class="ot">=</span> <span class="fu">fmap</span> intToString myInts <span class="co">-- [&quot;1!&quot;,&quot;2!&quot;,&quot;3!&quot;,&quot;4!&quot;,&quot;5!&quot;]</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="ot">myEmptyString ::</span> []</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>myEmptyString <span class="ot">=</span> <span class="fu">fmap</span> intToString emptyInts  <span class="co">-- []</span></span></code></pre></div>
<p>Another example would the <code>Maybe</code> data type, that represents a value that may or may not exist.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> _ <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<p>In the example below we convert a <code>Maybe Int</code> into a <code>Maybe String</code> given a function <code>Int -&gt; String</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Semigroup</span> ((&lt;&gt;))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">maybeInt ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>maybeInt <span class="ot">=</span> <span class="dt">Just</span> <span class="dv">10</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="ot">notInt ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>notInt <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="ot">intToString ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>intToString n <span class="ot">=</span> (<span class="fu">show</span> n) <span class="op">&lt;&gt;</span> <span class="st">&quot;!&quot;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="ot">maybeString ::</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>maybeString <span class="ot">=</span> <span class="fu">fmap</span> intToString maybeInt <span class="co">-- Just &quot;10!&quot;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="ot">notString ::</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>notString <span class="ot">=</span> <span class="fu">fmap</span> intToString notInt <span class="co">-- Nothing</span></span></code></pre></div>
<p>The <code>Functor</code> typeclass has laws, that ensure <code>Functor</code> instances behave in a predictable way.</p>
<h3 id="laws">Laws</h3>
<h4 id="identity">Identity</h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> <span class="fu">id</span> <span class="op">==</span> <span class="fu">id</span></span></code></pre></div>
<p>Essentially if you do nothing to the value of a <code>Functor</code>, you get the same <code>Functor</code> you started with.</p>
<h4 id="composition">Composition</h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (f <span class="op">.</span> g) <span class="op">==</span> <span class="fu">fmap</span> f <span class="op">.</span> <span class="fu">fmap</span> g</span></code></pre></div>
<p>If you convert the result of a Functor by <code>fmap</code>ing with a function <code>g</code> and then <code>fmap</code>ing that result with a subsequent function <code>f</code>, it’s the same as composing functions <code>g</code> and <code>f</code> (<code>f . g</code>) and then <code>fmap</code>ing once.</p>
<figure>
<img src="../images/contravariant/functor-laws-ct.png" alt="Functor Laws" />
<figcaption aria-hidden="true">Functor Laws</figcaption>
</figure>
<h3 id="the-wrong-type-of-fmap">The Wrong Type of fmap</h3>
<p>Now let’s look at something a little different. Let’s create a data type to wrap a predicate of some sort. A predicate is something that will evaluate to a <code>Bool</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Predicate</span> a <span class="ot">=</span> <span class="dt">Predicate</span> {<span class="ot"> getPredicate ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> }</span></code></pre></div>
<p>An example of a Predicate is <code>greaterThanTen</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">greaterThanTen ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>greaterThanTen <span class="ot">=</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="op">&gt;</span> <span class="dv">10</span>)</span></code></pre></div>
<p>that tests whether a number is greater than ten.</p>
<p>We can run with it <code>getPredicate</code> and an <code>Int</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>getPredicate greateThanTen <span class="dv">5</span>  <span class="co">-- False</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>getPredicate greateThanTen <span class="dv">11</span> <span class="co">-- True</span></span></code></pre></div>
<p>It could be useful to define a <code>Functor</code> instance for Predicate - say if we have a <code>Predicate Int</code> and we want to convert it into a <code>Predicate String</code> when we have a <code>Int -&gt; String</code> function. Let’s try and implement that:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Predicate</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- fmap (a -&gt; b) -&gt; Predicate a -&gt; Predicate b</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Predicate</span> p) <span class="ot">=</span> <span class="dt">Predicate</span> (\b <span class="ot">-&gt;</span> <span class="fu">undefined</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Predicate</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)) <span class="ot">=</span> <span class="dt">Predicate</span> (\b <span class="ot">-&gt;</span> <span class="fu">undefined</span>)  <span class="co">-- expanding p</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> (a <span class="ot">-&gt;</span> b) (<span class="dt">Predicate</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)) <span class="ot">=</span> <span class="dt">Predicate</span> (\b <span class="ot">-&gt;</span> <span class="fu">undefined</span>) <span class="co">-- expanding f</span></span></code></pre></div>
<p>Now we’ve run into a small problem:</p>
<blockquote>
<p>How do we compose (a -&gt; Bool) and (a -&gt; b) to give us a (b -&gt; Bool) ?</p>
</blockquote>
<p>We are given a <code>b</code> but we don’t have access to any functions that actually use a <code>b</code>.</p>
<p>The problem is that we can’t. It’s because of something called “polarity” of the type variable <code>a</code>. No <code>Functor</code> instance for you <code>Predicate</code>.</p>
<figure>
<img src="../images/contravariant/sad-panda.png" alt="sad-panda by Nick Bluth" />
<figcaption aria-hidden="true">sad-panda by <a href="https://thenounproject.com/nickbluth/collection/pandas">Nick Bluth</a></figcaption>
</figure>
<h2 id="polarity">Polarity</h2>
<p>Polarity is a way of representing <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">variance</a> using the position of type variables. Let’s take a simple function <code>a -&gt; b</code> as an example.</p>
<figure>
<img src="../images/contravariant/function-polarity.png" alt="Function Polarity" />
<figcaption aria-hidden="true">Function Polarity</figcaption>
</figure>
<p>If a type variable is in <strong>input</strong> position like <code>a</code> it is given a <strong>negative</strong> polarity. If it is in an <strong>output</strong> position like <code>b</code> then it is given a <strong>positive</strong> polarity.</p>
<p>These polarities map directly to variant types.</p>
<table>
<thead>
<tr class="header">
<th>Polarity</th>
<th>Variance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Positive</td>
<td>Covariant</td>
</tr>
<tr class="even">
<td>Negative</td>
<td>Contravariant</td>
</tr>
<tr class="odd">
<td>Both</td>
<td>Invariant</td>
</tr>
</tbody>
</table>
<p>What this means is that <code>Functor</code>s (which are actually covariant functors) require a type constructor in a covariant position in order for you to define a <code>Functor</code> instance for that type.</p>
<p>Let’s look at a type that we know has a <code>Functor</code> instance like <code>Maybe</code>:</p>
<figure>
<img src="../images/contravariant/maybe-polarity.png" alt="Polarity of the Maybe data type" />
<figcaption aria-hidden="true">Polarity of the Maybe data type</figcaption>
</figure>
<p>We can see that the type variable <code>a</code> occurs in a covariant (or output) position within the definition of the <code>Just</code> constructor.</p>
<p>Now let’s look at the definition of <code>Predicate</code> data type:</p>
<figure>
<img src="../images/contravariant/predicate-polarity.png" alt="Polarity of the Predicate data type" />
<figcaption aria-hidden="true">Polarity of the Predicate data type</figcaption>
</figure>
<p>We can see that the type variable <code>a</code> occurs in a contravariant (or input) position. This indicates that we can’t create a (covariant) <code>Functor</code> instance for this data type.</p>
<p>But we want to map things! What do we do?</p>
<h2 id="contravariant">Contravariant</h2>
<p>Welcome the <code>Contravariant</code> typeclass to the stage! It’s defined as:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Contravariant</span> f <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span></code></pre></div>
<p>Snazzy! <code>Contravariant</code> also takes some kind of type constructor <code>f</code> just like <code>Functor</code> but it has this weirdly named <code>contramap</code> function instead of <code>fmap</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">     fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="co">-- Functor</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a <span class="co">-- Contravariant</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                         <span class="op">^^^</span></span></code></pre></div>
<p>If we read <code>fmap</code> as:</p>
<blockquote>
<p>If you have an <code>a</code> in some context and a function that takes that <code>a</code> and converts it to a <code>b</code>, I can give you a context with a <code>b</code> in it.</p>
</blockquote>
<p>we can then read <code>contramap</code> as:</p>
<blockquote>
<p>If you have a context that needs an <code>a</code> and a function that can convert <code>b</code>s to
<code>a</code>s, I can give you a context that needs <code>b</code>s.</p>
</blockquote>
<p>But that probably doesn’t make much sense. So let’s try and look at this in terms of our non-<code>Functor</code>: <code>Predicate</code>. <code>Predicate</code> has a <strong>need</strong> for an <code>a</code>, which it then uses to tell if something about that <code>a</code> is True or False.</p>
<p>Let’s try and write a <code>Contravariant</code> instance for <code>Predicate</code> given that we know that the type <code>a</code> in <code>Predicate</code> occurs in an input position.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Predicate</span> <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- contramp (a -&gt; b) -&gt; f b -&gt; f a</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  contramap (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Predicate</span> b <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="co">-- substituting for `f` for Predicate</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  contramap aToB (<span class="dt">Predicate</span> bToBool) <span class="ot">=</span> <span class="dt">Predicate</span> (\a <span class="ot">-&gt;</span> <span class="fu">undefined</span>)</span></code></pre></div>
<p>Given that we have a function <code>a -&gt; b</code> and essentially a function of type <code>b -&gt; Bool</code> (wrapped inside a <code>Predicate b</code>), we can if given an <code>a</code>, convert it to a <code>b</code> using <code>aToB</code> and then give that <code>b</code> to <code>bToBool</code> to give us a <code>Bool</code>.</p>
<p>Here’s a slightly long-form implementation of the <code>Contravariant</code> instance for <code>Predicate</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Predicate</span> <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Predicate</span> b <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  contramap aToB (<span class="dt">Predicate</span> bToBool) <span class="ot">=</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Predicate</span> <span class="op">$</span> \a <span class="ot">-&gt;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> b    <span class="ot">=</span> aToB a</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>          bool <span class="ot">=</span> bToBool b</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> bool</span></code></pre></div>
<figure>
<img src="../images/contravariant/contramap-predicate.png" alt="contramap on Predicate" />
<figcaption aria-hidden="true">contramap on Predicate</figcaption>
</figure>
<p>or more succinctly:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Predicate</span> <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Predicate</span> b <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  contramap f (<span class="dt">Predicate</span> b) <span class="ot">=</span> <span class="dt">Predicate</span> <span class="op">$</span> b <span class="op">.</span> f</span></code></pre></div>
<p>We can see from the definition of <code>Predicate a</code> that all we are doing is running the supplied function <code>f</code> <strong>before</strong> the function within <code>Predicate b</code>. The reason we do that is to adapt a new input type to match an existing input type to gain some functionality.</p>
<p>If we revisit the (covariant) <code>Functor</code> instance for <code>Maybe</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> _ <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> aToB (<span class="dt">Just</span> a) <span class="ot">=</span> <span class="dt">Just</span> (aToB a)</span></code></pre></div>
<p>we can see that the function <code>aToB</code> is run <strong>after</strong> we have a value of <code>a</code>. We do that to convert a result of some type to another type.</p>
<figure>
<img src="../images/contravariant/fmap-maybe.png" alt="fmap on Maybe" />
<figcaption aria-hidden="true">fmap on Maybe</figcaption>
</figure>
<p>These are the essential differences between covariant and contravariant functors:</p>
<table>
<thead>
<tr class="header">
<th>Typeclass</th>
<th>Function runs</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Functor</td>
<td>after</td>
<td>Convert results</td>
</tr>
<tr class="even">
<td>Contravariant</td>
<td>before</td>
<td>Adapt inputs</td>
</tr>
</tbody>
</table>
<p>Now that we know the essential difference between <code>Functor</code> and <code>Contravariant</code>, let’s look at how we can use <code>contramap</code> with our <code>Predicate</code> class.</p>
<p>Given that we already have a <code>Predicate</code> that determines whether a number is greater than ten:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">numGreaterThanTen ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>numGreaterThanTen <span class="ot">=</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="op">&gt;</span> <span class="dv">10</span>)</span></code></pre></div>
<p>say we want to write another <code>Predicate</code> that verifies that the length of String is greater than ten characters.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">strLengthGreaterThanTen ::</span> <span class="dt">Predicate</span> <span class="dt">String</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>strLengthGreaterThanTen <span class="ot">=</span> <span class="dt">Predicate</span> (\s <span class="ot">-&gt;</span> (<span class="fu">length</span> s) <span class="op">&gt;</span> <span class="dv">10</span>)</span></code></pre></div>
<p>Sure, that’s pretty contrived but bear with me. Let’s also say we have a <code>Person</code> data type and we want to know if a person’s name is over ten characters long - if so we consider that to be a long name.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span> {<span class="ot"> personName ::</span> <span class="dt">String</span>,<span class="ot"> personAge ::</span> <span class="dt">Int</span> }</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="ot">personLongName ::</span> <span class="dt">Predicate</span> <span class="dt">Person</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>personLongName <span class="ot">=</span> <span class="dt">Predicate</span> (\p <span class="ot">-&gt;</span> (<span class="fu">length</span> <span class="op">.</span> personName <span class="op">$</span> p) <span class="op">&gt;</span> <span class="dv">10</span>)</span></code></pre></div>
<p>And we can run these <code>Predicate</code>s as:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>getPredicate numGreaterThanTen <span class="dv">5</span> <span class="co">-- False</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>getPredicate numGreaterThanTen <span class="dv">20</span> <span class="co">-- True</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>getPredicate strLengthGreaterThanTen <span class="st">&quot;hello&quot;</span>       <span class="co">-- False</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>getPredicate strLengthGreaterThanTen <span class="st">&quot;hello world&quot;</span> <span class="co">-- True</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>getPredicate personLongName <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;John&quot;</span> <span class="dv">30</span>        <span class="co">-- False</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>getPredicate personLongName <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Bartholomew&quot;</span> <span class="dv">30</span> <span class="co">-- True</span></span></code></pre></div>
<p>And this is fine, but there’s some duplication across each of the <code>Predicate</code>s - namely the part where we compare a number to ten:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>(\n <span class="ot">-&gt;</span> n <span class="op">&gt;</span> <span class="dv">10</span>)  <span class="co">-- Int</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>(\s <span class="ot">-&gt;</span> (<span class="fu">length</span> s) <span class="op">&gt;</span> <span class="dv">10</span>) <span class="co">-- String</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>(\p <span class="ot">-&gt;</span> (<span class="fu">length</span> <span class="op">.</span> personName <span class="op">$</span> p) <span class="op">&gt;</span> <span class="dv">10</span>) <span class="co">-- Person</span></span></code></pre></div>
<p>It would be nice if we didn’t have to repeat ourselves.</p>
<p>If we look at the differences between <code>numGreaterThanTen</code>, <code>strLengthGreaterThanTen</code> and <code>personLongName</code> we can see that the only difference is that one works on an <code>Int</code> and the others work on <code>String</code> and <code>Person</code> respectively. <code>strLengthGreaterThanTen</code> and <code>personLongName</code> each convert their input types to an <code>Int</code> and then do the same comparison:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> (\(<span class="ot">n ::</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> num <span class="ot">=</span> <span class="fu">id</span> n</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> num <span class="op">&gt;</span> <span class="dv">10</span> <span class="co">-- (1)</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>) <span class="co">-- numGreaterThanTen</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> (\(<span class="ot">s ::</span> <span class="dt">String</span>) <span class="ot">-&gt;</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> num <span class="ot">=</span> <span class="fu">length</span> s</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> num <span class="op">&gt;</span> <span class="dv">10</span> <span class="co">-- (1)</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>) <span class="co">-- strLengthGreaterThanTen</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> (\(<span class="ot">p ::</span> <span class="dt">Person</span>) <span class="ot">-&gt;</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> name <span class="ot">=</span> personName p</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>      num  <span class="ot">=</span> <span class="fu">length</span> name</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> num <span class="op">&gt;</span> <span class="dv">10</span> <span class="co">-- (1)</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>) <span class="co">-- personLongName</span></span></code></pre></div>
<p>The above expansion of the functions demonstrates that even though the <code>Predicate</code>s themselves have different input types, at the end they are all converted to a number which is compared against the number ten. This is tagged with <code>(1)</code> in the above example.</p>
<p>We can also see that the only changes between the <code>Predicate</code>s is the conversion from one type to another <strong>before</strong> running our comparison function <code>(1)</code>. This is our clue that we can use <code>contramap</code> here to reuse some functionality.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">numGreaterThanTen ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>numGreaterThanTen <span class="ot">=</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="op">&gt;</span> <span class="dv">10</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="ot">strLengthGreaterThanTen2 ::</span> <span class="dt">Predicate</span> <span class="dt">String</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>strLengthGreaterThanTen2 <span class="ot">=</span> contramap <span class="fu">length</span> numGreaterThanTen <span class="co">-- convert the String to an Int, then pass it to numGreaterThanTen</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="ot">personLongName2 ::</span> <span class="dt">Predicate</span> <span class="dt">Person</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>personLongName2 <span class="ot">=</span> contramap (<span class="fu">length</span> <span class="op">.</span> personName) numGreaterThanTen <span class="co">-- convert the Person to an Int, then pass it to numGreaterThanTen</span></span></code></pre></div>
<p>We get the same results as before:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>getPredicate strLengthGreaterThanTen2 <span class="st">&quot;hello&quot;</span>       <span class="co">-- False</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>getPredicate strLengthGreaterThanTen2 <span class="st">&quot;hello world&quot;</span> <span class="co">-- True</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>getPredicate personLongName2 <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;John&quot;</span> <span class="dv">30</span>        <span class="co">-- False</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>getPredicate personLongName2 <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Bartholomew&quot;</span> <span class="dv">30</span> <span class="co">-- True</span></span></code></pre></div>
<p>Now we have rewritten <code>strLengthGreaterThanTen</code> and <code>personLongName</code> in terms of <code>numGreaterThanTen</code> by just running a function before it to convert the types. This is a simple example of a Contravariant Functor where we can reuse some existing functionality for a given type if we can convert from our other types to that type through some mapping function.</p>
<p>We can also go a little further and reuse even more:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">personLongName3 ::</span> <span class="dt">Predicate</span> <span class="dt">Person</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>personLongName3 <span class="ot">=</span> contramap personName strLengthGreaterThanTen <span class="co">-- convert the Person to a String, then pass it to strLengthGreaterThanTen</span></span></code></pre></div>
<h3 id="laws-1">Laws</h3>
<p>Just like <code>Functor</code> has laws, <code>Contravariant</code> also has laws. This is awesome - because laws make our lives easier.</p>
<h4 id="identity-1">Identity</h4>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>contramap <span class="fu">id</span> <span class="op">==</span> <span class="fu">id</span></span></code></pre></div>
<p>Essentially if you do not change the value of a <code>Contravariant</code> functor, you get the same <code>Contravariant</code> functor you started with.</p>
<h4 id="composition-1">Composition</h4>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>contramap f <span class="op">.</span> contramap g <span class="ot">=</span> contramap (g <span class="op">.</span> f)</span></code></pre></div>
<p>If you convert the input to some <code>Contravariant</code> functor by <code>contramap</code>ing with function <code>g</code> and then convert its input to some other type by <code>contramap</code>ing again with a function <code>f</code>, it’s the same as composing the functions <code>f</code> and <code>g</code> (<code>g . f</code>) and then <code>contramap</code>ing once. Notice the order of composition is switched as opposed to when we looked at the <code>Functor</code> laws.</p>
<figure>
<img src="../images/contravariant/contravariant-laws-ct.png" alt="Contravariant Laws" />
<figcaption aria-hidden="true">Contravariant Laws</figcaption>
</figure>
<p>Let’s take <code>Predicate</code> as an example and try out the identity law. The <code>Contravariant</code> instance for <code>Predicate</code> is defined as:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a> <span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Predicate</span> <span class="kw">where</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="ot">   contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>   contramap f (<span class="dt">Predicate</span> p) <span class="ot">=</span> <span class="dt">Predicate</span> (p <span class="op">.</span> f)</span></code></pre></div>
<p>Given that we have a <code>Predicate Int</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">numGreaterThanTen ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>numGreaterThanTen <span class="ot">=</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="op">&gt;</span> <span class="dv">10</span>)</span></code></pre></div>
<p>Using <code>contramap id</code> on the above:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- identity law</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>contramap <span class="fu">id</span> numGreaterThanTen <span class="op">==</span> numGreaterThanTen</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- lhs</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> (p <span class="op">.</span> f) <span class="co">-- applying contramap</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> (p <span class="op">.</span> <span class="fu">id</span>) <span class="co">-- expanding f</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> (p) <span class="co">-- applying f</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="op">&gt;</span> <span class="dv">10</span>) <span class="co">-- expanding p</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- rhs</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>numGreaterThanTen</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="op">&gt;</span> <span class="dv">10</span>) <span class="co">-- expanding numGreaterThanTen</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- equality</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>lhs                      <span class="op">==</span> rhs</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="op">&gt;</span> <span class="dv">10</span>) <span class="op">==</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="op">&gt;</span> <span class="dv">10</span>)</span></code></pre></div>
<p>Once again using <code>Predicate</code> as an example, let’s explore the compositional law of <code>Contravariant</code>.</p>
<p>Given that we have the following <code>Predicate</code>s:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">numGreaterThanTen ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>numGreaterThanTen <span class="ot">=</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="op">&gt;</span> <span class="dv">10</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="ot">personName ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<p>Using <code>numGreaterThanTen</code>, with <code>length</code> and <code>personName</code>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- composition law</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>contramap personName <span class="op">.</span> contramap <span class="fu">length</span> <span class="op">$</span> numGreaterThanTen <span class="ot">=</span> contramap (<span class="fu">length</span> <span class="op">.</span> personName) numGreaterThanTen</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- lhs</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>contramap personName <span class="op">.</span> contramap <span class="fu">length</span> <span class="op">$</span> numGreaterThanTen</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>contramap personName <span class="op">.</span> contramap <span class="fu">length</span> <span class="op">$</span> <span class="dt">Predicate</span> (\n <span class="ot">-&gt;</span> n <span class="op">&gt;</span> <span class="dv">10</span>) <span class="co">-- expanding numGreaterThanTen</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>contramap personName (<span class="dt">Predicate</span> <span class="op">$</span> \str <span class="ot">-&gt;</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> num  <span class="ot">=</span> <span class="fu">length</span> str</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>     bool  <span class="ot">=</span> num <span class="op">&gt;</span> <span class="dv">10</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> bool</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>) <span class="co">-- applying length</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> <span class="op">$</span> \person <span class="ot">-&gt;</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> str <span class="ot">=</span> personName person</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>      num <span class="ot">=</span> <span class="fu">length</span> str</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>     bool <span class="ot">=</span> num <span class="op">&gt;</span> <span class="dv">10</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> bool</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>) <span class="co">-- applying personName</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a><span class="ot">=&gt;</span> <span class="dt">Predicate</span> <span class="dt">Person</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- rhs</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>contramap (<span class="fu">length</span> <span class="op">.</span> personName) numGreaterThanTen</span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>contramap (\person <span class="ot">-&gt;</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> str <span class="ot">=</span> personName person</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>        num <span class="ot">=</span> <span class="fu">length</span> str</span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> num</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>) numGreaterThanTen <span class="co">-- expanding length . personName</span></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> (\person <span class="ot">-&gt;</span></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> str  <span class="ot">=</span> personName person</span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>       num  <span class="ot">=</span> <span class="fu">length</span> str</span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>       bool <span class="ot">=</span> num <span class="op">&gt;</span> <span class="dv">10</span> <span class="co">-- expanding numGreaterThanTen</span></span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> bool</span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a><span class="ot">=&gt;</span> <span class="dt">Predicate</span> <span class="dt">Person</span></span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a><span class="co">-- equality</span></span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a>lhs <span class="op">==</span> rhs</span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> (\person <span class="ot">-&gt;</span></span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> str  <span class="ot">=</span> personName person</span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a>      num  <span class="ot">=</span> <span class="fu">length</span> str</span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a>      bool <span class="ot">=</span> num <span class="op">&gt;</span> <span class="dv">10</span></span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> bool</span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-45"><a href="#cb33-45" aria-hidden="true" tabindex="-1"></a>) <span class="op">==</span></span>
<span id="cb33-46"><a href="#cb33-46" aria-hidden="true" tabindex="-1"></a><span class="dt">Predicate</span> (\person <span class="ot">-&gt;</span></span>
<span id="cb33-47"><a href="#cb33-47" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> str  <span class="ot">=</span> personName person</span>
<span id="cb33-48"><a href="#cb33-48" aria-hidden="true" tabindex="-1"></a>       num  <span class="ot">=</span> <span class="fu">length</span> str</span>
<span id="cb33-49"><a href="#cb33-49" aria-hidden="true" tabindex="-1"></a>       bool <span class="ot">=</span> num <span class="op">&gt;</span> <span class="dv">10</span></span>
<span id="cb33-50"><a href="#cb33-50" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> bool</span>
<span id="cb33-51"><a href="#cb33-51" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<h3 id="combinators">Combinators</h3>
<p>There are some built-in combinators that go with <code>Contravariant</code>.</p>
<h4 id="infix-contramap">Infix contramap</h4>
<p>Similar to the <code>contramap</code> function the following functions can be used infix:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- infixl 4</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;$&lt;)        ::</span> <span class="dt">Contravariant</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- contramap :: Contravariant f =&gt; (a -&gt; b) -&gt; f b -&gt; f a</span></span></code></pre></div>
<p>A simple example of it in use:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p5 ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>p5 <span class="ot">=</span> <span class="dt">Predicate</span> <span class="op">$</span> \n <span class="ot">-&gt;</span> n <span class="op">==</span> <span class="dv">5</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="ot">pLength5 ::</span> <span class="dt">Predicate</span> [a]</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>pLength5 <span class="ot">=</span> <span class="fu">length</span> <span class="op">&gt;$&lt;</span> p5</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>getPredicate pLength5 <span class="st">&quot;hello&quot;</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- True</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>getPredicate pLength5 <span class="st">&quot;hello world&quot;</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- False</span></span></code></pre></div>
<p>Same as <code>contramap</code> but with the parameters switched:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- infixl 4</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;$$&lt;)       ::</span> <span class="dt">Contravariant</span> f <span class="ot">=&gt;</span> f b      <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- contramap :: Contravariant f =&gt; (a -&gt; b) -&gt; f b      -&gt; f a</span></span></code></pre></div>
<h4 id="infix-const">Infix const</h4>
<p>These combinators take in a constant input and completely ignore the input supplied when running the <code>Contravariant</code> instance.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- infixl 4</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;$) ::</span> b <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span></code></pre></div>
<p>It has a default implementation of:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;$) ::</span> b <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;$</span>) <span class="ot">=</span> contramap <span class="op">.</span> <span class="fu">const</span></span></code></pre></div>
<p>Let’s see how that works:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- const when given two values returns the first value ignoring the second</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="fu">const</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="fu">const</span> x _ <span class="ot">=</span>  x</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="ot">contramap ::</span> <span class="dt">Contravariant</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;$) ::</span> b <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;$</span>)      <span class="ot">=</span> contramap <span class="op">.</span> <span class="fu">const</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;$</span>) b    <span class="ot">=</span> contramap (<span class="fu">const</span> b)   <span class="co">-- simplifying with b</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;$</span>) b    <span class="ot">=</span> contramap (a <span class="ot">-&gt;</span> b)    <span class="co">-- applying `const b`</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;$</span>) b fb <span class="ot">=</span> contramap (a <span class="ot">-&gt;</span> b) fb <span class="co">-- simplifying with fb</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;$</span>) b fb <span class="ot">=</span> fa                    <span class="co">-- simplifying `contramap (a -&gt; b) fb`</span></span></code></pre></div>
<p>A simple example of it in use:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p5 ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>p5 <span class="ot">=</span> <span class="dt">Predicate</span> <span class="op">$</span> \n <span class="ot">-&gt;</span> n <span class="op">==</span> <span class="dv">5</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="ot">pLength5 ::</span> <span class="dt">Predicate</span> [a]</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>pLength5 <span class="ot">=</span> contramap <span class="fu">length</span> p5</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>getPredicate pLength5 <span class="st">&quot;hello&quot;</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- True</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>getPredicate pLength5 <span class="st">&quot;hello world&quot;</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- False</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a><span class="ot">pAlwaysFalse ::</span> <span class="dt">Predicate</span> [a]</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>pAlwaysFalse <span class="ot">=</span> <span class="dv">10</span> <span class="op">&gt;$</span> p5</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>getPredicate pAlwaysFalse <span class="st">&quot;hello&quot;</span></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- False (because 10 /= 5)</span></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>getPredicate pAlwaysFalse <span class="st">&quot;hello world&quot;</span></span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- False</span></span></code></pre></div>
<p>Same as above but with the parameters switched:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- infixl 4</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="ot">($&lt;) ::</span> <span class="dt">Contravariant</span> f <span class="ot">=&gt;</span> f b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> f a</span></code></pre></div>
<h3 id="logaction">LogAction</h3>
<p>Let’s look at another example of <code>Contravariant</code>. Imagine you have the following data type that encapsulates performing some side effect on some polymorphic type <code>a</code>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">LogAction</span> a <span class="ot">=</span> <span class="dt">LogAction</span> {<span class="ot"> unlog ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> () }</span></code></pre></div>
<p>For our purposes we can assume that we are going to use this to log some value either to the console or to a file or some other medium. This example has been adapted from the <a href="https://github.com/kowainik/co-log/blob/master/co-log-core/src/Colog/Core/Action.hs#L105">LogAction</a> class of the <a href="https://kowainik.github.io/posts/2018-09-25-co-log">CO-LOG</a> logging library. Definitely check out the library for real-world uses of <code>Contravariant</code> and friends.</p>
<p>As we can see the type variable <code>a</code> occurs in input position so we should be able to define a <code>Contravariant</code> instance for it:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">LogAction</span> <span class="kw">where</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  contramap ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">LogAction</span> a <span class="ot">-&gt;</span> <span class="dt">LogAction</span> b</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  contramap bToA logActionA <span class="ot">=</span> <span class="dt">LogAction</span> <span class="op">$</span> \b <span class="ot">-&gt;</span> unlog logActionA (bToA b)</span></code></pre></div>
<p>There should be no surprises here; we run the supplied function <code>bToA</code> on the input <em>before</em> passing it to the log action.</p>
<p>Here’s a slightly simplified implementation of the above:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">LogAction</span> <span class="kw">where</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  contramap f logActionA <span class="ot">=</span> <span class="dt">LogAction</span> <span class="op">$</span> unlog logActionA <span class="op">.</span> f</span></code></pre></div>
<p>So how can we use <code>LogAction</code>? Let’s define a couple of implementations:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="ot">putStrLog ::</span> <span class="dt">LogAction</span> <span class="dt">String</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>putStrLog <span class="ot">=</span> <span class="dt">LogAction</span> <span class="fu">putStr</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="ot">putStrLnLog ::</span> <span class="dt">LogAction</span> <span class="dt">String</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>putStrLnLog <span class="ot">=</span> <span class="dt">LogAction</span> <span class="fu">putStrLn</span></span></code></pre></div>
<p><code>putStrLog</code> and <code>putStrLn</code> are just wrappers around <code>putStr</code> and <code>putStrLn</code> from <code>base</code>. Both log a String to the console, the difference being that <code>putStrLn</code> sends a newline character to the console after each call.</p>
<p>Here’s how we’d use <code>putStrLnLog</code>:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>unlog putStrLnLog <span class="st">&quot;Hello World&quot;</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Hello World</span></span></code></pre></div>
<p>Remember that <code>LogAction</code> <em>needs</em> an <code>a</code> which in this case is a <code>String</code>.</p>
<p>Now because we have the power of contravariance, we should be able to log out other types if we can convert them to a <code>String</code>.</p>
<p>Here are some examples:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- simple function around contramap for LogAction</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="ot">putStringlyLnLog ::</span> (a <span class="ot">-&gt;</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">LogAction</span> a</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>putStringlyLnLog f <span class="ot">=</span> contramap f putStrLnLog</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Now we can log Ints</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="ot">putStrLnInt ::</span> <span class="dt">LogAction</span> <span class="dt">Int</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>putStrLnInt <span class="ot">=</span> putStringlyLnLog <span class="fu">show</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span> {<span class="ot"> name ::</span> <span class="dt">String</span>,<span class="ot"> age ::</span> <span class="dt">Int</span> }</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- custom String representation of Person</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a><span class="ot">showPerson ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>showPerson (<span class="dt">Person</span> name age) <span class="ot">=</span> <span class="st">&quot;Person(name:&quot;</span> <span class="op">&lt;&gt;</span> name <span class="op">&lt;&gt;</span> <span class="st">&quot;, age: &quot;</span> <span class="op">&lt;&gt;</span> (<span class="fu">show</span> age) <span class="op">&lt;&gt;</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- Now we can log people</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a><span class="ot">putStrLnPerson ::</span> <span class="dt">LogAction</span> <span class="dt">Person</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>putStrLnPerson <span class="ot">=</span> putStringlyLnLog showPerson</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- custom String representation of Person that only displays age</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a><span class="ot">showPersonAge ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>showPersonAge person <span class="ot">=</span>  <span class="st">&quot;age: &quot;</span> <span class="op">&lt;&gt;</span> (<span class="fu">show</span> <span class="op">$</span> age person)</span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- Additional Person LogAction which outputs only age</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a><span class="ot">putStrLnPersonAge ::</span> <span class="dt">LogAction</span> <span class="dt">Person</span></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>putStrLnPersonAge <span class="ot">=</span> putStringlyLnLog showPersonAge</span></code></pre></div>
<p>Here’s how we can run the above:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>unlog putStrLnInt <span class="dv">42</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 42</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>unlog putStrLnPerson <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Neelix&quot;</span> <span class="dv">60</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Person(name:Neelix, age: 60)</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>unlog putStrLnPersonAge <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Tuvok&quot;</span> <span class="dv">240</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- age: 240</span></span></code></pre></div>
<p>We can see that <code>LogAction</code> for <code>Person</code>, <em>needs</em> a <code>Person</code> instance as input to perform the log action.</p>
<p>Something that might not be obvious is that we can also adapt an input type to itself. It’s not necessary to always convert from one type to another.</p>
<p>Here are some example functions which we can use with <code>contramap</code>:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">hello ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>hello <span class="ot">=</span> (<span class="st">&quot;Hello&quot;</span> <span class="op">&lt;&gt;</span>)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="ot">there ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>there <span class="ot">=</span> (<span class="st">&quot;there&quot;</span> <span class="op">&lt;&gt;</span>)</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a><span class="ot">doctor ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>doctor <span class="ot">=</span> (<span class="st">&quot;Doctor&quot;</span> <span class="op">&lt;&gt;</span>)</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a><span class="ot">space ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>space <span class="ot">=</span> (<span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span>)</span></code></pre></div>
<p>Here’s how we compose the above functions into a <code>LogAction</code>:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">putStrLnGreeting ::</span> <span class="dt">LogAction</span> <span class="dt">String</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>putStrLnGreeting <span class="ot">=</span> contramap space <span class="op">.</span> contramap doctor <span class="op">.</span> contramap space <span class="op">.</span> contramap there <span class="op">.</span> contramap space <span class="op">.</span> contramap hello <span class="op">$</span> putStrLnLog</span></code></pre></div>
<p>Whoa! That’s even hard to read. What does it do? Remember from the second law of <code>Contravariant</code> that:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>contramap f <span class="op">.</span> contramap g <span class="ot">=</span> contramap (g <span class="op">.</span> f)</span></code></pre></div>
<p>Given that, we can rewrite our highly compositional <code>LogAction</code> like so:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">putStrLnGreeting ::</span> <span class="dt">LogAction</span> <span class="dt">String</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>putStrLnGreeting <span class="ot">=</span> contramap  (hello <span class="op">.</span> space <span class="op">.</span> there <span class="op">.</span> space <span class="op">.</span> doctor <span class="op">.</span> space) <span class="op">$</span> putStrLnLog</span></code></pre></div>
<p>At least this is somewhat more readable - but the great thing is that knowing the laws helped us make our code more legible. But still - what does this do?</p>
<p>The trick is to remember that <code>Contravaraint</code> composition works in <strong>reverse</strong> to normal composition:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>contramap f <span class="op">.</span> contramap g <span class="ot">=</span> contramap (g <span class="op">.</span> f) <span class="co">-- notice the (g . f) instead of (f. g)</span></span></code></pre></div>
<p>This is how <code>putStrLnGreeting</code> is evaluated:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">putStrLnGreeting ::</span> <span class="dt">LogAction</span> <span class="dt">String</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>putStrLnGreeting <span class="ot">=</span> contramap  (hello <span class="op">.</span> space <span class="op">.</span> there <span class="op">.</span> space <span class="op">.</span> doctor <span class="op">.</span> space) <span class="op">$</span> putStrLnLog</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>unlog putStrLnGreeting <span class="st">&quot;Switzer&quot;</span> <span class="co">-- run the logger with &quot;Switzer&quot; as the input</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- the input is going to go through this sequence of functions:</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- (hello . space . there . space . doctor . space)</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- applying space</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="dt">Switzer</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- applying doctor</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Doctor&quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="dt">Switzer</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- applying space</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a><span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot;Doctor&quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="dt">Switzer</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- applying there</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;there&quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot;Doctor&quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="dt">Switzer</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- applying space</span></span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a><span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot;there&quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot;Doctor&quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="dt">Switzer</span></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- applying hello</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Hello&quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot;there&quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot;Doctor&quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> <span class="dt">Switzer</span></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- final output:</span></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- Hello there Doctor Switzer</span></span></code></pre></div>
<p>Let’s look at one more <code>LogAction</code> which might be interesting; One where we ignore the input and return some constant output:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">override ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>override value <span class="ot">=</span> <span class="fu">const</span> value</span></code></pre></div>
<p>A we mentioned previously, <code>const</code> is defined as <code>a -&gt; b -&gt; a</code>, where it accepts two inputs but returns the value of the first input (ignoring the second input).</p>
<p>Here’s how we use it with <code>LogAction</code>:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">qPutStrLn ::</span><span class="dt">LogAction</span> <span class="dt">String</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>qPutStrLn <span class="ot">=</span> contramap (override <span class="st">&quot;This is Q!!&quot;</span>) putStrLnLog</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- run it</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>unlog qPutStrLn <span class="st">&quot;Picard J L&quot;</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- This is Q!!</span></span></code></pre></div>
<p>Now if our memory serves, we should be able to do the same with <code>&gt;$</code>:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ot">qPutStrLnOp ::</span> <span class="dt">LogAction</span> <span class="dt">String</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>qPutStrLnOp <span class="ot">=</span> <span class="st">&quot;This is Q!!&quot;</span> <span class="op">&gt;$</span> putStrLnLog</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- run it</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>unlog qPutStrLnOp <span class="st">&quot;Sisko B L&quot;</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- This is Q!!</span></span></code></pre></div>
<h3 id="equality-and-ordering">Equality and Ordering</h3>
<p>Now let’s look at two somewhat related concepts: equality and ordering</p>
<h4 id="equivalence">Equivalence</h4>
<p>Let’s imagine that we have a datatype called <code>Equivalence</code> that wraps an equality expression:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Equivalence</span> a <span class="ot">=</span> <span class="dt">Equivalence</span> {<span class="ot"> getEquivalence ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> }</span></code></pre></div>
<p>Given two values of type <code>a</code> the <code>getEquivalence</code> function will return a <code>Bool</code> indicating if they are equal or not.</p>
<p>Now we can see that both <code>a</code> type variables are in input position. Let’s define a <code>Contravariant</code> instance for it:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Equivalence</span> <span class="kw">where</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Equivalence</span> b <span class="ot">-&gt;</span> <span class="dt">Equivalence</span> a</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  contramap aToB (<span class="dt">Equivalence</span> eqB1B2) <span class="ot">=</span> <span class="dt">Equivalence</span> <span class="op">$</span> \a1 a2 <span class="ot">-&gt;</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> b1 <span class="ot">=</span> aToB a1</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>        b2 <span class="ot">=</span> aToB a2</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> eqB1B2 b1 b2</span></code></pre></div>
<p>Something important to note is that the function we supply to <code>contramap</code> (<code>a -&gt; b</code>) is run on twice - once on each of the input parameters (<code>b</code>).</p>
<figure>
<img src="../images/contravariant/equivalence-polarity.png" alt="Polarity of Equivalence" />
<figcaption aria-hidden="true">Polarity of Equivalence</figcaption>
</figure>
<p>Given an <code>Equivalence</code> for <code>Int</code>:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="ot">intEq ::</span> <span class="dt">Equivalence</span> <span class="dt">Int</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>intEq <span class="ot">=</span> <span class="dt">Equivalence</span> (<span class="op">==</span>)</span></code></pre></div>
<p>We can run it as:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>getEquivalence intEq <span class="dv">1</span> <span class="dv">2</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- False</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>getEquivalence intEq <span class="dv">1</span> <span class="dv">1</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- True</span></span></code></pre></div>
<p>We can calculate the equivalence of other types using <code>contramap</code>:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="ot">strLengthEq ::</span> <span class="dt">Equivalence</span> <span class="dt">String</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>strLengthEq <span class="ot">=</span> contramap <span class="fu">length</span> intEq</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span> {<span class="ot"> name ::</span> <span class="dt">String</span>,<span class="ot"> age ::</span> <span class="dt">Int</span> }</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="ot">personAgeEq ::</span> <span class="dt">Equivalence</span> <span class="dt">Person</span> <span class="co">-- equality by age</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>personAgeEq <span class="ot">=</span> contramap age intEq</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a><span class="ot">personNameLengthEq ::</span> <span class="dt">Equivalence</span> <span class="dt">Person</span> <span class="co">-- equality by length of name</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>personNameLengthEq <span class="ot">=</span> contramap name strLengthEq</span></code></pre></div>
<p>Here’s how we can run the above:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- t1 = Person &quot;Tuvok1&quot; 240</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- t2 = Person &quot;Tuvok2&quot; 340</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- t3 = Person &quot;Neelix&quot; 60</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- t4 = Person &quot;Janeway&quot; 40</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>getEquivalence personAgeEq t1 t2</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- False</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>getEquivalence personAgeEq t1 t1</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- True</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>getEquivalence personAgeEq t2 t2</span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- True</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>getEquivalence personAgeEq t2 t3</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- False</span></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>getEquivalence personNameLengthEq t1 t2</span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- True</span></span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a>getEquivalence personNameLengthEq t3 t4</span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- False</span></span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a>getEquivalence personNameLengthEq t1 t4</span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- False</span></span></code></pre></div>
<h4 id="comparison">Comparison</h4>
<p>Let’s imagine that we have a datatype called <code>Comparison</code> that wraps a comparison expression:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Comparison</span> a <span class="ot">=</span> <span class="dt">Comparison</span> {<span class="ot"> getComparison ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span> }</span></code></pre></div>
<p>Given two values of type <code>a</code> the <code>getComparison</code> function will return an <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#t:Ordering">Ordering</a> (<code>LT</code>, <code>GT</code> or <code>EQ</code>) with respect to each other.</p>
<p>Now we can see that both <code>a</code> type variables are in input position as before. Let’s define a <code>Contravariant</code> instance for it:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Comparison</span> <span class="kw">where</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Comparison</span> b <span class="ot">-&gt;</span> <span class="dt">Comparison</span> a</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  contramap aToB (<span class="dt">Comparison</span> cmpB1B2) <span class="ot">=</span> <span class="dt">Comparison</span> <span class="op">$</span> \a1 a2 <span class="ot">-&gt;</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> b1 <span class="ot">=</span> aToB a1</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>        b2 <span class="ot">=</span> aToB a2</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> cmpB1B2 b1 b2</span></code></pre></div>
<figure>
<img src="../images/contravariant/comparison-polarity.png" alt="Polarity of Comparison" />
<figcaption aria-hidden="true">Polarity of Comparison</figcaption>
</figure>
<p>We can see that the wrappers for <code>Equivalence</code> and <code>Comparison</code> are almost the same, as are their <code>Contravariant</code> instances.</p>
<p>Given a <code>Comparison</code> for Int as:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="ot">intCmp ::</span> <span class="dt">Comparison</span> <span class="dt">Int</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>intCmp <span class="ot">=</span> <span class="dt">Comparison</span> <span class="fu">compare</span></span></code></pre></div>
<p>We can run it as:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>getComparison intCmp <span class="dv">1</span> <span class="dv">1</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- EQ</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>getComparison intCmp <span class="dv">1</span> <span class="dv">2</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- LT</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>getComparison intCmp <span class="dv">2</span> <span class="dv">1</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- GT</span></span></code></pre></div>
<p>We can now calculate the comparison of other types using <code>contramap</code>:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="ot">strCmp ::</span> <span class="dt">Comparison</span> <span class="dt">String</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>strCmp <span class="ot">=</span> contramap <span class="fu">length</span> intCmp</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="ot">personAgeCmp ::</span> <span class="dt">Comparison</span> <span class="dt">Person</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>personAgeCmp <span class="ot">=</span> contramap age intCmp</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a><span class="ot">fstCmp ::</span> <span class="dt">Comparison</span> a <span class="ot">-&gt;</span> <span class="dt">Comparison</span> (a, b)</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>fstCmp compA <span class="ot">=</span> contramap <span class="fu">fst</span> compA</span></code></pre></div>
<p>Nothing new here. Let’s have a look at how to sort numbers. We use the <code>sortBy</code> function defined in <code>Data.List</code> from the <code>base</code> package:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sortBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>We can see from the <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:sortBy">sortBy</a> function definition that it can accept the data wrapped in the <code>Comparison</code> data type:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sortBy        ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getComparison ::</span>  a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span></span></code></pre></div>
<p>Sorting numbers with the above function:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- unsortedNumbers = [3, 5, 1, 4, 2]</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- ascending sort</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>sortBy (getComparison intCmp) unsortedNumbers</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- [1,2,3,4,5]</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- descending sort</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>sortBy (<span class="fu">flip</span> <span class="op">$</span> getComparison intCmp) unsortedNumbers</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- [5,4,3,2,1]</span></span></code></pre></div>
<p>Notice how we just use the <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:flip">flip</a> function to change between ascending and descending sort:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span></code></pre></div>
<p><code>flip</code> just changes the order of input parameters. <code>flip</code> is awesome :) I saw this technique first used at <a href="https://ro-che.info/articles/2016-04-02-descending-sort-haskell">Roman Cheplyaka</a>’s blog.</p>
<p>But here’s something interesting: since we know how to sort <code>Int</code>s we also know how to sort people by age via <code>personAgeCmp</code>! Let’s see that in action:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- unsortedPeople = [Person &quot;Tuvok1&quot; 240, Person &quot;Janeway&quot; 40, Person &quot;Neelix&quot; 60]</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- ascending sort</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>sortBy (getComparison personAgeCmp) unsortedPeople</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- [Person {name = &quot;Janeway&quot;, age = 40},Person {name = &quot;Neelix&quot;, age = 60},Person {name = &quot;Tuvok1&quot;, age = 240}]</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- descending sort</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>sortBy (<span class="fu">flip</span> <span class="op">$</span> getComparison personAgeCmp)</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- [Person {name = &quot;Tuvok1&quot;, age = 240},Person {name = &quot;Neelix&quot;, age = 60},Person {name = &quot;Janeway&quot;, age = 40}]</span></span></code></pre></div>
<h3 id="function-types">Function Types</h3>
<p>A regular function can be though of being defined as:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">RegularFunc</span> a b <span class="ot">=</span> <span class="dt">RegularFunc</span> {<span class="ot"> getRegular ::</span> a <span class="ot">-&gt;</span> b }</span></code></pre></div>
<p>We can define a <code>Functor</code> instance for <code>RegularFunc</code> because <code>b</code> is in output position. But what about <code>a</code>, which is in input position? More on that below.</p>
<p>Let’s recall what the definition of the <code>Functor</code> type class looks like:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>In the above declaration, <code>f</code> is a type constructor with one type hole. Given <code>RegularFunc</code> which has two type holes (<code>a</code> and <code>b</code>), we need to fill one in, in order to use it with the <code>Functor</code> instance implementation. To do this we fix <code>a</code> and get the type constructor <code>RegularFunc a</code>. We can’t fix <code>b</code> as partial application of types is done from left to right (holes can only be on the right).</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">RegularFunc</span> a) <span class="kw">where</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmap ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> <span class="ot">=</span> (<span class="op">.</span>)</span></code></pre></div>
<p>We can’t define a <code>Contravariant</code> instance for <code>a</code> because we have to fix <code>a</code> (we can’t define behaviour over it). All we have to play with is <code>b</code> which is in output position (and hence covariant)</p>
<p>Oh! Come on! If only we didn’t have to fix <code>a</code>. What if we could fix <code>b</code> instead? We don’t care about <code>b</code>. <code>b</code> is dead to us.</p>
<p>Let’s dream up such a type and call it <code>Op</code> - for <strong>op</strong>posite of regular:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Op</span> a b <span class="ot">=</span> <span class="dt">Op</span> {<span class="ot"> getOp ::</span> b <span class="ot">-&gt;</span> a }</span></code></pre></div>
<p>Now we can see that the type <code>b</code> is in input position within the data type. It’s also on the right of <code>Op a b</code> which means we don’t have to fix it.</p>
<p><code>Op a b</code> can be a little confusing because we have switched the position of type parameters <code>a</code> and <code>b</code> as they were in <code>RegularFunc</code>; <code>a</code> is the output and <code>b</code> is the input.</p>
<table>
<thead>
<tr class="header">
<th>Data type</th>
<th>Polarity of a</th>
<th>Polarity of b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RegularFunc a b</td>
<td>Input</td>
<td>Output</td>
</tr>
<tr class="even">
<td>Op a b</td>
<td>Output</td>
<td>Input</td>
</tr>
</tbody>
</table>
<p>And guess what? We can now fix <code>a</code> (which is now our output) and can define a <code>Contravariant</code> instance for <code>Op</code>:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> (<span class="dt">Op</span> a) <span class="kw">where</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  contramap ::</span> (c <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Op</span> a b <span class="ot">-&gt;</span> <span class="dt">Op</span> a c</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>  contramap cToB (<span class="dt">Op</span> bToA) <span class="ot">=</span> <span class="dt">Op</span> <span class="op">$</span> \c <span class="ot">-&gt;</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> b <span class="ot">=</span> cToB c</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> bToA b</span></code></pre></div>
<p>Here’s a simple example of how to use it:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stringsLength ::</span> <span class="dt">Op</span> <span class="dt">Int</span> [<span class="dt">String</span>]</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>stringsLength <span class="ot">=</span> <span class="dt">Op</span> <span class="op">$</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="fu">length</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="ot">unqiueStringsLength ::</span> <span class="dt">Op</span> <span class="dt">Int</span> (<span class="dt">S.Set</span> <span class="dt">String</span>)</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>unqiueStringsLength <span class="ot">=</span> contramap S.toList stringsLength</span></code></pre></div>
<p>If we know how to sum all the lengths of a <code>[String]</code> we can adapt that function to sum the lengths of a <code>Set</code> of <code>String</code>:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Set</span> (fromList)</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>namesList <span class="ot">=</span> [<span class="st">&quot;Paris&quot;</span>, <span class="st">&quot;Kim&quot;</span>, <span class="st">&quot;B'Elanna&quot;</span>, <span class="st">&quot;Seven&quot;</span>]</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>namesSet  <span class="ot">=</span> fromList namesList</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>getOp stringsLength <span class="op">$</span> namesList</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- 21</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>getOp unqiueStringsLength <span class="op">$</span> namesSet</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- 21</span></span></code></pre></div>
<p>Now <code>Predicate</code>, <code>Comparison</code>, <code>Equivalence</code> and <code>Op</code> seem like useful data structures. The good news is that they already exist in the <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Functor-Contravariant.html">Data.Functor.Contravariant</a> package from <code>base</code> so you don’t have to write them yourself.</p>
<p>One interesting implementation detail of the <code>Comparison</code> and <code>Equivalence</code> <code>Contravariant</code> instances is that they are implemented using the <code>on</code> function:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Equivalence</span> a <span class="ot">=</span> <span class="dt">Equivalence</span> {<span class="ot"> getEquivalence ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> }</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">Equivalence</span> <span class="kw">where</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>  contramap f g <span class="ot">=</span> <span class="dt">Equivalence</span> <span class="op">$</span> on (getEquivalence g) f</span></code></pre></div>
<p>The <code>on</code> function is <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/src/Data.Function.html#on">defined</a> as:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="ot">on ::</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">.*.</span>) <span class="ot">`on`</span> f <span class="ot">=</span> \x y <span class="ot">-&gt;</span> f x <span class="op">.*.</span> f y</span></code></pre></div>
<p>Essentially given a function <code>b -&gt; b -&gt; c</code> and a function <code>a -&gt; b</code>, the second function will be applied to each input of type <code>a</code> converting it to a <code>b</code> and then the first function is applied on the transformed inputs. Such reuse. :)</p>
<h2 id="more-polarity">More Polarity</h2>
<p>Let’s take a look at the <code>CallbackRunner</code> example from <a href="https://tech.fpcomplete.com/blog/2016/11/covariance-contravariance/">FP Complete</a>:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">CallbackRunner</span> a <span class="ot">=</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">CallbackRunner</span> {</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    runCallback ::</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Type variable <code>a</code> is in input position so we should be able to write a <code>Contravariant</code> instance for it:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">CallbackRunner</span> <span class="kw">where</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">CallbackRunner</span> b <span class="ot">-&gt;</span> <span class="dt">CallbackRunner</span> a</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>  contramap aToB (<span class="dt">CallbackRunner</span> runCallbackB) <span class="ot">=</span> <span class="dt">CallbackRunner</span> <span class="op">$</span> \aToIO <span class="ot">-&gt;</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    runCallbackB <span class="op">$</span> \b <span class="ot">-&gt;</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> a <span class="ot">=</span> <span class="fu">undefined</span> <span class="co">-- where do we get an `a` from?</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> aToIO a</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- if we had a (b -&gt; a) we could convert the `b` to an `a`</span></span></code></pre></div>
<p>Hmm. Now it looks like we have a problem. There doesn’t seem to anyway for us to get an <code>a</code> to pass to <code>aToIO</code> to complete the implementation. We have a <code>b</code> and if there was a function <code>b -&gt; a</code> instead of our <code>a -&gt; b</code>, we could convert that <code>b</code> to an <code>a</code> and it would all work.</p>
<p>This is because there’s more to the polarity story than I’ve shared up until now. While <code>a</code> is in input position in <code>a -&gt; IO()</code>, it’s polarity changes when it’s also used as an input to the function <code>(a -&gt; IO ()) -&gt; IO ()</code>. I <a href="#Polarity">previously mentioned</a> that an input position is a <code>negative</code> polarity and an output position is a <code>positive</code> polarity.</p>
<p>To figure out the final polarity of something we need to multiply its polarities at every context it is used within in the function definition. More on this below.</p>
<p>Polarity multiplication is similar to the multiplication of positive and negative numbers:</p>
<h3 id="polarity-multiplication-table">Polarity Multiplication Table</h3>
<table>
<thead>
<tr class="header">
<th>Polarity1</th>
<th>x</th>
<th>Polarity2</th>
<th>Polarity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Positive</td>
<td>x</td>
<td>Positive</td>
<td>Positive</td>
</tr>
<tr class="even">
<td>Positive</td>
<td>x</td>
<td>Negative</td>
<td>Negative</td>
</tr>
<tr class="odd">
<td>Negative</td>
<td>x</td>
<td>Positive</td>
<td>Negative</td>
</tr>
<tr class="even">
<td>Negative</td>
<td>x</td>
<td>Negative</td>
<td>Positive</td>
</tr>
</tbody>
</table>
<p>Let’s try and figure out the polarity of <code>a</code> given our new found multiplication skills. Given <code>runCallback</code>:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runCallback ::</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p><code>a</code> is in input or negative position in:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>but within whole function it’s a slightly different story:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>(a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> () <span class="co">-- func</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> ())      <span class="co">-- assigning (a -&gt; IO ()) to x in func</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>x <span class="ot">-&gt;</span> <span class="dt">IO</span> ()            <span class="co">-- substituting x in func</span></span></code></pre></div>
<p>We can see that <code>x</code> in the above example is in input or negative position as well. Given that <code>x</code> is <code>a -&gt; IO ()</code>:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>(a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- a -&gt; IO (a is negative)</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- (a -&gt; IO ()) -&gt; IO () (the whole parenthesis are in negative position)</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- polarity of a: negative * negative = positive</span></span></code></pre></div>
<figure>
<img src="../images/contravariant/callbackRunner-polarity.png" alt="Polarity Multiplication" />
<figcaption aria-hidden="true">Polarity Multiplication</figcaption>
</figure>
<p>Given that <code>a</code> is now in output or positive position, we should be able to write a <code>Functor</code> instance for it:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">CallbackRunner</span> <span class="kw">where</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">CallbackRunner</span> a <span class="ot">-&gt;</span> <span class="dt">CallbackRunner</span> b</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> aToB (<span class="dt">CallbackRunner</span> runCallbackA) <span class="ot">=</span> <span class="dt">CallbackRunner</span> <span class="op">$</span> \bToIO <span class="ot">-&gt;</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>    runCallbackA <span class="op">$</span> \a <span class="ot">-&gt;</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> b      <span class="ot">=</span> aToB a</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>          result <span class="ot">=</span> bToIO b</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> result</span></code></pre></div>
<p>And we can!! If you want to dig more into polarities there are some good exercises at the <a href="https://tech.fpcomplete.com/blog/2016/11/covariance-contravariance/">FP Complete article</a>.</p>
<h2 id="invariant-functors">Invariant Functors</h2>
<p>We briefly mentioned invariant functors when talking about <a href="#Polarity">Polarity</a> but never mentioned them again until now. The <code>Invariant</code> typeclass is the parent typeclass of both <code>Functor</code> and <code>Contravariant</code>)</p>
<figure>
<img src="../images/contravariant/functor-hierarchy-aligned.png" alt="Simplified Functor Hierarchy" />
<figcaption aria-hidden="true">Simplified Functor Hierarchy</figcaption>
</figure>
<p>Given that this post is quite long, I’m only going to mention that <code>Invariant</code> has both covariant and contravariant functions in its definition:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Invariant</span> f <span class="kw">where</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  invmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>where <code>a -&gt; b</code> is the function to use if <code>f a</code> is a <code>Functor</code> and <code>b -&gt; a</code> is the function to use if <code>f a</code> is <code>Contravariant</code>.</p>
<p>I may write another article about invariant functors if I feel the need for it, but in the meantime <a href="http://oleg.fi/gists/posts/2017-12-23-functor-optics.html#t:Invariant">checkout</a> <a href="https://stackoverflow.com/questions/22103445/example-of-invariant-functor">these</a> <a href="https://cvlad.info/functor-of/">articles</a> to get you <a href="https://www.lesswrong.com/posts/KRb2x2RJjGbBMbE4M/my-functor-is-rich">started</a>.</p>
<h2 id="summary">Summary</h2>
<p>Hopefully this has shed some light onto contravariant functors and how they are used and how they can be implemented. In a future article I hope to cover <code>Divisible</code> and <code>Decidable</code> typeclasses that build up from <code>Contravariant</code>.</p>
<p>The <a href="https://github.com/ssanj/contravariant-functors">source</a> for this article can be found on Github.</p>
<p>A big “Thank You” to <a href="https://twitter.com/georgetalkscode">George Wilson</a> for inspiring me to dig deeper into this topic with his excellent <a href="#video">presentations</a> on Functors.</p>
<p>A big thanks also to <a href="https://twitter.com/andrewfnewman">Andrew Newman</a> who reviewed this article.</p>
<h2 id="epilogue">Epilogue</h2>
<p>Just when you thought you’d learned all there is to learn about variance, there appears to be a variance of the <a href="https://en.wikipedia.org/wiki/Close_Encounters_of_the_Third_Kind">fourth kind</a>. It’s known as <a href="https://www.benjamin.pizza/posts/2019-01-11-the-fourth-type-of-variance.html">phantom variance</a> or <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">bivariance</a> as pointed by <a href="https://www.reddit.com/user/emilypii/">emilypii</a> and <a href="https://www.reddit.com/user/dbramucci/">dbramucci</a> on <a href="https://www.reddit.com/r/haskell/comments/iqpbnz/blog_post_learning_about_contravariant_functors/">reddit</a>. dbramucci also linked to a nice Scala <a href="https://speakerdeck.com/mpilquist/explorations-in-variance?slide=17">slidedeck</a> from <a href="https://twitter.com/mpilquist">Michael Pilquist</a></p>
<h2 id="links">Links</h2>
<h3 id="articles">Articles</h3>
<ul>
<li><a href="http://oleg.fi/gists/posts/2017-12-23-functor-optics.html#t:Contravariant">Functor Optics - Oleg’s Gists</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html">24 days of Hackage - Contravariant - Ocharles</a></li>
<li><a href="https://tech.fpcomplete.com/blog/2016/11/covariance-contravariance/">Covariance and Contravariance - FP Complete</a></li>
<li><a href="https://typeclasses.com/contravariance">Understanding Contravariance - Type classes</a></li>
<li><a href="https://kowainik.github.io/posts/2018-09-25-co-log">CO-LOG - Kowainik</a></li>
</ul>
<h3 id="video">Video</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=JZPXzJ5tp9w">The Extended Functor Family - George Wilson</a></li>
<li><a href="https://www.youtube.com/watch?v=IJ_bVVsQhvc&amp;t">Contravariant Functors - The Other Side of the Coin - George Wilson</a></li>
<li><a href="https://www.youtube.com/watch?v=OJtGECfksds">Fun with Profunctors - Phil Freeman</a></li>
<li><a href="https://www.youtube.com/watch?v=SxfZ_6ynhi0">A Fistful of Functors - Itamar Ravid</a></li>
</ul>
<h3 id="books">Books</h3>
<ul>
<li><a href="https://github.com/hmemcpy/milewski-ctfp-pdf">Category Theory for Programmers - Bartosz Milewski</a></li>
<li><a href="https://leanpub.com/thinking-with-types">Thinking in Types - Sandy Maguire</a></li>
</ul>
<h3 id="questions-and-answers">Questions and Answers</h3>
<ul>
<li><a href="https://www.reddit.com/r/haskell/comments/2p7toa/looking_for_an_abstraction_to_compose/">Looking for an abstraction to compose - Reddit</a></li>
<li><a href="https://www.reddit.com/r/haskelltil/comments/bqiyr9/datafunctorcontravariant_some_simple_applications/">datafunctorcontravariant some simple applications - Reddit</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/4rvtzy/what_is_the_motivation_behind_contravariant/">The motivation behind Contravariant - Reddit</a></li>
</ul>
<h3 id="packages">Packages</h3>
<ul>
<li><a href="http://hackage.haskell.org/package/contravariant-1.5.2">Contravariant Package</a></li>
</ul>
<h2 id="definitions">Definitions</h2>
<h4 id="type-constructor-1">Type constructor (1)</h4>
<p>A data type that needs one or more type variables to be fully defined.</p>
<p>For example, <code>Maybe</code> is a type constructor and <code>Maybe Int</code> is a type.</p>
          </article>
        </div>
        
          <div id="disqus_thread"></div>
          <script>
              /**
              *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
              *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */

              var disqus_config = function () {
              this.page.url = 'https://ssanj.github.io' + '/posts/2020-06-13-contravariant-functors-are-weird.html';
              this.page.identifier = '/posts/2020-06-13-contravariant-functors-are-weird.html';
              };

              (function() { // DON'T EDIT BELOW THIS LINE
              var d = document, s = d.createElement('script');
              s.src = 'https://babyloncandle.disqus.com/embed.js';
              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        
    </div>


      
    </body>
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/typeahead.bundle.min.js"></script>
    <script src="../js/handlebars-v1.3.0.js"></script>
    <script src="../js/babyloncandle.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55156872-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-55156872-1');
    </script>
</html>
