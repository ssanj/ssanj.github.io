<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Using Validated for Error Accumulation in Scala with Cats</title>
    <meta name="viewport" content="width=device-width">
    
    <meta name="description" content="How to accumulate errors in Validated">
    
    <link rel="canonical" href="https://blog.ssanj.net/posts/2019-08-18-using-validated-for-error-accumulation-in-scala-with-cats.html">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../css/main-2024-05-05.css">
    <link rel="stylesheet" type="text/css" href="../css/example-2024-05-05.css">
    <link rel="stylesheet" href="../css/syntax-2024-05-05.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    
  </head>

    <body>
      
          <div class="page-content">
      <div class="wrap">
        <div class="post">
          <header class="post-header">
            <h1><a href="../">Using Validated for Error Accumulation in Scala with Cats</a></h1>
            <p class="meta">August 18, 2019&nbsp;<span class="post-tag"><a title="All pages tagged 'scala'." href="../tags/scala.html">scala</a></span></p>
          </header>
          <article class="post-content">
            <p>The <code>Either</code> data type allows us to represent a computation that may fail. A simplified definition of an <code>Either</code> is given below:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Either<span class="op">[+</span>A<span class="op">,</span> <span class="op">+</span>B<span class="op">]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">final</span> <span class="cf">case</span> <span class="kw">class</span> Left<span class="op">[+</span>A<span class="op">,</span> <span class="op">+</span>B<span class="op">](</span>value<span class="op">:</span> A<span class="op">)</span> <span class="kw">extends</span> Either<span class="op">[</span>A<span class="op">,</span> B<span class="op">]</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">final</span> <span class="cf">case</span> <span class="kw">class</span> Right<span class="op">[+</span>A<span class="op">,</span> <span class="op">+</span>B<span class="op">](</span>value<span class="op">:</span> B<span class="op">)</span> <span class="kw">extends</span> Either<span class="op">[</span>A<span class="op">,</span> B<span class="op">]</span></span></code></pre></div>
<p>We use the two data constructors of Either to represent an error or a success. We wrap an error in the <code>Left</code> constructor or a successful value in the <code>Right</code> constructor. Let’s look at a simple example to make that clearer.</p>
<p>Say we want to validate a person’s name, age and email address. We could use the following ADT (algebraic data type) to do that:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">sealed</span> <span class="kw">trait</span> PersonErrorType</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">object</span> NameInvalid <span class="kw">extends</span> PersonErrorType</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">object</span> AgeInvalid <span class="kw">extends</span> PersonErrorType</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">object</span> EmailInvalid <span class="kw">extends</span> PersonErrorType</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">final</span> <span class="cf">case</span> <span class="kw">class</span> <span class="fu">PersonError</span><span class="op">(</span>value<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> errorType<span class="op">:</span> PersonErrorType<span class="op">)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">final</span> <span class="cf">case</span> <span class="kw">class</span> <span class="ex">Name</span><span class="op">(</span>value<span class="op">:</span> <span class="ex">String</span><span class="op">)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">final</span> <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Age</span><span class="op">(</span>value<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">final</span> <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Email</span><span class="op">(</span>value<span class="op">:</span> <span class="ex">String</span><span class="op">)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">final</span> <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Person</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">Name</span><span class="op">,</span> age<span class="op">:</span> Age<span class="op">,</span> email<span class="op">:</span> Email<span class="op">)</span></span></code></pre></div>
<p>The <code>PersonErrorType</code> models the various errors we may encounter during the creation of a <code>Person</code>and <code>PersonError</code> captures that error with some extra information as to why it failed. We also have wrapper classes around name, age and email to differentiate them from regular <code>String</code>s.</p>
<p>Now we could use an <code>Either</code> type, which has a <code>PersonError</code> on the <code>Left</code> and some valid type <code>A</code> on the <code>Right</code> to represent our validations. We define the type alias <code>ErrorOr</code> to represent this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ErrorOr<span class="op">[</span>A<span class="op">]</span> <span class="op">=</span> Either<span class="op">[</span>PersonError<span class="op">,</span> A<span class="op">]</span></span></code></pre></div>
<p>Notice that in <code>ErrorOr</code>, the error type or the left-side of the <code>Either</code> is fixed to <code>PersonError</code> and we can only vary the success type or the right-side of the Either. This is represented by the type variable <code>A</code>. <code>A</code> could be any type.</p>
<p>We can imagine having three functions that represent validating our name, age and email address:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateName</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> ErrorOr<span class="op">[</span><span class="ex">Name</span><span class="op">]</span> <span class="op">=</span> <span class="op">???</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> ErrorOr<span class="op">[</span>Age<span class="op">]</span> <span class="op">=</span> <span class="op">???</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateEmail</span><span class="op">(</span>email<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> ErrorOr<span class="op">[</span>Email<span class="op">]</span> <span class="op">=</span> <span class="op">???</span></span></code></pre></div>
<p>We will leave their definitions for a little later.</p>
<p>Notice that all the functions above return an <code>ErrorOr</code> with different types for the success value.</p>
<p>In addition we would need some kind of validation function that combines the above functions together to return a valid <code>Person</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validatePerson</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> age<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> email<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> ErrorOr<span class="op">[</span>Person<span class="op">]</span> <span class="op">=</span> <span class="op">???</span></span></code></pre></div>
<p>Now let’s go ahead and implement the validation functions according to the following rules:</p>
<ol type="1">
<li>The supplied name must not be empty and has to start with an uppercase character.</li>
<li>The supplied age must be a number and must be between one and a hundred and twenty.</li>
<li>The supplied email address must not be empty and must have at least a single <code>@</code> character.</li>
</ol>
<p>Following is a sample implementation of the above rules:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateName</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> ErrorOr<span class="op">[</span><span class="ex">Name</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>name<span class="op">.</span>headOption<span class="op">.</span><span class="fu">exists</span><span class="op">(</span>_<span class="op">.</span>isUpper<span class="op">))</span> <span class="fu">Right</span><span class="op">(</span><span class="ex">Name</span><span class="op">(</span>name<span class="op">))</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="fu">Left</span><span class="op">(</span><span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Name is empty or does not start with an uppercase character: </span><span class="ss">$name&quot;</span><span class="op">,</span> NameInvalid<span class="op">))</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> ErrorOr<span class="op">[</span>Age<span class="op">]</span> <span class="op">=</span> <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    numericAge <span class="op">&lt;-</span> <span class="fu">Try</span><span class="op">(</span>age<span class="op">.</span>toInt<span class="op">).</span>toEither<span class="op">.</span>left<span class="op">.</span><span class="fu">map</span><span class="op">(</span>ex <span class="op">=&gt;</span> <span class="fu">PersonError</span><span class="op">(</span>ex<span class="op">.</span>getMessage<span class="op">,</span> AgeInvalid<span class="op">))</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    validAge <span class="op">&lt;-</span> <span class="op">{</span> </span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>numericAge <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> numericAge <span class="op">&gt;</span> <span class="dv">120</span><span class="op">)</span> <span class="fu">Left</span><span class="op">(</span><span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Age must be a number between 1-120: </span><span class="ss">${</span>numericAge<span class="ss">}&quot;</span><span class="op">,</span> AgeInvalid<span class="op">))</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span> <span class="fu">Right</span><span class="op">(</span>numericAge<span class="op">)</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">yield</span> <span class="fu">Age</span><span class="op">(</span>validAge<span class="op">)</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateEmail</span><span class="op">(</span>email<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> ErrorOr<span class="op">[</span>Email<span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>email<span class="op">.</span>isEmpty <span class="op">||</span> <span class="op">!</span>email<span class="op">.</span><span class="fu">contains</span><span class="op">(</span><span class="st">&quot;@&quot;</span><span class="op">))</span> <span class="fu">Left</span><span class="op">(</span><span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Email address is empty or does not contain an `@` symbol: </span><span class="ss">$email&quot;</span><span class="op">,</span> EmailInvalid<span class="op">))</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="fu">Right</span><span class="op">(</span><span class="fu">Email</span><span class="op">(</span>email<span class="op">))</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>Don’t worry too much about the implementation.</p>
<p>Notice that we wrap the errors in a <code>PersonError</code> and put it in the <code>Left</code> constructor. Similarly we put the success values in the <code>Right</code> constructor. We also lift all success values into their wrapper types: <code>Name</code>, <code>Age</code> and <code>Email</code>.</p>
<p>Given the above validation implementations, how do we go about combining them to give us either a valid <code>Person</code> instance or an error of type <code>PersonError</code>?</p>
<p>Fortunately for us, the <code>Either</code> datatype implements both the <code>flatMap</code> and <code>map</code> methods which allows us to use a for-comprehension to sequence the validations we have:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validatePerson</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> age<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> email<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> ErrorOr<span class="op">[</span>Person<span class="op">]</span> <span class="op">=</span> <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    validName   <span class="op">&lt;-</span> <span class="fu">validateName</span><span class="op">(</span>name<span class="op">)</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    validAge    <span class="op">&lt;-</span> <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    validEmail  <span class="op">&lt;-</span> <span class="fu">validateEmail</span><span class="op">(</span>email<span class="op">)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">yield</span> <span class="fu">Person</span><span class="op">(</span>validName<span class="op">,</span> validAge<span class="op">,</span> validEmail<span class="op">)</span></span></code></pre></div>
<p>Now given a valid name, age and email, the <code>validatePerson</code> function returns a <code>Right</code> with a <code>Person</code> instance:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">validatePerson</span><span class="op">(</span><span class="st">&quot;Benjamin Sisko&quot;</span><span class="op">,</span> <span class="st">&quot;50&quot;</span><span class="op">,</span> <span class="st">&quot;b.sisko@dsn.st&quot;</span><span class="op">)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Right(Person(Name(Benjamin Sisko),Age(50),Email(b.sisko@dsn.st)))</span></span></code></pre></div>
<p>And it returns a <code>Left</code> with the first error of type <code>PersonError</code> for an invalid person:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">validatePerson</span><span class="op">(</span><span class="st">&quot;odo&quot;</span><span class="op">,</span> <span class="st">&quot;200&quot;</span><span class="op">,</span> <span class="st">&quot;odo.founder.net&quot;</span><span class="op">)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Left(PersonError(Name is empty or does not start with an uppercase character: odo,NameInvalid))</span></span></code></pre></div>
<p>Now in the above invalid example, we can see that Odo’s age is not between one and a hundred and twenty and his email address does not have a single <code>@</code> character in it and would be invalid. Unfortunately <code>Either</code> bails on the first error and we don’t get to see what any of the other errors are. This could get annoying if we keep getting new errors each time we run this code.</p>
<p>What we want is to get all the errors returned to us at once. How do we do that?</p>
<h3 id="validated">Validated</h3>
<p>This is where we need to lean on the <a href="https://typelevel.org/cats/datatypes/validated.html">Validated</a> datatype. The <code>Validated</code> datatype also lets us represent a computation that may fail - but with one crucial difference. It accumulates any errors that may occur.</p>
<p>The <code>Validated</code> datatype is not defined in the Scala standard library and has to be sourced from the <a href="https://typelevel.org/cats/">Cats</a> functional programming library.</p>
<p>A simplified definition of the <code>Validated</code> type is given below:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Validated<span class="op">[+</span>E<span class="op">,</span> <span class="op">+</span>A<span class="op">]</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">final</span> <span class="cf">case</span> <span class="kw">class</span> <span class="ex">Invalid</span><span class="op">[+</span>E<span class="op">](</span>e<span class="op">:</span> E<span class="op">)</span> <span class="kw">extends</span> Validated<span class="op">[</span>E<span class="op">,</span> Nothing<span class="op">]</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">final</span> <span class="cf">case</span> <span class="kw">class</span> Valid<span class="op">[+</span>A<span class="op">](</span>a<span class="op">:</span> A<span class="op">)</span> <span class="kw">extends</span> Validated<span class="op">[</span>Nothing<span class="op">,</span> A<span class="op">]</span></span></code></pre></div>
<p>We can see that the similarity to <code>Either</code> is uncanny. The <code>Invalid</code> data constructor is used to wrap some type of error while the <code>Valid</code> data constructor wraps success types. So what is it about this datatype that makes it accumulate errors in the <code>Invalid</code> case?</p>
<p>Before we answer that question, let’s look at transforming our previous validation example to use <code>Validated</code> instead of <code>Either</code>.</p>
<p>Let’s start off by creating a type alias called <code>AllErrorsOr</code> to accumulate our errors or return our success value:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> AllErrorsOr<span class="op">[</span>A<span class="op">]</span> <span class="op">=</span> Validated<span class="op">[</span>PersonError<span class="op">,</span> A<span class="op">]</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ErrorOr<span class="op">[</span>A<span class="op">]</span>     <span class="op">=</span>    Either<span class="op">[</span>PersonError<span class="op">,</span> A<span class="op">]</span></span></code></pre></div>
<p>The code is almost identical to <code>ErrorOr</code>; we just swapped out <code>Either</code> for <code>Validated</code>. Let’s change the return type of all our validation function to use <code>AllErrorsOr</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateName</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span><span class="ex">Name</span><span class="op">]</span> <span class="op">=</span> <span class="op">???</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span>Age<span class="op">]</span> <span class="op">=</span> <span class="op">???</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateEmail</span><span class="op">(</span>email<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span>Email<span class="op">]</span> <span class="op">=</span> <span class="op">???</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validatePerson</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> age<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> email<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span>Person<span class="op">]</span> <span class="op">=</span> <span class="op">???</span></span></code></pre></div>
<p>All we did is swap the <code>ErrorOr</code> type alias for <code>AllErrorsOr</code> and we have the definitions we need.</p>
<h4 id="construction">Construction</h4>
<p>Let’s go ahead and implement our validators. We can change our <code>validateName</code> function quite easily:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateName</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span><span class="ex">Name</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>name<span class="op">.</span>headOption<span class="op">.</span><span class="fu">exists</span><span class="op">(</span>_<span class="op">.</span>isUpper<span class="op">))</span> <span class="fu">Valid</span><span class="op">(</span><span class="ex">Name</span><span class="op">(</span>name<span class="op">))</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="ex">Invalid</span><span class="op">(</span><span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Name is empty or does not start with an uppercase character: </span><span class="ss">$name&quot;</span><span class="op">,</span> NameInvalid<span class="op">))</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>We just simply swap <code>Left</code> for <code>Invalid</code> and <code>Right</code> for <code>Valid</code> data constructors and we are done. We could have also used the <code>invalid</code> and <code>valid</code> helper functions as well:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateName</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span><span class="ex">Name</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>name<span class="op">.</span>headOption<span class="op">.</span><span class="fu">exists</span><span class="op">(</span>_<span class="op">.</span>isUpper<span class="op">))</span> <span class="ex">Name</span><span class="op">(</span>name<span class="op">).</span>valid</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Name is empty or does not start with an uppercase character: </span><span class="ss">$name&quot;</span><span class="op">,</span> NameInvalid<span class="op">).</span>invalid</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p><code>validateAge</code> requires a little more work.</p>
<p>The <code>Either</code> implementation of <code>validateAge</code> was defined as:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span>Age<span class="op">]</span> <span class="op">=</span> <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    numericAge <span class="op">&lt;-</span> <span class="fu">Try</span><span class="op">(</span>age<span class="op">.</span>toInt<span class="op">).</span>toEither<span class="op">.</span>left<span class="op">.</span><span class="fu">map</span><span class="op">(</span>ex <span class="op">=&gt;</span> <span class="fu">PersonError</span><span class="op">(</span>ex<span class="op">.</span>getMessage<span class="op">,</span> AgeInvalid<span class="op">))</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    validAge <span class="op">&lt;-</span> <span class="op">{</span> </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>numericAge <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> numericAge <span class="op">&gt;=</span> <span class="dv">120</span><span class="op">)</span> <span class="fu">Left</span><span class="op">(</span><span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Age must be a number between 1-120: </span><span class="ss">${</span>numericAge<span class="ss">}&quot;</span><span class="op">,</span> AgeInvalid<span class="op">))</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span> <span class="fu">Valid</span><span class="op">(</span>numericAge<span class="op">)</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">yield</span> <span class="fu">Age</span><span class="op">(</span>validAge<span class="op">)</span></span></code></pre></div>
<p>So we have a couple of hurdles we need to jump over:</p>
<ol type="1">
<li>How do we convert a <code>Try</code> instance to a <code>Validated</code>?</li>
<li><code>Validated</code> does not implement <code>flatMap</code>; only <code>map</code>. This means we can’t use a for-comprehension to sequence <code>Validated</code> instances.</li>
</ol>
<p>We can solve the first problem by using the function <code>fromEither</code> on <code>Validated</code> that converts an <code>Either[A, B]</code> to a <code>Validated[A, B]</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fromEither<span class="op">[</span>A<span class="op">,</span> B<span class="op">](</span>e<span class="op">:</span> Either<span class="op">[</span>A<span class="op">,</span> B<span class="op">]):</span> Validated<span class="op">[</span>A<span class="op">,</span> B<span class="op">]</span></span></code></pre></div>
<p>Updating <code>validatedAge</code> we get:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span>Age<span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> ageEither<span class="op">:</span> Either<span class="op">[</span>PersonError<span class="op">,</span> <span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">Try</span><span class="op">(</span>age<span class="op">.</span>toInt<span class="op">).</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        toEither<span class="op">.</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        left<span class="op">.</span><span class="fu">map</span><span class="op">(</span>ex <span class="op">=&gt;</span> <span class="fu">PersonError</span><span class="op">(</span>ex<span class="op">.</span>getMessage<span class="op">,</span> AgeInvalid<span class="op">))</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> validatedIntAge<span class="op">:</span> Validated<span class="op">[</span>PersonError<span class="op">,</span> <span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> Validated<span class="op">.</span><span class="fu">fromEither</span><span class="op">(</span>ageEither<span class="op">)</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>We can also use the <code>toValidated</code> to achieve the same result and IMO it’s a little nicer:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span>Age<span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> validatedIntAge<span class="op">:</span> Validated<span class="op">[</span>PersonError<span class="op">,</span> <span class="bu">Int</span><span class="op">]</span> Either<span class="op">[</span>PersonError<span class="op">,</span> <span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> </span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">Try</span><span class="op">(</span>age<span class="op">.</span>toInt<span class="op">).</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>       toEither<span class="op">.</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>       left<span class="op">.</span><span class="fu">map</span><span class="op">(</span>ex <span class="op">=&gt;</span> <span class="fu">PersonError</span><span class="op">(</span>ex<span class="op">.</span>getMessage<span class="op">,</span> AgeInvalid<span class="op">)).</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>       toValidated</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> numericAge <span class="op">=</span> <span class="op">???</span> <span class="co">//we need some way to get the Int age out of validatedIntAge</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> validateAge<span class="op">:</span> Validated<span class="op">[</span>PersonError<span class="op">,</span> Age<span class="op">]</span> <span class="op">=</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>numericAge <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> numericAge <span class="op">&gt;</span> <span class="dv">120</span><span class="op">)</span> <span class="ex">Invalid</span><span class="op">(</span><span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Age must be a number between 1-120: </span><span class="ss">${</span>numericAge<span class="ss">}&quot;</span><span class="op">,</span> AgeInvalid<span class="op">))</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span> <span class="fu">Valid</span><span class="op">(</span>numericAge<span class="op">)</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    validatedAge</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>We are almost there but we still need a way of sequencing two <code>Validated</code> instances together; where one <code>Validated</code> instance depends on the value returned from the previous <code>Validated</code> instance.</p>
<h4 id="combining">Combining</h4>
<p>Let’s see how we can answer our previous question:</p>
<blockquote>
<p>So what is it about this datatype that makes it accumulate errors in the <code>Invalid</code> case?</p>
</blockquote>
<p>In order to combine errors in a <code>Validated</code> we need the <u>types used as errors</u> to have some behaviours such as <a href="https://typelevel.org/cats/typeclasses/functor.html">Functor</a> (think something that can be mapped over) and <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Semigroupal.scala">Semigroupal</a> (think combining two effectful values into a pair of effectful values) or we need to <u>put the errors in a type</u> that has the above behaviours. One type that has those behaviours already defined is <a href="https://typelevel.org/cats/datatypes/nel.html">NonEmptyList</a>. A <code>NonEmptyList</code> is as the name suggests, a <code>List</code> that is guaranteed not to be empty (it has at least one element); which means you can safely call <code>head</code> on it among other things.</p>
<p>Cats already has a pre-build <code>Validated</code> type that uses <code>NonEmptyList</code> as its error type called <code>ValidatedNel</code>. The type definition of <code>ValidatedNel</code> reveals its form to us:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ValidatedNel<span class="op">[+</span>E<span class="op">,</span> <span class="op">+</span>A<span class="op">]</span> <span class="op">=</span> Validated<span class="op">[</span>NonEmptyList<span class="op">[</span>E<span class="op">],</span> A<span class="op">]</span></span></code></pre></div>
<p>We can see that <code>ValidatedNel</code> is a simple type alias for a <code>Validated</code> with a <code>NonEmptyList</code> of some error type <code>E</code> or a success type of <code>A</code>.</p>
<p>The <code>Nel</code> part in <code>ValidatedNel</code> refers to the <code>N</code>on<code>E</code>mpty<code>L</code>ist of the error type. There are also <code>NonEmptyVector</code> and <code>NonEmptyChain</code> variations but they encapsulate the same thing - some data structure that is not empty that is used to accumulate any errors.</p>
<p>Let’s start off by updating our <code>AllErrorsOr</code> type alias to work with <code>ValidatedNel</code> instead of <code>Validated</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">//old</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">//type AllErrorsOr[A] = Validated[PersonError, A]</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">//new</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> AllErrorsOr<span class="op">[</span>A<span class="op">]</span>   <span class="op">=</span> ValidatedNel<span class="op">[</span>PersonError<span class="op">,</span> A<span class="op">]</span></span></code></pre></div>
<p>To lift our invalid and valid values into a <code>ValidateNel</code> we can use the helper functions: <code>invalidNel</code> and <code>validNel</code> respectively. Here’s how we’d change the <code>validateName</code> function to use <code>ValidatedNel</code> instead of <code>Validated</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validateName</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span><span class="ex">Name</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>name<span class="op">.</span>headOption<span class="op">.</span><span class="fu">exists</span><span class="op">(</span>_<span class="op">.</span>isUpper<span class="op">))</span> <span class="ex">Name</span><span class="op">(</span>name<span class="op">).</span>validNel</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Name is empty or does not start with an uppercase character: </span><span class="ss">$name&quot;</span><span class="op">,</span> NameInvalid<span class="op">).</span>invalidNel</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>We can also use the usual <code>Valid</code> and <code>Invalid</code> data constructors but it’s a little cumbersome to wrap the <code>Invalid</code> case within a <code>NonEmptyList</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> cats<span class="op">.</span>data<span class="op">.</span>Validated<span class="op">.</span>_</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> cats<span class="op">.</span>data<span class="op">.</span>NonEmptyList</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validateName</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span><span class="ex">Name</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>name<span class="op">.</span>headOption<span class="op">.</span><span class="fu">exists</span><span class="op">(</span>_<span class="op">.</span>isUpper<span class="op">))</span> <span class="fu">Valid</span><span class="op">(</span><span class="ex">Name</span><span class="op">(</span>name<span class="op">))</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="ex">Invalid</span><span class="op">(</span>NonEmptyList<span class="op">.</span><span class="fu">of</span><span class="op">(</span><span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Name is empty or does not start with an uppercase character: </span><span class="ss">$name&quot;</span><span class="op">,</span> NameInvalid<span class="op">)))</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>So far so good. Let’s try and update the <code>validateAge</code> function:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span>Age<span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> numericAgeV<span class="op">:</span> AllErrorsOr<span class="op">[</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Try</span><span class="op">(</span>age<span class="op">.</span>toInt<span class="op">).</span>toEither<span class="op">.</span>left<span class="op">.</span><span class="fu">map</span><span class="op">(</span>ex <span class="op">=&gt;</span> <span class="fu">PersonError</span><span class="op">(</span>ex<span class="op">.</span>getMessage<span class="op">,</span> AgeInvalid<span class="op">)).</span>toValidatedNel</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>We can quite easily convert an <code>Either</code> to a <code>ValidateNel</code> by calling <code>toValidatedNel</code> on it. Next let’s try and update the <code>validateAge</code> function:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span>Age<span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> numericAgeV<span class="op">:</span> AllErrorsOr<span class="op">[</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="co">//from before</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">validAgeV</span><span class="op">(</span>numericAge<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> AllErrorsOr<span class="op">[</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>numericAge <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> numericAge <span class="op">&gt;</span> <span class="dv">120</span><span class="op">)</span> <span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Age must be a number between 1-120: </span><span class="ss">${</span>numericAge<span class="ss">}&quot;</span><span class="op">,</span> AgeInvalid<span class="op">).</span>invalidNel</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span> numericAge<span class="op">.</span>validNel</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>Also quite easy. The next question is how do we combine these two validations to give us an <code>Age</code>?</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>  numericAgeV <span class="op">???</span> validAgeV <span class="op">=&gt;</span> Age</span></code></pre></div>
<h5 id="andthen">andThen</h5>
<p>Here’s where the <code>andThen</code> method on <code>Validated</code> comes into play. It is defined as:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Validated<span class="op">[+</span>E<span class="op">,</span> <span class="op">+</span>A<span class="op">]</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> andThen<span class="op">[</span>EE <span class="op">&gt;:</span> E<span class="op">,</span> B<span class="op">](</span>f<span class="op">:</span> <span class="op">(</span>A<span class="op">)</span> ⇒ Validated<span class="op">[</span>EE<span class="op">,</span> B<span class="op">]):</span> Validated<span class="op">[</span>EE<span class="op">,</span> B<span class="op">]</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can see that this method definition is similar to <code>Either</code>’s <code>flatMap</code> definition, in that it sequences together two computations that may fail, returning the latter as the result:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Either<span class="op">[+</span>E<span class="op">,</span> <span class="op">+</span>A<span class="op">]</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  flatMap<span class="op">[</span>EE <span class="op">&gt;:</span> E<span class="op">,</span> B<span class="op">](</span>f<span class="op">:</span> <span class="op">(</span>A<span class="op">)</span> <span class="op">=&gt;</span> Either<span class="op">[</span>EE<span class="op">,</span> B<span class="op">]):</span> Either<span class="op">[</span>EE<span class="op">,</span> B<span class="op">]</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can also see that the first computation has to complete, to supply the <code>A</code> before the next computation can proceed. So let’s use it:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> combineAgeV<span class="op">:</span> AllErrorsOr<span class="op">[</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> numericAgeV<span class="op">.</span><span class="fu">andThen</span><span class="op">(</span>validAgeV<span class="op">)</span></span></code></pre></div>
<p>We can see that when we run <code>numericAgeV</code> validator we get a <code>AllErrorsOr[Int]</code>. This <code>Int</code> is then needed by the <code>validAgeV</code> function, which will then produce another <code>AllErrorsOr[Int]</code> if all goes well.</p>
<p>We still don’t have an <code>Age</code> instance, only an <code>Int</code>. To lift the validated <code>Int</code> value into the <code>Age</code> constructor we can use the <code>map</code> function. <code>map</code> is defined on <code>Validated</code> as follows:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Validated<span class="op">[+</span>E<span class="op">,</span> <span class="op">+</span>A<span class="op">]</span> <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> map<span class="op">[</span>B<span class="op">](</span>f<span class="op">:</span> <span class="op">(</span>A<span class="op">)</span> ⇒ B<span class="op">):</span> Validated<span class="op">[</span>E<span class="op">,</span> B<span class="op">]</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Using <code>map</code> on <code>combineAgeV</code> with the <code>Age</code> constructor gives us the final result:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> result<span class="op">:</span> AllErrorsOr<span class="op">[</span>Age<span class="op">]</span> <span class="op">=</span> combineAgeV<span class="op">.</span><span class="fu">map</span><span class="op">(</span>n <span class="op">=&gt;</span> <span class="fu">Age</span><span class="op">(</span>n<span class="op">))</span></span></code></pre></div>
<p>The complete <code>validateAge</code> function is as follows:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span>Age<span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> numericAgeV<span class="op">:</span> AllErrorsOr<span class="op">[</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Try</span><span class="op">(</span>age<span class="op">.</span>toInt<span class="op">).</span>toEither<span class="op">.</span>left<span class="op">.</span><span class="fu">map</span><span class="op">(</span>ex <span class="op">=&gt;</span> <span class="fu">PersonError</span><span class="op">(</span>ex<span class="op">.</span>getMessage<span class="op">,</span> AgeInvalid<span class="op">)).</span>toValidatedNel</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">validAgeV</span><span class="op">(</span>numericAge<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> AllErrorsOr<span class="op">[</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>numericAge <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> numericAge <span class="op">&gt;=</span> <span class="dv">120</span><span class="op">)</span> <span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Age must be a number between 1-120: </span><span class="ss">${</span>numericAge<span class="ss">}&quot;</span><span class="op">,</span> AgeInvalid<span class="op">).</span>invalidNel</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span> numericAge<span class="op">.</span>validNel</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    numericAgeV<span class="op">.</span><span class="fu">andThen</span><span class="op">(</span>validAgeV<span class="op">).</span><span class="fu">map</span><span class="op">(</span>Age<span class="op">)</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>Next lets convert our <code>validateEmail</code> function to use <code>ValidatedNel</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validateEmail</span><span class="op">(</span>email<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span>Email<span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>email<span class="op">.</span>isEmpty <span class="op">||</span> <span class="op">!</span>email<span class="op">.</span><span class="fu">contains</span><span class="op">(</span><span class="st">&quot;@&quot;</span><span class="op">))</span> <span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Email address is empty or does not contain an `@` symbol: </span><span class="ss">$email&quot;</span><span class="op">,</span> EmailInvalid<span class="op">).</span>invalidNel</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="fu">Email</span><span class="op">(</span>email<span class="op">).</span>validNel</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>That’s very similar to how we modified the <code>validateName</code> function.</p>
<p>Now let’s try and implement the <code>validatePerson</code> function. As mentioned previously, <code>Validated</code> does not implement the <code>flatMap</code> function and hence it <a href="https://stackoverflow.com/questions/35761043/how-to-make-your-own-for-comprehension-compliant-scala-monad">can’t be used in a for-comprehension</a>.
So how can we combine these three <code>Validated</code> instances? We can use the <code>andThen</code> method again but it gets quite messy:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">validateName</span><span class="op">(</span>name<span class="op">).</span><span class="fu">andThen</span><span class="op">(</span>validName <span class="op">=&gt;</span> </span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">).</span><span class="fu">andThen</span><span class="op">(</span>validAge <span class="op">=&gt;</span> </span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">validateEmail</span><span class="op">(</span>email<span class="op">).</span><span class="fu">map</span><span class="op">(</span>validEmail <span class="op">=&gt;</span> </span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">Person</span><span class="op">(</span>validName<span class="op">,</span> validAge<span class="op">,</span> validEmail<span class="op">))))</span> <span class="co">//ValidatedNel[PersonError, Person]</span></span></code></pre></div>
<p>If only there were a neater way of combining these validations. What we need is a function that is given each of the validated values if successful:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validatePerson</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> age<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> email<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span>Person<span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">validateName</span><span class="op">(</span>name<span class="op">)</span> <span class="op">???</span> <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">)</span> <span class="op">???</span> <span class="fu">validateEmail</span><span class="op">(</span>email<span class="op">)</span> <span class="op">???</span> <span class="op">(</span>validName<span class="op">,</span> validAge<span class="op">,</span> validEmail<span class="op">)</span> <span class="op">=&gt;</span> <span class="fu">Person</span><span class="op">(</span>validName<span class="op">,</span> validAge<span class="op">,</span> validEmail<span class="op">)</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<h5 id="mapn">mapN</h5>
<p>To combine two or more <code>ValidatedNel</code> instances that don’t depend on each others’ values we can use the <code>mapN</code> method. A simplified definition of <code>mapN</code> is given below:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">//A: 1st successful value</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co">//B: 2nd successful value</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co">//Z: Result of applying function `f`</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co">//E: The failure type</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mapN<span class="op">[</span>Z<span class="op">](</span>f<span class="op">:</span> <span class="op">(</span>A<span class="op">,</span> B<span class="op">)</span> <span class="op">=&gt;</span> Z<span class="op">)(</span><span class="kw">implicit</span> functor<span class="op">:</span> Functor<span class="op">[</span>ValidatedNel<span class="op">[</span>E<span class="op">,</span> <span class="op">?]],</span><span class="kw">implicit</span> semigroupal<span class="op">:</span> Semigroupal<span class="op">[</span>ValidatedNel<span class="op">[</span>E<span class="op">,?]]):</span> ValidatedNel<span class="op">[</span>E<span class="op">,</span>Z<span class="op">]</span></span></code></pre></div>
<p>Luckily we already know that <code>ValidatedNel</code> has <code>Functor</code> and <code>Semigroupal</code> instances so we can just use <code>mapN</code>. <code>mapN</code> is specialised for combining <code>Validated</code> instances from two to twenty two parameters. Using the product capabilities which we get from <code>Semigroupal</code>, we can write a function that uses the three validated values from our validators in the <code>validatePerson</code> function to create an <code>AllErrorsOr[Person]</code> instance.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validatePerson</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> age<span class="op">:</span> <span class="ex">String</span><span class="op">,</span> email<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span>Person<span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span><span class="fu">validateName</span><span class="op">(</span>name<span class="op">),</span> <span class="fu">validateAge</span><span class="op">(</span>age<span class="op">),</span> <span class="fu">validateEmail</span><span class="op">(</span>email<span class="op">)).</span><span class="fu">mapN</span><span class="op">((</span>validName<span class="op">,</span> validAge<span class="op">,</span> validEmail<span class="op">)</span> <span class="op">=&gt;</span> <span class="fu">Person</span><span class="op">(</span>validName<span class="op">,</span> validAge<span class="op">,</span> validateEmail<span class="op">))</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>Now let’s see what happens when all of the validations fail:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">validatePerson</span><span class="op">(</span><span class="st">&quot;odo&quot;</span><span class="op">,</span> <span class="st">&quot;200&quot;</span><span class="op">,</span> <span class="st">&quot;odo.founder.net&quot;</span><span class="op">)</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Invalid(NonEmptyList(PersonError(Name is empty or does not start with an uppercase character: odo,NameInvalid), PersonError(Age must be a number between 1-120: 200,AgeInvalid), PersonError(Email address is empty or does not contain an `@` symbol: odo.founder.net,EmailInvalid)))</span></span></code></pre></div>
<p>We can see that all the errors have been accumulated for us!</p>
<p>Let’s see what happens when there are no errors:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">validatePerson</span><span class="op">(</span><span class="st">&quot;Benjamin Sisko&quot;</span><span class="op">,</span> <span class="st">&quot;50&quot;</span><span class="op">,</span> <span class="st">&quot;b.sisko@dsn.st&quot;</span><span class="op">)</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Valid(Person(Name(Benjamin Sisko),Age(50),Email(b.sisko@dsn.st)))</span></span></code></pre></div>
<p>We can see the output is as expected.</p>
<h5 id="productl-and-productr">productL and productR</h5>
<p>Now let’s assume that we rewrote <code>validateName</code> such that it depended on two separate validators; one for validating a non empty name (<code>validateNonEmptyName</code>) and one for validating whether the name starts with an uppercase character (<code>validateStartsWithUpper</code>):</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validateNonEmptyName</span><span class="op">(</span>nameString<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span><span class="ex">String</span><span class="op">]</span> <span class="op">=</span> </span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>nameString<span class="op">.</span>nonEmpty<span class="op">)</span> nameString<span class="op">.</span>validNel <span class="cf">else</span> <span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">Name is empty</span><span class="ss">&quot;</span><span class="op">,</span> NameInvalid<span class="op">).</span>invalidNel</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validateStartsWithUpper</span><span class="op">(</span>nameString<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span><span class="ex">String</span><span class="op">]</span> <span class="op">=</span> </span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>nameString<span class="op">.</span>headOption<span class="op">.</span><span class="fu">exists</span><span class="op">(</span>_<span class="op">.</span>isUpper<span class="op">))</span> nameString<span class="op">.</span>validNel <span class="cf">else</span> <span class="fu">PersonError</span><span class="op">(</span><span class="ss">s&quot;$nameString</span><span class="st"> does not start with an uppercase character</span><span class="ss">&quot;</span><span class="op">,</span> NameInvalid<span class="op">).</span>invalidNel</span></code></pre></div>
<p>We might compose them as follows within the <code>validateName</code> function:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validateName</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span><span class="ex">Name</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">validateNonEmptyName</span><span class="op">(</span>name<span class="op">).</span><span class="fu">andThen</span><span class="op">(</span>_ <span class="op">=&gt;</span> <span class="fu">validateStartsWithUpper</span><span class="op">(</span>name<span class="op">)).</span><span class="fu">map</span><span class="op">(</span><span class="ex">Name</span><span class="op">)</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that we are discarding the success value returned from <code>validateNonEmptyName</code> when using the <code>andThen</code> function. We can directly use the value of the argument <code>name</code> in the <code>validateStartsWithUpper</code> function.</p>
<p>A more succinct way of writing this function composition is by using the <code>productR</code> function to ignore the result of the validator on the left and use the result of the validator on the right (hence the <code>R</code> in <code>productR</code>):</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">validateNameWithProduct</span><span class="op">(</span>name<span class="op">:</span> <span class="ex">String</span><span class="op">):</span> AllErrorsOr<span class="op">[</span><span class="ex">Name</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">(</span><span class="fu">validateNonEmptyName</span><span class="op">(</span>name<span class="op">)</span> productR <span class="fu">validateStartsWithUpper</span><span class="op">(</span>name<span class="op">)).</span><span class="fu">map</span><span class="op">(</span><span class="ex">Name</span><span class="op">)</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>There is an inverse method to <code>productR</code> called <code>productL</code> which uses the result of the validator on the left and ignores the result of the validator on the right. The important thing to realise is that both validators still get run, but only one of the success results is returned. This is a nice shorthand when you need to ignore one of the results from a validator. The <code>productL</code> and <code>productR</code> functions are available to any <a href="https://typelevel.org/cats/typeclasses/applicative.html">Applicative</a> <a href="https://typelevel.org/cats/typeclasses.html">typeclass</a> (via <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Apply.scala#L40">Apply</a>) and since <code>Validated</code> has an <code>Applicative</code> instance we get these methods for free.</p>
<h5 id="combine">combine</h5>
<p>Using <code>productL</code> and <code>productR</code> is similar to using the <code>combine</code> function available to any instance of the <a href="https://typelevel.org/cats/typeclasses/semigroup.html">Semigroup</a> typeclass (think something that can combine values similar to addition or multiplication of numbers) - with one important difference: The successes are accumulated in the event of all the validators succeeding - if your success type has an instance for <code>Semigroup</code>. Some common <code>Semigroup</code>s are <code>String</code>, <code>List</code> and <code>NoneEmptyList</code>.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">//captures all errors if there are any errors</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="fu">validateNonEmptyName</span><span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">)</span> combine <span class="fu">validateStartsWithUpper</span><span class="op">(</span><span class="st">&quot;joe&quot;</span><span class="op">)</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>res11<span class="op">:</span> Validated<span class="op">[</span>NonEmptyList<span class="op">[</span>PersonError<span class="op">],</span><span class="ex">String</span><span class="op">]</span> <span class="op">=</span> <span class="ex">Invalid</span><span class="op">(</span><span class="fu">NonEmptyList</span><span class="op">(</span><span class="fu">PersonError</span><span class="op">(</span><span class="ex">Name</span> is empty<span class="op">,</span>NameInvalid<span class="op">),</span> <span class="fu">PersonError</span><span class="op">(</span>joe does not start <span class="kw">with</span> an uppercase character<span class="op">,</span>NameInvalid<span class="op">)))</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="co">//accumulates successes when the success value is a Semigroup</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="fu">validateNonEmptyName</span><span class="op">(</span><span class="st">&quot;joe1&quot;</span><span class="op">)</span> combine <span class="fu">validateStartsWithUpper</span><span class="op">(</span><span class="st">&quot;Joe2&quot;</span><span class="op">)</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>res12<span class="op">:</span> Validated<span class="op">[</span>NonEmptyList<span class="op">[</span>PersonError<span class="op">],</span><span class="ex">String</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Valid</span><span class="op">(</span>joe1Joe2<span class="op">)</span></span></code></pre></div>
<p>This is just something to be aware of so you won’t get tripped up when your successes are also accumulated.</p>
<p>I’m not really sure when this accumulation of successes would be useful. Send me a comment if you have a problem that this solves.</p>
<h5 id="combinek">combineK</h5>
<p>What if you want to choose between two or more validators, where you only want the one that passed? Think something similar to short-circuiting <code>Boolean</code> operators such as <code>&amp;&amp;</code> or <code>||</code>.
In this scenario you could use <code>combineK</code> which comes from the <a href="https://typelevel.org/cats/typeclasses/semigroupk.html">SemigroupK</a> typeclass:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> combineK<span class="op">[</span>A<span class="op">](</span>x<span class="op">:</span> F<span class="op">[</span>A<span class="op">],</span> y<span class="op">:</span> F<span class="op">[</span>A<span class="op">]):</span> F<span class="op">[</span>A<span class="op">]</span> <span class="co">//can choose between `x` and `y` for some types of `F`</span></span></code></pre></div>
<p>Here’s how we could use it with our validators:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">//returns the first validator that succeeds</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="fu">validateNonEmptyName</span><span class="op">(</span><span class="st">&quot;joe&quot;</span><span class="op">)</span> combineK  <span class="fu">validateStartsWithUpper</span><span class="op">(</span><span class="st">&quot;Joe2&quot;</span><span class="op">)</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>res16<span class="op">:</span> net<span class="op">.</span>ssanj<span class="op">.</span>validated<span class="op">.</span>ValidatedValidations<span class="op">.</span>AllErrorsOr<span class="op">[</span><span class="ex">String</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Valid</span><span class="op">(</span>joe<span class="op">)</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="co">//tries the second validator if the first fails</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="fu">validateStartsWithUpper</span><span class="op">(</span><span class="st">&quot;joe1&quot;</span><span class="op">)</span> combineK  <span class="fu">validateStartsWithUpper</span><span class="op">(</span><span class="st">&quot;Joe2&quot;</span><span class="op">)</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>res17<span class="op">:</span> net<span class="op">.</span>ssanj<span class="op">.</span>validated<span class="op">.</span>ValidatedValidations<span class="op">.</span>AllErrorsOr<span class="op">[</span><span class="ex">String</span><span class="op">]</span> <span class="op">=</span> <span class="fu">Valid</span><span class="op">(</span>Joe2<span class="op">)</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a><span class="co">//accumulates errors if all validators fail</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a><span class="fu">validateStartsWithUpper</span><span class="op">(</span><span class="st">&quot;joe1&quot;</span><span class="op">)</span> combineK  <span class="fu">validateStartsWithUpper</span><span class="op">(</span><span class="st">&quot;joe2&quot;</span><span class="op">)</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>res18<span class="op">:</span> net<span class="op">.</span>ssanj<span class="op">.</span>validated<span class="op">.</span>ValidatedNelValidations<span class="op">.</span>AllErrorsOr<span class="op">[</span><span class="ex">String</span><span class="op">]</span> <span class="op">=</span> <span class="ex">Invalid</span><span class="op">(</span><span class="fu">NonEmptyList</span><span class="op">(</span><span class="fu">PersonError</span><span class="op">(</span>joe1 does not start <span class="kw">with</span> an uppercase character<span class="op">,</span>NameInvalid<span class="op">),</span> <span class="fu">PersonError</span><span class="op">(</span>joe2 does not start <span class="kw">with</span> an uppercase character<span class="op">,</span>NameInvalid<span class="op">)))</span></span></code></pre></div>
<h4 id="extracting">Extracting</h4>
<p>And finally you can run a <code>fold</code> on a <code>Validated</code> instance (just like you for <code>Option</code> or <code>Either</code>) to extract the value of failure or success:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Validated<span class="op">[+</span>E<span class="op">,</span> <span class="op">+</span>A<span class="op">]</span> <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> fold<span class="op">[</span>B<span class="op">](</span>fe<span class="op">:</span> <span class="op">(</span>E<span class="op">)</span> ⇒ B<span class="op">,</span> fa<span class="op">:</span> <span class="op">(</span>A<span class="op">)</span> ⇒ B<span class="op">):</span> B</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>An example usage of <code>fold</code>:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">validateNonEmptyName</span><span class="op">(</span><span class="st">&quot;joe&quot;</span><span class="op">).</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fold</span><span class="op">(</span>failure <span class="op">=&gt;</span> <span class="ss">s&quot;</span><span class="st">you failed: </span><span class="ss">$failure&quot;</span><span class="op">,</span> success <span class="op">=&gt;</span> <span class="ss">s&quot;</span><span class="st">you succeeded with </span><span class="ss">$success&quot;</span><span class="op">)</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>res19<span class="op">:</span> <span class="ex">String</span> <span class="op">=</span> you succeeded <span class="kw">with</span> joe</span></code></pre></div>
<p>You can also use pattern matching instead to achieve the same result:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode scala scrollx"><code class="sourceCode scala"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> cats<span class="op">.</span>data<span class="op">.</span>Validated<span class="op">.</span>_</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="fu">validateNonEmptyName</span><span class="op">(</span><span class="st">&quot;joe&quot;</span><span class="op">)</span> <span class="cf">match</span>  <span class="op">{</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="ex">Invalid</span><span class="op">(</span>failure<span class="op">)</span> <span class="op">=&gt;</span> <span class="ss">s&quot;</span><span class="st">you failed: </span><span class="ss">$failure&quot;</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="fu">Valid</span><span class="op">(</span>success<span class="op">)</span> <span class="op">=&gt;</span> <span class="ss">s&quot;</span><span class="st">you succeeded with </span><span class="ss">$success&quot;</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>res22<span class="op">:</span> <span class="ex">String</span> <span class="op">=</span> you succeeded <span class="kw">with</span> joe</span></code></pre></div>
<p>While it can seem like <code>Validated</code> is complex to use, in practise it is quite straight forward once you know a few rules. Hopefully this article has given you some confidence in using <code>Validated</code> the next time you need to accumulate some errors. Also be sure to read the <a href="https://typelevel.org/cats/datatypes/validated.html">Cats documentation on Validated</a> to give you more insight into their usage. Sample code for this article can be found <a href="https://github.com/ssanj/validated-examples">here</a></p>
          </article>
        </div>
        
          <div id="disqus_thread"></div>
          <script>
              /**
              *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
              *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */

              var disqus_config = function () {
              this.page.url = 'https://ssanj.github.io' + '/posts/2019-08-18-using-validated-for-error-accumulation-in-scala-with-cats.html';
              this.page.identifier = '/posts/2019-08-18-using-validated-for-error-accumulation-in-scala-with-cats.html';
              };

              (function() { // DON'T EDIT BELOW THIS LINE
              var d = document, s = d.createElement('script');
              s.src = 'https://babyloncandle.disqus.com/embed.js';
              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        
    </div>


      
    </body>
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/typeahead.bundle.min.js"></script>
    <script src="../js/handlebars-v1.3.0.js"></script>
    <script src="../js/babyloncandle.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55156872-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-55156872-1');
    </script>
</html>
