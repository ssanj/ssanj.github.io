<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Stacking the ReaderT WriterT Monad Transformer Stack in Haskell</title>
    <meta name="viewport" content="width=device-width">
    
    <meta name="description" content="How to stack a Monad Transformer stack of a ReaderT Writer.">
    
    <link rel="canonical" href="https://blog.ssanj.net/posts/2018-01-12-stacking-the-readert-writert-monad-transformer-stack-in-haskell.html">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../css/main-2024-05-08.css">
    <link rel="stylesheet" type="text/css" href="../css/example-2024-05-05.css">
    <link rel="stylesheet" href="../css/syntax-2024-05-05.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    
  </head>

    <body>
      
          <div class="page-content">
      <div class="wrap">
        <div class="post">
          <header class="post-header">
            <h1><a href="../">Stacking the ReaderT WriterT Monad Transformer Stack in Haskell</a></h1>
            <p class="meta">January 12, 2018&nbsp;<span class="post-tag"><a title="All pages tagged 'fp'." href="../tags/fp.html">fp</a>, <a title="All pages tagged 'haskell'." href="../tags/haskell.html">haskell</a>, <a title="All pages tagged 'monad-transformer'." href="../tags/monad-transformer.html">monad-transformer</a></span></p>
          </header>
          <article class="post-content">
            <p>Stacking Monads can be somewhat confusing to get your head around. While looking around for a decent example, I came across this <a href="https://gist.github.com/Decoherence/39a4c34685d86a334b63">Gist</a> by
<a href="https://github.com/Decoherence">Decoherence</a> on how to combine a <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control-Monad-Trans-Reader.html#ReaderT">ReaderT</a> with a <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control-Monad-Trans-Writer-Lazy.html#WriterT">WriterT</a> over some Monad.</p>
<p>I needed to use this stack as I was working with the IO Monad and needed some way to capture the outcomes of a computation (via a Writer) and also needed to supply the initial inputs (via a Reader).</p>
<p>While <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html">Reader</a> and <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html">Writer</a> Monads on their own seem easy to use, it can be somewhat daunting to try and figure out how to combine the transformer variations of these Monads over some other Monad.</p>
<figure>
<img src="https://scalerablog.files.wordpress.com/2015/10/bdu68sacyaafkkr.jpg" alt="Say Monad one more time" />
<figcaption aria-hidden="true">Say Monad one more time</figcaption>
</figure>
<p>I’m documenting my findings on how to use this stack here for anyone who might be also struggling to figure out how all this stuff hangs together. It is also for my future-self who might need a quick refresher.</p>
<h2 id="reader-and-readert">Reader and ReaderT</h2>
<p>Let’s start by looking at the type signature for the Reader Monad:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>r <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>The Reader Monad when given some resource, <strong>r</strong> from the environment will return a result of <strong>a</strong>.</p>
<p>The type variables defined are as follows:</p>
<ul>
<li>r = resource from the environment</li>
<li>a = value returned</li>
</ul>
<p>Next lets have a look at the type signature for a ReaderT Monad Transformer (MT):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a <span class="ot">=</span> <span class="dt">ReaderT</span> {<span class="ot"> runReaderT ::</span> r <span class="ot">-&gt;</span> m a }</span></code></pre></div>
<p>This is less clear than the definition of the Reader Monad. As we’ll see below they are essentially very similar.</p>
<p>The type variables defined are as follows:</p>
<ul>
<li>r = resource from the environment</li>
<li>m = the resulting Monad</li>
<li>a = value returned in the Monad</li>
</ul>
<p>The ReaderT MT has one extra type variable <strong>m</strong> which is a Monad. If we examine the ReaderT constructor we can see that it encapsulates a type very similar to that of the Reader Monad:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>r <span class="ot">-&gt;</span> m a <span class="co">-- ReaderT MT</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>r <span class="ot">-&gt;</span>   a <span class="co">-- Reader Monad</span></span></code></pre></div>
<p>The ReaderT MT is simply a Reader Monad whose result is returned within another Monad. More on that later. Hopefully the connection between the Reader Monad and the Reader MT is clearer.</p>
<p>When we see a ReaderT r m a we can mentally substitute it with a function of the type:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>r <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>And when we see a function of the type <code>r -&gt; m a</code> we can mentally substitute it with:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ReaderT</span> r m a</span></code></pre></div>
<p>Depending on the situation it might be easier to think in one of the above versions of the ReaderT MT.</p>
<p>Given a ReaderT r m a we can unwrap its value via the <em>runReaderT</em> method:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runReaderT ::</span> <span class="dt">ReaderT</span> r m a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>Also given a simple Reader Monad (<code>r -&gt; a</code>) we can lift it into a ReaderT MT with the <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#v:reader"><em>reader</em></a> or the <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#v:asks"><em>asks</em></a> function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>reader,<span class="ot">asks ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a</span></code></pre></div>
<p>Also note that ReaderT r m is a Monad if <strong>m</strong> is a Monad:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ReaderT</span> r m)</span></code></pre></div>
<p>This is important to know when using <em>do</em> notation with the ReaderT MT as each bind operation will result in a ReaderT r m and not a ReaderT:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> <span class="dt">ReaderT</span> r m a</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>someFunc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    r <span class="ot">&lt;-</span> ask</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> a <span class="co">-- this will be returned into ReaderT r m</span></span></code></pre></div>
<p>If you need to wrap a value within a ReaderT MT use:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ReaderT</span> \r <span class="ot">-&gt;</span> <span class="co">-- your value of (m a)</span></span></code></pre></div>
<p>This might all seem very confusing at the moment. These are different ways of lifting values into the transformer stack at different points. Once you start using the ReaderT MT this will become clearer.</p>
<p>Some other useful functions that work with the ReaderT MT are:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#v:ask"><em>ask</em></a> - to retrieve the supplied resource</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ask ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> r m r</span></code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#v:local"><em>local</em></a> - to map a function on the resource <em>before</em> using it:</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">local ::</span> (r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a</span></code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#v:mapReaderT"><em>mapReaderT</em></a> - to change all components of the ReaderT MT except the input type (the inner Monad and result type):</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapReaderT ::</span> (m a <span class="ot">-&gt;</span> n b) <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r n b</span></code></pre></div>
<h2 id="writer-and-writert">Writer and WriterT</h2>
<p>As we’ve not looked at the definitions of the Writer Monad and the WriterT MT let’s do that now. The Writer Monad is defined as:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>(a, w)</span></code></pre></div>
<p>The type variables defined are:</p>
<ul>
<li>a = return value</li>
<li>w = log value (which has to be an <a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html">Monoid</a>)</li>
</ul>
<p>The Writer Monad will return a pair of values; a result <strong>a</strong> along with an accumulated log <strong>w</strong>.</p>
<p>The WriterT MT is defined as:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">WriterT</span> w m a <span class="ot">=</span> <span class="dt">WriterT</span> {<span class="ot"> runWriterT ::</span> m (a, w) }</span></code></pre></div>
<p>where the type variables defined are:</p>
<ul>
<li>a = return value</li>
<li>m = the resulting Monad</li>
<li>w = log value (which has to be an Monoid)</li>
</ul>
<p>Both <strong>a</strong> and <strong>w</strong> are returned as a pair within the Monad <strong>m</strong>.</p>
<p>The WriterT constructor encapsulates:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>m (a, w)</span></code></pre></div>
<p>It’s basically a Writer Monad within another Monad m:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  (a, w) <span class="co">-- Writer Monad</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>m (a, w) <span class="co">-- WriterT MT</span></span></code></pre></div>
<p>Some other useful functions that work with the WriterT MT are:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html#v:runWriterT"><em>runWriterT</em></a> - to unwrap the value of a WriterT MT and return the result and the log:</li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runWriterT ::</span> <span class="dt">WriterT</span> w m a <span class="ot">-&gt;</span> m (a, w)</span></code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html#v:execWriterT"><em>execWriterT</em></a> - to unwrap the value of a WriterT MT and return only the log:</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">execWriterT ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">WriterT</span> w m a <span class="ot">-&gt;</span> m w</span></code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html#v:tell"><em>tell</em></a> - to write a log entry into the WriterT MT:</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tell ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> w <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m ()</span></code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html#v:listen"><em>listen</em></a> - to change the result to include the log:</li>
</ul>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">listen ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">WriterT</span> w m a <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m (a, w)</span></code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Writer-Lazy.html#v:pass"><em>pass</em></a> - to run a function on the log to update it:</li>
</ul>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pass ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">WriterT</span> w m (a, w <span class="ot">-&gt;</span> w) <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m a</span></code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Lazy.html#v:mapWriter"><em>mapWriterT</em></a> - to change all components of the WriterT MT (the inner Monad, result and log type):</li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapWriterT ::</span> (m (a, w) <span class="ot">-&gt;</span> n (b, w’)) <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m a <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w’ n b</span></code></pre></div>
<h2 id="monadtrans">MonadTrans</h2>
<p>Let’s also have a look at the <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> typeclass. It defines one function called <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html#v:lift"><em>lift</em></a>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lift ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</span></code></pre></div>
<p>that lifts a Monad into a MT. We can use this function to insert a Monad into a given transformer stack.</p>
<h2 id="a-readert-writert-example">A ReaderT WriterT example</h2>
<p>Phew! We’ve just had a whirlwind tour of some typeclasses and related functions. Now let’s have a look at an example of using a ReaderT/WriterT transformer stack.</p>
<p>Say we had some configuration about an external service, like its <em>host</em> and <em>port</em>. We might use a Reader Monad to supply that configuration to the program.</p>
<p>Let’s start by defining a type alias to a Map of String keys and values:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Lazy</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Config</span> <span class="ot">=</span> <span class="dt">M.Map</span> <span class="dt">String</span> <span class="dt">String</span></span></code></pre></div>
<p>Let’s also define a <em>serverConfig</em> function to return our populated configuration from a list of key-value pairs:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">serverConfig ::</span> <span class="dt">Config</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>serverConfig <span class="ot">=</span> M.fromList [(<span class="st">&quot;host&quot;</span>, <span class="st">&quot;localhost&quot;</span>), (<span class="st">&quot;port&quot;</span>, <span class="st">&quot;7654&quot;</span>)]</span></code></pre></div>
<p>Let’s definite a function to read the host:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getHost ::</span> <span class="dt">Reader</span> <span class="dt">Config</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)</span></code></pre></div>
<p>Given a <em>Config</em> this function will return the host name in a <em>Just</em> if present, or a <em>Nothing</em> if not.</p>
<p>It would could be implemented as:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getHost ::</span> <span class="dt">Reader</span> <span class="dt">Config</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>getHost <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> ask</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (Map.lookup <span class="st">&quot;host&quot;</span> config)</span></code></pre></div>
<p>First, the <em>getHost</em> function requests the Config instance from the environment using the <em>ask</em> function. It then looks up the “host” key from that config. Finally it lifts the Maybe value returned from the <a href="http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Lazy.html#v:lookup"><em>lookup</em></a> function into the Reader Monad using the <em>return</em> function.</p>
<p>Let’s define a function to read the port:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getPort ::</span> <span class="dt">Reader</span> <span class="dt">Config</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span></code></pre></div>
<p>It would could be implemented as:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getPort ::</span> <span class="dt">Reader</span> <span class="dt">Config</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>getPort <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> ask</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (Map.lookup <span class="st">&quot;port&quot;</span> config <span class="op">&gt;&gt;=</span> readMaybe)</span></code></pre></div>
<p>This function is similar to <em>getHost</em> with the additional bind (&gt;&gt;=) operation to join together the value read from <em>lookup</em> with <a href="https://hackage.haskell.org/package/base-4.8.1.0/docs/Text-Read.html#v:readMaybe"><em>readMaybe</em></a>. readMaybe tries to parse a String into a value of type Int in this case. If it successfully parses the value it returns a (<em>Just Int</em>) or if it fails it returns a <em>Nothing</em>. readMaybe is defined as:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readMaybe ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span></code></pre></div>
<p>Also notice that we used a Reader Monad as opposed to a ReaderT MT to read both the host and port. Since the Reader Monad and the ReaderT MT are very similar we can easily convert between them. Why didn’t we use a ReaderT MT directly to read the configuration? We could have, but the ReaderT MT requires an inner Monad m:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ReaderT</span> r m a</span></code></pre></div>
<p>and we haven’t decided on what <strong>m</strong> is at the moment. I’ll demonstrate how we could have directly used a ReaderT MT to implement <em>getHost</em> and <em>getPort</em> <a href="https://sanj.ink/posts/2018-01-12-stacking-the-readert-writert-monad-transformer-stack-in-haskell.html#using-readert-instead-of-reader">later</a> on.</p>
<p>Now that we’ve written functions to read the host and port, lets go ahead and use those values in a ReaderT MT along with a WriterT MT to log out the values we received from the configuration:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getConfig ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()</span></code></pre></div>
<p>Given a Config type as an input, the result returned will be in a WriterT MT with a log type of String with an inner Monad of IO and a value of unit () returned within IO. That sounds more complicated than it really is.</p>
<p>It’s implemented as:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getConfig ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>getConfig <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  hostM <span class="ot">&lt;-</span> fromReader getHost</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  portM <span class="ot">&lt;-</span> fromReader getPort</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> host <span class="ot">=</span> <span class="fu">maybe</span> <span class="st">&quot;-&quot;</span> <span class="fu">id</span> hostM</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>      port <span class="ot">=</span> <span class="fu">maybe</span> <span class="st">&quot;-&quot;</span> <span class="fu">show</span> portM</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> <span class="st">&quot;\nConfig&quot;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> <span class="st">&quot;\n======&quot;</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> (printf <span class="st">&quot;\nhost: %s&quot;</span> host)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> (printf <span class="st">&quot;\nport: %s&quot;</span> port)</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ()</span></code></pre></div>
<p>Let’s delve into the implementation of <em>getConfig</em>. The first two lines read the host and port into Maybe values from the configuration:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>  hostM <span class="ot">&lt;-</span> fromReader getHost</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  portM <span class="ot">&lt;-</span> fromReader getPort</span></code></pre></div>
<p>The next two lines covert the Maybe values for host and port into their String equivalents:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> host <span class="ot">=</span> <span class="fu">maybe</span> <span class="st">&quot;-&quot;</span> <span class="fu">id</span> hostM</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>      port <span class="ot">=</span> <span class="fu">maybe</span> <span class="st">&quot;-&quot;</span> <span class="fu">show</span> portM</span></code></pre></div>
<p>The next four lines write String values to the log in order:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> <span class="st">&quot;\nConfig&quot;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> <span class="st">&quot;\n======&quot;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> (printf <span class="st">&quot;\nhost: %s&quot;</span> host)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> (printf <span class="st">&quot;\nport: %s&quot;</span> port)</span></code></pre></div>
<p>and the final line returns a Unit result into the ReaderT r m Monad:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> ()</span></code></pre></div>
<p>which in this case is the ReaderT (WriterT String IO) Monad.</p>
<p>Let’s look at the type definition of the <em>fromReader</em> function:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromReader ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a</span></code></pre></div>
<p><em>fromReader</em> converts a Reader Monad to a ReaderT MT. It is implemented as:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromReader ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>fromReader <span class="ot">=</span> reader <span class="op">.</span> runReader</span></code></pre></div>
<p>The <em>runReader</em> function is defined as:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runReader ::</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>and unwraps the Reader Monad to a function (<code>r -&gt; a</code>). The <em>reader</em> function (as defined previously) lifts a function from (<code>r -&gt; a</code>) into the ReaderT MT. This seems like unnecessary work and ideally there should be an in-built function that does this for us.</p>
<p>Next let’s have a look at the <em>log</em> function:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">log</span><span class="ot"> ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadTrans</span> t, <span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> w <span class="ot">-&gt;</span> t (<span class="dt">WriterT</span> w m) ()</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="fu">log</span> <span class="ot">=</span> lift <span class="op">.</span> tell</span></code></pre></div>
<p>From the type definition of <em>tell</em>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tell ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> w <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m ()</span></code></pre></div>
<p>we can see that we almost get the result we want:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>w <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m ()</span></code></pre></div>
<p>We just need to lift the WriterT w m Monad into a Monad Transformer <strong>t</strong> and we can do that with the <em>lift</em> defined previously:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lift ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</span></code></pre></div>
<p>which gives us:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>w <span class="ot">-&gt;</span> <span class="dt">WriterT</span> w m () <span class="co">-- tell</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>m a <span class="ot">-&gt;</span> t m a <span class="co">-- lift</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- replacing m with (WriterT w m)</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>(<span class="dt">WriterT</span> w m) a <span class="ot">-&gt;</span> t (<span class="dt">WriterT</span> w m) a</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- replacing a with ()</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>(<span class="dt">WriterT</span> w m) () <span class="ot">-&gt;</span> t (<span class="dt">WriterT</span> w m) ()</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- combining lift . tell</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>w <span class="ot">-&gt;</span> t (<span class="dt">WriterT</span> w m) ()</span></code></pre></div>
<p>We can see that we are lifing some log <strong>w</strong> into a transformer stack <strong>t</strong> through the WriterT w m Monad.</p>
<p>We’ve come a long way and we’ve got everything setup as needed. The only thing left to do is run the transformer stack and reap our rewards. We can do that with the <em>readWriteConfig</em> function:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readWriteConfig ::</span> <span class="dt">IO</span> ()</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>readWriteConfig <span class="ot">=</span> execWriterT (runReaderT getConfig serverConfig) <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span></span></code></pre></div>
<p>When running the stack, it is run from outside-in. So given a <em>ReaderT (WriterT String m) a</em>,
we:</p>
<ol type="1">
<li>Run the ReaderT MT:</li>
</ol>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>r <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>with runReaderT. This returns the result <strong>a</strong> in the inner Monad <strong>m</strong> which is a WriterT String m. Substituting the IO Monad for <strong>m</strong> and Unit for <strong>a</strong> returns a WriterT String IO (). We don’t care about the result of <strong>a</strong> - only the log.</p>
<ol start="2" type="1">
<li>Run the WriterT MT:</li>
</ol>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>m (a, w)</span></code></pre></div>
<p>with execWriterT. This returns the log <strong>w</strong> in the inner Monad <strong>m</strong> which is an <strong>m w</strong>. Substituting the IO Monad for <strong>m</strong> and String for <strong>w</strong>, returns an IO String.</p>
<ol start="3" type="1">
<li>Binding through from IO String to <em>putStrLn</em> gives us an IO (). The final output of running the above is:</li>
</ol>
<pre class="terminal scrollx"><code>Config
======
host: localhost
port: 7654</code></pre>
<h3 id="using-readert-instead-of-reader">Using ReaderT instead of Reader</h3>
<p>I previously mentioned that we could have written the <em>getHost</em> and <em>getPort</em> functions with a ReaderT MT instead of a Reader Monad. Here’s how we’d do that:</p>
<p><em>getHost2</em></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getHost2 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> m (<span class="dt">Maybe</span> <span class="dt">String</span>)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>getHost2 <span class="ot">=</span> <span class="co">-- same as getHost</span></span></code></pre></div>
<p>Notice that the only difference between <em>getHost</em> and <em>getHost2</em> is the addition of a new type variable <em>m</em> which is a Monad:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getHost  ::</span>            <span class="dt">Reader</span>  <span class="dt">Config</span>   (<span class="dt">Maybe</span> <span class="dt">String</span>) <span class="co">-- Reader Monad</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getHost2 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> m (<span class="dt">Maybe</span> <span class="dt">String</span>) <span class="co">-- ReaderT MT</span></span></code></pre></div>
<p>And since we are working with Monads in both cases, the implementation code remains unchanged! So just by changing the type definition of the <em>getConfig</em> method we can go from a Reader Monad to a ReaderT MT!</p>
<p><em>getPort2</em></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getPort2 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> m (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>getPort2 <span class="ot">=</span> <span class="co">-- same as getPort</span></span></code></pre></div>
<p><em>getConfig2</em></p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getConfig2 ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>getConfig2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  hostM <span class="ot">&lt;-</span> getHost2 <span class="co">-- no need to call fromReader</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  portM <span class="ot">&lt;-</span> getPort2 <span class="co">-- no need to call fromReader</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span> <span class="co">-- same as getConfig</span></span></code></pre></div>
<p>We can see that this solution is a lot easier with less work to do. We just needed to add a Monad type constraint to the <em>getHost2</em> and <em>getPort2</em> functions. We also have no need for the <em>fromReader</em> function which is a bonus! We can also call the <em>readWriteConfig</em> function with <em>getConfig2</em> instead of <em>getConfig</em> and it all works:</p>
<p><em>readWriteConfig2</em></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readWriteConfig2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>readWriteConfig2 <span class="ot">=</span> execWriterT (runReaderT getConfig2 serverConfig) <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span></span></code></pre></div>
<p>The complete Solution</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Config</span> (readWriteConfig) <span class="kw">where</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Printf</span> (printf)</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.IO.Class</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans.Class</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans.Reader</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans.Writer.Lazy</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Lazy</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (intercalate)</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Functor.Identity</span> (<span class="dt">Identity</span>, runIdentity)</span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Read</span> (readMaybe)</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (log)</span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Config</span> <span class="ot">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a><span class="ot">serverConfig ::</span> <span class="dt">Config</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>serverConfig <span class="ot">=</span> Map.fromList [(<span class="st">&quot;host&quot;</span>, <span class="st">&quot;localhost&quot;</span>), (<span class="st">&quot;port&quot;</span>, <span class="st">&quot;7654&quot;</span>)]</span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- variation with Reader</span></span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a><span class="ot">getHost ::</span> <span class="dt">Reader</span> <span class="dt">Config</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)</span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a>getHost <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> ask</span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (Map.lookup <span class="st">&quot;host&quot;</span> config)</span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true" tabindex="-1"></a><span class="ot">getPort ::</span> <span class="dt">Reader</span> <span class="dt">Config</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true" tabindex="-1"></a>getPort <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> ask</span>
<span id="cb56-29"><a href="#cb56-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (Map.lookup <span class="st">&quot;port&quot;</span> config <span class="op">&gt;&gt;=</span> readMaybe)</span>
<span id="cb56-30"><a href="#cb56-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-31"><a href="#cb56-31" aria-hidden="true" tabindex="-1"></a><span class="ot">fromReader ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r m a</span>
<span id="cb56-32"><a href="#cb56-32" aria-hidden="true" tabindex="-1"></a>fromReader <span class="ot">=</span> reader <span class="op">.</span> runReader</span>
<span id="cb56-33"><a href="#cb56-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-34"><a href="#cb56-34" aria-hidden="true" tabindex="-1"></a><span class="fu">log</span><span class="ot"> ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadTrans</span> t, <span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> w <span class="ot">-&gt;</span> t (<span class="dt">WriterT</span> w m) ()</span>
<span id="cb56-35"><a href="#cb56-35" aria-hidden="true" tabindex="-1"></a><span class="fu">log</span> <span class="ot">=</span> lift <span class="op">.</span> tell</span>
<span id="cb56-36"><a href="#cb56-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-37"><a href="#cb56-37" aria-hidden="true" tabindex="-1"></a><span class="ot">getConfig ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()</span>
<span id="cb56-38"><a href="#cb56-38" aria-hidden="true" tabindex="-1"></a>getConfig <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb56-39"><a href="#cb56-39" aria-hidden="true" tabindex="-1"></a>  hostM <span class="ot">&lt;-</span> fromReader getHost</span>
<span id="cb56-40"><a href="#cb56-40" aria-hidden="true" tabindex="-1"></a>  portM <span class="ot">&lt;-</span> fromReader getPort</span>
<span id="cb56-41"><a href="#cb56-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> host <span class="ot">=</span> <span class="fu">maybe</span> <span class="st">&quot;-&quot;</span> <span class="fu">id</span> hostM</span>
<span id="cb56-42"><a href="#cb56-42" aria-hidden="true" tabindex="-1"></a>      port <span class="ot">=</span> <span class="fu">maybe</span> <span class="st">&quot;-&quot;</span> <span class="fu">show</span> portM</span>
<span id="cb56-43"><a href="#cb56-43" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> <span class="st">&quot;\nConfig&quot;</span></span>
<span id="cb56-44"><a href="#cb56-44" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> <span class="st">&quot;\n======&quot;</span></span>
<span id="cb56-45"><a href="#cb56-45" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> (printf <span class="st">&quot;\nhost: %s&quot;</span> host)</span>
<span id="cb56-46"><a href="#cb56-46" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> (printf <span class="st">&quot;\nport: %s&quot;</span> port)</span>
<span id="cb56-47"><a href="#cb56-47" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ()</span>
<span id="cb56-48"><a href="#cb56-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-49"><a href="#cb56-49" aria-hidden="true" tabindex="-1"></a><span class="ot">readWriteConfig ::</span> <span class="dt">IO</span> ()</span>
<span id="cb56-50"><a href="#cb56-50" aria-hidden="true" tabindex="-1"></a>readWriteConfig <span class="ot">=</span> execWriterT (runReaderT getConfig serverConfig) <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span></span>
<span id="cb56-51"><a href="#cb56-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-52"><a href="#cb56-52" aria-hidden="true" tabindex="-1"></a><span class="co">-- variation with ReaderT</span></span>
<span id="cb56-53"><a href="#cb56-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-54"><a href="#cb56-54" aria-hidden="true" tabindex="-1"></a><span class="ot">getHost2 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> m (<span class="dt">Maybe</span> <span class="dt">String</span>)</span>
<span id="cb56-55"><a href="#cb56-55" aria-hidden="true" tabindex="-1"></a>getHost2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb56-56"><a href="#cb56-56" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> ask</span>
<span id="cb56-57"><a href="#cb56-57" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (Map.lookup <span class="st">&quot;host&quot;</span> config)</span>
<span id="cb56-58"><a href="#cb56-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-59"><a href="#cb56-59" aria-hidden="true" tabindex="-1"></a><span class="ot">getPort2 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> m (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb56-60"><a href="#cb56-60" aria-hidden="true" tabindex="-1"></a>getPort2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb56-61"><a href="#cb56-61" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> ask</span>
<span id="cb56-62"><a href="#cb56-62" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (Map.lookup <span class="st">&quot;port&quot;</span> config <span class="op">&gt;&gt;=</span> readMaybe)</span>
<span id="cb56-63"><a href="#cb56-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-64"><a href="#cb56-64" aria-hidden="true" tabindex="-1"></a><span class="ot">getConfig2 ::</span> <span class="dt">ReaderT</span> <span class="dt">Config</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()</span>
<span id="cb56-65"><a href="#cb56-65" aria-hidden="true" tabindex="-1"></a>getConfig2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb56-66"><a href="#cb56-66" aria-hidden="true" tabindex="-1"></a>  hostM <span class="ot">&lt;-</span> getHost2</span>
<span id="cb56-67"><a href="#cb56-67" aria-hidden="true" tabindex="-1"></a>  portM <span class="ot">&lt;-</span> getPort2</span>
<span id="cb56-68"><a href="#cb56-68" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> host <span class="ot">=</span> <span class="fu">maybe</span> <span class="st">&quot;-&quot;</span> <span class="fu">id</span> hostM</span>
<span id="cb56-69"><a href="#cb56-69" aria-hidden="true" tabindex="-1"></a>      port <span class="ot">=</span> <span class="fu">maybe</span> <span class="st">&quot;-&quot;</span> <span class="fu">show</span> portM</span>
<span id="cb56-70"><a href="#cb56-70" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> <span class="st">&quot;\nConfig&quot;</span></span>
<span id="cb56-71"><a href="#cb56-71" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> <span class="st">&quot;\n======&quot;</span></span>
<span id="cb56-72"><a href="#cb56-72" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> (printf <span class="st">&quot;\nhost: %s&quot;</span> host)</span>
<span id="cb56-73"><a href="#cb56-73" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> (printf <span class="st">&quot;\nport: %s&quot;</span> port)</span>
<span id="cb56-74"><a href="#cb56-74" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ()</span>
<span id="cb56-75"><a href="#cb56-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-76"><a href="#cb56-76" aria-hidden="true" tabindex="-1"></a><span class="ot">readWriteConfig2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb56-77"><a href="#cb56-77" aria-hidden="true" tabindex="-1"></a>readWriteConfig2 <span class="ot">=</span> execWriterT (runReaderT getConfig2 serverConfig) <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span></span></code></pre></div>
<h2 id="a-tale-of-at-least-two-monads">A Tale of At Least Two Monads</h2>
<p>A Monad is based on a type constructor:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>)</span></code></pre></div>
<p>which has one type hole; it creates a type when given a type. A simple example is the Maybe Monad:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Maybe</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span></code></pre></div>
<p>While we can create a Monad instance for the Maybe type constructor, a specific Maybe instance like Maybe String can’t have one because it has no type holes:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a> <span class="dt">Maybe</span><span class="ot">         ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Maybe</span> <span class="dt">String</span>)<span class="ot"> ::</span>      <span class="op">*</span> <span class="co">-- no type hole</span></span></code></pre></div>
<p>Each Monad Transformer is composed of at least two Monads. If we take ReaderT MT as an example, we have its definition as:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ReaderT</span> r m a</span></code></pre></div>
<p>where ReaderT r m is a Monad and <strong>m</strong> is also a Monad. If you stack Monads, in the <strong>m</strong> type variable as with a WriterT for example:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ReaderT</span> r (<span class="dt">WriterT</span> w m) a</span></code></pre></div>
<p>then ReaderT r (WriterT w m) is a Monad, WriterT w m is a Monad and <strong>m</strong> is a Monad. Talk about Monad overload!</p>
<figure>
<img src="../images/readertwritert/mind-blown.gif" alt="Mind Blown" />
<figcaption aria-hidden="true">Mind Blown</figcaption>
</figure>
<h2 id="decoherences-example">Decoherence’s Example</h2>
<p>What we’ve learned so far will help us understand the example from Decoherence I mentioned at the start of this post.</p>
<p>We start off by defining a data type for a Person:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span> {<span class="ot"> name ::</span> <span class="dt">String</span> } <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>We then create a few specific Person instances:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alex ::</span> <span class="dt">Person</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>alex <span class="ot">=</span> <span class="dt">Person</span> <span class="st">&quot;Alex Fontaine&quot;</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="ot">philip ::</span> <span class="dt">Person</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>philip <span class="ot">=</span> <span class="dt">Person</span> <span class="st">&quot;Philip Carpenter&quot;</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="ot">kim ::</span> <span class="dt">Person</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>kim <span class="ot">=</span> <span class="dt">Person</span> <span class="st">&quot;Kim Lynch&quot;</span></span></code></pre></div>
<p>followed by a <em>peopleDb</em> function that returns a list of Person instances:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="ot">peopleDb ::</span> [<span class="dt">Person</span>]</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>peopleDb <span class="ot">=</span> [alex, philip, kim]</span></code></pre></div>
<p>We then define a <em>process</em> function as:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="ot">process ::</span> <span class="dt">ReaderT</span> <span class="dt">Person</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()</span></code></pre></div>
<p>and a <em>process’</em> function as:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="ot">process' ::</span> <span class="dt">ReaderT</span> <span class="dt">Person</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) <span class="dt">String</span></span></code></pre></div>
<p>The main difference between the above functions is that one returns a Unit return type and the other returns a String, respectively. Given that the ReaderT MT stack is almost the same as that in the previous example, it should be fairly easy to implement the above functions.</p>
<p>The <em>process</em> function is implemented as:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="ot">process ::</span> <span class="dt">ReaderT</span> <span class="dt">Person</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>process <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> <span class="op">$</span> <span class="st">&quot;Looking up Person. &quot;</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Person</span> p <span class="ot">&lt;-</span> ask</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> <span class="op">$</span> printf <span class="st">&quot;Found person: %s. &quot;</span> p</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>  (liftIO <span class="op">.</span> <span class="fu">putStrLn</span>) p</span></code></pre></div>
<p>We’ve not seen the <a href="https://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-IO-Class.html#v:liftIO"><em>liftIO</em></a> function before. It’s defined in the <a href="https://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-IO-Class.html">MonadIO</a> typeclass as:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>which just lifts a value from the IO Monad into another Monad. In the above example, <em>liftIO</em> will lift a Unit value from the IO Monad (<code>putStrLn p</code>), into the ReaderT Person (WriterT String IO) Monad.</p>
<p>The <em>process’</em> function is implemented as:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="ot">process' ::</span> <span class="dt">ReaderT</span> <span class="dt">Person</span> (<span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span>) <span class="dt">String</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>process' <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> <span class="st">&quot;Looking up Person... &quot;</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Person</span> p <span class="ot">&lt;-</span> ask</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">log</span> <span class="op">$</span> printf <span class="st">&quot;Found person: %s. &quot;</span> p</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> p</span></code></pre></div>
<p>Let’s define a function to run the transformer stack:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readWritePeople ::</span> <span class="dt">IO</span> ()</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>readWritePeople <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>Let’s start by running the <em>process</em> function with a Person instance:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>  result1 <span class="ot">&lt;-</span> runWriterT (runReaderT process alex) <span class="co">-- :: ((), String)</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> (<span class="fu">putStrLn</span> <span class="op">.</span> <span class="fu">snd</span>) result1</span></code></pre></div>
<p>Next let’s Run the <em>process’</em> function with a Person instance:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>  result2 <span class="ot">&lt;-</span> runWriterT (runReaderT process' alex) <span class="co">-- :: (String, String)</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> (<span class="fu">putStrLn</span> <span class="op">.</span> <span class="fu">fst</span>) result2</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> (<span class="fu">putStrLn</span> <span class="op">.</span> <span class="fu">snd</span>) result2</span></code></pre></div>
<h3 id="traversable">Traversable</h3>
<p>Before we look at the next invocation let’s look at the definition of the <a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:mapM"><em>mapM</em></a> function. The <em>mapM</em> function maps each element of a structure to a monadic action, evaluates these actions from left to right, and collects the results.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM</span><span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</span></code></pre></div>
<p><em>t</em> is the <a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html">Traversable</a> typeclass which has a <a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#t:Functor">Functor</a> and <a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Foldable.html">Foldable</a> constraint:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Functor</span> t, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> <span class="dt">Traversable</span> t <span class="kw">where</span></span></code></pre></div>
<p>There is also a similarly named <a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:mapM_">mapM_</a> function:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM_</span><span class="ot"> ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>which just differs from <em>mapM</em> in its result:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM</span><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM_</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m () <span class="co">-- only performs a side effect</span></span></code></pre></div>
<p>which it discards (returns Unit). This is useful when you don’t care about the return value and just want to perform some side effect.</p>
<p>Some other interesting functions on the Traversable typeclass are:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:traverse">traverse</a> - has the same definition as <em>mapM</em> where the container is an Applicative instead of a Monad:</li>
</ul>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="fu">traverse</span><span class="ot"> ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM</span><span class="ot">     ::</span> <span class="dt">Monad</span>       m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</span></code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:sequencea">sequenceA</a> - Evaluate each action in the structure from left to right, and and collect the results.</li>
</ul>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sequenceA</span><span class="ot"> ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> t (f a) <span class="ot">-&gt;</span> f (t a)</span></code></pre></div>
<ul>
<li><a href="http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Traversable.html#v:sequence">sequence</a> - Evaluate each monadic action in the structure from left to right, and collect the results.</li>
</ul>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span><span class="ot">   ::</span> <span class="dt">Monad</span> m      <span class="ot">=&gt;</span> t (m a) <span class="ot">-&gt;</span> m (t a)</span></code></pre></div>
<p><em>sequence</em> and <em>sequenceA</em> are also Monadic and Applicative variants of each other:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sequenceA</span><span class="ot">  ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> t (f a) <span class="ot">-&gt;</span> f (t a)</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span><span class="ot">   ::</span> <span class="dt">Monad</span> m       <span class="ot">=&gt;</span> t (m a) <span class="ot">-&gt;</span> m (t a)</span></code></pre></div>
<p>There are also <code>sequence_</code> and <code>sequenceA_</code> variants that discard the results of the action.</p>
<h3 id="running-readert-mt-with-multiple-inputs">Running ReaderT MT with Multiple Inputs</h3>
<p>Let’s use <em>mapM</em> to run our ReaderT stack with multiple input values:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>  result3 <span class="ot">&lt;-</span> runWriterT (<span class="fu">mapM</span> (runReaderT process') peopleDb) <span class="co">-- :: ([String], String)</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> people <span class="ot">=</span> <span class="fu">fst</span> result3</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">log</span>    <span class="ot">=</span> <span class="fu">snd</span> result3</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">putStrLn</span> <span class="st">&quot;\n\nReaderT values:\n&quot;</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">mapM_</span> <span class="fu">putStrLn</span> people</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> <span class="fu">putStrLn</span> <span class="st">&quot;\nWriterT log:\n&quot;</span></span></code></pre></div>
<p>The <em>mapM</em> function is run as follows:</p>
<ol type="1">
<li>Each <em>runReaderT process’</em> is supplied a Person from the <em>peopleDb</em> function, which then returns a WriterT String IO String.</li>
<li>These results are then collected as a WriterT String IO [String].</li>
</ol>
<p>Here’s how we derive the result by replacing each type parameter with the actual types:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell scrollx"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- replacing a with Person:</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM</span>    (<span class="dt">Person</span> <span class="ot">-&gt;</span> m b) t <span class="dt">Person</span>  <span class="ot">-&gt;</span> m (t b)</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- replacing t with []:</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM</span>    (<span class="dt">Person</span> <span class="ot">-&gt;</span> m b) [<span class="dt">Person</span>]  <span class="ot">-&gt;</span> m [b]</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- replacing m (the Monad) with WriterT String IO</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> [<span class="dt">Person</span>] <span class="ot">-&gt;</span> <span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span> [b]</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- replacing b with String</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> [<span class="dt">Person</span>] <span class="ot">-&gt;</span> <span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span> [<span class="dt">String</span>]</span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- which returns the this result:</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a><span class="dt">WriterT</span> <span class="dt">String</span> <span class="dt">IO</span> [<span class="dt">String</span>]</span></code></pre></div>
<p>The final output is:</p>
<pre class="terminal scrollx"><code>Alex Fontaine
Looking up Person. Found person: Alex Fontaine.
Alex Fontaine
Looking up Person... Found person: Alex Fontaine.


ReaderT values:

Alex Fontaine
Philip Carpenter
Kim Lynch

WriterT log:

Looking up Person... Found person: Alex Fontaine. Looking up Person... Found person: Philip Carpenter. Looking up Person... Found person: Kim Lynch.</code></pre>
<p>I hope this walk-through has made using Monad Transformers a little more approachable.</p>
<p>The code for these examples can be found <a href="https://github.com/ssanj/readert-writert">Github</a>.</p>
<p><strong>References</strong></p>
<ol type="1">
<li><a href="https://stackoverflow.com/questions/43840588/use-readert-maybe-or-maybet-reader#43840589">use-readert-maybe-or-maybet-reader</a></li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Monad_transformers">Monad_transformers</a></li>
<li><a href="https://stackoverflow.com/questions/11684321/how-to-play-with-control-monad-writer-in-haskell">how-to-play-with-control-monad-writer-in-haskell</a></li>
</ol>
          </article>
        </div>
        
          <div id="disqus_thread"></div>
          <script>
              /**
              *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
              *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */

              var disqus_config = function () {
              this.page.url = 'https://ssanj.github.io' + '/posts/2018-01-12-stacking-the-readert-writert-monad-transformer-stack-in-haskell.html';
              this.page.identifier = '/posts/2018-01-12-stacking-the-readert-writert-monad-transformer-stack-in-haskell.html';
              };

              (function() { // DON'T EDIT BELOW THIS LINE
              var d = document, s = d.createElement('script');
              s.src = 'https://babyloncandle.disqus.com/embed.js';
              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        
    </div>


      
    </body>
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/typeahead.bundle.min.js"></script>
    <script src="../js/handlebars-v1.3.0.js"></script>
    <script src="../js/babyloncandle.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55156872-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-55156872-1');
    </script>
</html>
